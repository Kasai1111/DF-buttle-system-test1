<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>DUSTFALL - Advanced AI</title>
    <style>
      :root {
        --bg-color: #0d1117;
        --panel-bg: #161b22;
        --text-color: #c9d1d9;
        --accent-color: #f2cc60; /* Scavenger Gold */
        --atk-color: #ff7b72; /* Red */
        --grd-color: #79c0ff; /* Blue */
        --brk-color: #ffd33d; /* Yellow */
        --sp-color: #a841d8;
        --secret-color: #8b949e;

        /* Visual Assist Vars */
        --ep-color: #3fb950;
        --ep-ghost: #238636;
        --sp-bar-color: #a371f7;
        --sp-ghost: #6e40c9;
      }
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 5px;
        min-height: 100vh;
        -webkit-tap-highlight-color: transparent;
      }
      h1 {
        margin: 5px 0;
        font-size: 1.2rem;
        border-bottom: 2px solid var(--accent-color);
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      /* --- Setup Screen Styles --- */
      #setup-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--bg-color);
        z-index: 999;
        display: flex;
        flex-direction: column;
        align-items: center;
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
      }

      .setup-container {
        width: 100%;
        max-width: 800px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        padding-bottom: 50px;
      }

      .equip-section {
        background: var(--panel-bg);
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #30363d;
      }
      .equip-title {
        font-weight: bold;
        color: var(--accent-color);
        margin-bottom: 10px;
        border-bottom: 1px solid #30363d;
        padding-bottom: 5px;
        font-size: 0.9rem;
      }

      .equip-options {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }

      .equip-btn {
        background: #21262d;
        color: #c9d1d9;
        border: 1px solid #30363d;
        padding: 10px 16px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        touch-action: manipulation;
        font-size: 0.85rem;
      }
      .equip-btn:hover {
        background: #30363d;
      }
      .equip-btn.active {
        background: var(--accent-color);
        color: #0d1117;
        font-weight: bold;
        border-color: var(--accent-color);
      }

      .preview-area {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        background: #0d1117;
        padding: 10px;
        border-radius: 6px;
        min-height: 110px;
        border: 1px solid #30363d;
      }

      .start-btn {
        padding: 15px;
        background: linear-gradient(45deg, #238636, #2ea043);
        color: white;
        border: none;
        font-size: 1.2rem;
        font-weight: bold;
        border-radius: 8px;
        cursor: pointer;
        margin-top: 20px;
        box-shadow: 0 4px 10px rgba(46, 160, 67, 0.4);
        touch-action: manipulation;
      }
      .start-btn:hover {
        transform: scale(1.02);
      }
      /* --- AI Personality Tag Styles --- */
      .personality-tag {
        font-size: 0.75rem;
        color: #8b949e;
        border: 1px solid #30363d;
        background: rgba(22, 27, 34, 0.6);
        padding: 1px 8px;
        border-radius: 4px;
        letter-spacing: 1px;
        margin-left: 5px;
        text-shadow: none;
        font-weight: normal;
        display: inline-block;
        vertical-align: middle;
      }
      /* --- Existing Game Styles --- */
      .game-container {
        width: 100%;
        max-width: 600px;
        display: none;
        flex-direction: column;
        gap: 8px;
        padding-bottom: 20px;
      }
      .panel {
        background: var(--panel-bg);
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid #30363d;
        position: relative;
        transition: border-color 0.3s;
      }

      /* Intel Box */
      .intel-box {
        background: rgba(13, 17, 23, 0.5);
        border: 1px dashed #30363d;
        padding: 4px 8px;
        margin-top: 4px;
        font-size: 0.85rem;
        color: #8b949e;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .intel-val {
        color: var(--ep-color);
        font-weight: bold;
        font-size: 1.1rem;
      }

      /* Bars */
      .status-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
        font-size: 0.9rem;
      }

      .status-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 5px;
      }

      .bar-label {
        font-size: 0.75rem;
        color: #8b949e;
        margin-bottom: 2px;
        display: flex;
        justify-content: space-between;
      }
      .bar-wrap {
        width: 100%;
        background: #0d1117;
        height: 8px;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 0;
        position: relative;
        border: 1px solid #30363d;
      }
      .hp-bar {
        background: #da3633;
        height: 100%;
        width: 100%;
        transition: width 0.3s;
        position: relative;
        z-index: 2;
      }
      .pos-bar {
        background: #d29922;
        height: 100%;
        width: 100%;
        transition: width 0.3s;
        position: relative;
        z-index: 2;
      }

      /* Ghost Bars */
      .bar-ghost {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        width: 0%;
        z-index: 1;
        transition: width 0.3s;
      }
      .bar-fill {
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        width: 0%;
        z-index: 2;
        transition: width 0.3s;
      }
      .ep-fill {
        background: var(--ep-color);
      }
      .ep-ghost-bg {
        background: var(--ep-ghost);
      }
      .sp-fill {
        background: var(--sp-bar-color);
      }
      .sp-ghost-bg {
        background: var(--sp-ghost);
      }

      .resource-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 5px;
      }

      .burnout-tag {
        color: #ff7b72;
        font-weight: bold;
        animation: blink 1s infinite;
        display: none;
        border: 1px solid #ff7b72;
        padding: 0 4px;
        border-radius: 4px;
        font-size: 0.7rem;
      }
      @keyframes blink {
        50% {
          opacity: 0.5;
        }
      }

      /* --- Tag System Styles --- */
      .active-tags-container {
        display: flex;
        gap: 5px;
        margin: 4px 0;
        flex-wrap: wrap;
        min-height: 20px;
        padding-bottom: 0;
      }
      .tag-badge {
        font-size: 0.65rem;
        padding: 2px 6px;
        border-radius: 4px;
        background: #30363d;
        color: #e6edf3;
        border: 1px solid #484f58;
        display: inline-block;
        animation: slideInTag 0.3s;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      }
      @keyframes slideInTag {
        from {
          transform: scale(0);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Cards */
      .card-area {
        display: flex;
        gap: 5px;
        justify-content: center;
        min-height: 90px;
        flex-wrap: wrap;
      }
      .card {
        width: 70px;
        height: 100px;
        border-radius: 6px;
        border: 2px solid #30363d;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        cursor: pointer;
        position: relative;
        background: #161b22;
        user-select: none;
        transition: transform 0.2s;
        flex-shrink: 0;
        touch-action: manipulation;
      }
      .card:hover {
        transform: translateY(-8px);
      }
      .card.selected {
        border-color: var(--accent-color);
        box-shadow: 0 0 8px var(--accent-color);
        transform: translateY(-10px);
      }
      .card.disabled {
        opacity: 0.5;
        filter: grayscale(1);
        cursor: not-allowed;
        position: relative;
      }
      /* Jamming effect */
      .card.jammed::after {
        content: "JAMMED";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) rotate(-45deg);
        color: #ff7b72;
        font-weight: bold;
        font-size: 1rem;
        border: 2px solid #ff7b72;
        padding: 2px;
        background: rgba(0, 0, 0, 0.8);
      }

      .type-Attack {
        border-top: 4px solid var(--atk-color);
      }
      .type-Guard {
        border-top: 4px solid var(--grd-color);
      }
      .type-Break {
        border-top: 4px solid var(--brk-color);
        color: #f0f6fc;
      }
      .type-SP {
        border-top: 4px solid var(--sp-color);
        background: #1f1b2e;
      }
      .type-Secret {
        border-top: 4px solid var(--secret-color);
        background: #21262d;
      }

      .card-cost {
        font-size: 1.2rem;
        font-weight: bold;
        margin: 2px 0;
      }
      .card-type {
        font-weight: bold;
      }

      .ability-badge {
        font-size: 0.6rem;
        color: var(--accent-color);
        margin-top: 2px;
        border: 1px solid var(--accent-color);
        border-radius: 3px;
        padding: 0 2px;
        transform: scale(0.9);
      }
      .ability-setup {
        color: #58a6ff;
        border-color: #58a6ff;
      }
      .ability-exec {
        color: #ff7b72;
        border-color: #ff7b72;
      }

      /* Matchup Badges */
      .matchup-badge {
        position: absolute;
        font-size: 0.65rem;
        font-weight: bold;
        padding: 2px 4px;
        border-radius: 4px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        z-index: 10;
        text-transform: uppercase;
        animation: popBadge 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        min-width: 30px;
        text-align: center;
        line-height: 1;
      }
      .mb-slot1 {
        top: -8px;
        right: -8px;
      }
      .mb-slot2 {
        bottom: -8px;
        left: -8px;
      }

      @keyframes popBadge {
        from {
          transform: scale(0);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
      .mb-win {
        background: #238636;
        color: #fff;
        border: 1px solid #2ea043;
      }
      .mb-lose {
        background: #da3633;
        color: #fff;
        border: 1px solid #f85149;
      }
      .mb-draw {
        background: #6e7681;
        color: #fff;
        border: 1px solid #8b949e;
      }

      /* Slots */
      .slots-wrapper {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 5px 0;
      }
      .slot {
        width: 80px;
        height: 110px;
        border: 2px dashed #484f58;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        color: #8b949e;
        position: relative;
        transition: all 0.3s ease;
        cursor: pointer;
        touch-action: manipulation;
      }
      .slot:hover {
        border-color: #8b949e;
      }
      .active-battle-slot {
        border: 2px solid #f0f6fc !important;
        box-shadow: 0 0 15px var(--accent-color);
        transform: scale(1.1);
        background-color: #21262d;
        z-index: 10;
        color: #fff;
      }

      .slot-result-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.4rem;
        font-weight: bold;
        border-radius: 4px;
        animation: popIn 0.3s forwards;
        z-index: 20;
      }
      .res-win {
        color: #3fb950;
        text-shadow: 0 0 5px #3fb950;
      }
      .res-lose {
        color: #ff7b72;
        text-shadow: 0 0 5px #ff7b72;
      }
      .res-draw {
        color: #8b949e;
      }

      /* Trinity Mission Success Overlay */
      .trinity-success-overlay {
        position: absolute;
        top: -30px;
        width: 140%;
        text-align: center;
        background: rgba(242, 204, 96, 0.9);
        color: #000;
        font-weight: bold;
        padding: 4px;
        border-radius: 4px;
        font-size: 0.7rem;
        z-index: 100;
        box-shadow: 0 0 15px rgba(242, 204, 96, 0.8);
        animation: bouncePop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        border: 2px solid #fff;
      }

      @keyframes bouncePop {
        0% {
          transform: scale(0);
        }
        60% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes popIn {
        0% {
          transform: scale(0);
          opacity: 0;
        }
        80% {
          transform: scale(1.2);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Controls */
      .controls {
        display: flex;
        gap: 10px;
      }
      button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 4px;
        font-weight: bold;
        cursor: pointer;
        font-size: 1rem;
        touch-action: manipulation;
      }
      #btn-commit {
        background: var(--accent-color);
        color: #000;
      }
      #btn-commit:disabled {
        background: #484f58;
        cursor: not-allowed;
      }
      #btn-counter {
        background: #8957e5;
        color: #fff;
      }
      #btn-counter.active {
        background: #d2a8ff;
        color: #4a148c;
        border: 2px solid #fff;
      }

      #log {
        height: 80px;
        overflow-y: auto;
        background: #000;
        color: #3fb950;
        padding: 8px;
        font-family: monospace;
        font-size: 0.85rem;
        border-radius: 4px;
        border: 1px solid #30363d;
      }

      /* Type Chart */
      .type-chart-container {
        position: fixed;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(22, 27, 34, 0.95);
        border: 1px solid #30363d;
        border-radius: 12px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        z-index: 100;
        width: 100px;
      }
      .tc-title {
        font-size: 0.75rem;
        color: #8b949e;
        margin-bottom: 5px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .tc-node {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 0.8rem;
        color: #0d1117;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
        position: relative;
        z-index: 2;
      }
      .tc-atk {
        background: var(--atk-color);
        border: 2px solid #ffa198;
      }
      .tc-brk {
        background: var(--brk-color);
        border: 2px solid #ffeeba;
      }
      .tc-grd {
        background: var(--grd-color);
        border: 2px solid #a5d6ff;
      }
      .tc-arrow {
        font-size: 1.5rem;
        color: #8b949e;
        line-height: 0.8;
      }
      .tc-loop-arrow {
        font-size: 0.7rem;
        color: #8b949e;
        margin-top: -5px;
      }

      .context-banner {
        background: linear-gradient(90deg, #2f371f, #374151);
        border: 1px solid #4b5563;
        color: #e5e7eb;
        padding: 8px 15px;
        text-align: center;
        margin: 5px 0;
        font-size: 0.95rem;
        border-radius: 4px;
        box-shadow: 0 0 10px rgba(75, 85, 99, 0.5);
        display: none;
        animation: slideIn 0.5s ease-out;
      }
      .context-highlight {
        font-weight: bold;
        color: var(--accent-color);
        text-decoration: underline;
      }
      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      /* --- Ability Cut-in Announcement --- */
      #ability-cutin {
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.9);
        background: rgba(13, 17, 23, 0.95);
        border: 2px solid var(--accent-color);
        box-shadow: 0 0 20px rgba(242, 204, 96, 0.5);
        color: #fff;
        padding: 20px 40px;
        z-index: 3000;
        text-align: center;
        border-radius: 8px;
        display: none;
        opacity: 0;
        pointer-events: none;
      }

      #ability-cutin.active {
        display: block;
        animation: cutinPop 2.5s ease-out forwards;
      }

      .cutin-user {
        font-size: 1rem;
        color: #8b949e;
        margin-bottom: 5px;
        text-transform: uppercase;
      }

      .cutin-name {
        font-size: 1.8rem;
        font-weight: bold;
        color: var(--accent-color);
        text-shadow: 0 0 10px #b08800;
        margin-bottom: 5px;
      }

      .cutin-desc {
        font-size: 0.9rem;
        color: #c9d1d9;
      }

      @keyframes cutinPop {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.5);
        }
        15% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1.1);
        }
        25% {
          transform: translate(-50%, -50%) scale(1);
        }
        85% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -60%);
        }
      }
      /* --- Tooltip Styles --- */
      #card-tooltip {
        position: fixed;
        background: rgba(22, 27, 34, 0.98);
        border: 1px solid var(--accent-color);
        color: #fff;
        padding: 12px;
        border-radius: 8px;
        pointer-events: auto;
        z-index: 2000;
        width: max-content;
        max-width: 340px;
        min-width: 280px;

        display: none;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 1);
        font-size: 0.85rem;
        line-height: 1.4;
        white-space: normal;
        cursor: pointer;
        text-align: left;
      }

      #card-tooltip::after {
        content: "タップで閉じる";
        display: block;
        font-size: 0.6rem;
        color: #888;
        text-align: right;
        margin-top: 8px;
      }
      #card-tooltip strong {
        color: var(--accent-color);
        font-size: 0.95rem;
        display: block;
        margin-bottom: 5px;
        border-bottom: 1px solid #444;
        padding-bottom: 3px;
        text-align: left;
      }

      #card-tooltip .tooltip-stat {
        color: #ffcc80;
        font-weight: bold;
        display: inline-block;
        margin-right: 8px;
      }

      #card-tooltip .tooltip-desc {
        margin-top: 8px;
        color: #e0e0e0;
        font-size: 0.8rem;
        text-align: left;
        line-height: 1.5;
        border-top: 1px solid #444;
        padding-top: 5px;
      }

      /* カード表面のステータス表示 */
      .card-stats {
        font-size: 0.8rem;
        font-weight: bold;
        color: #fff;
        text-shadow: 1px 1px 0 #000;
        display: flex;
        flex-direction: column;
        gap: 1px;
        margin-top: 2px;
      }
      .stat-row {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 3px;
      }

      @media (max-width: 900px) {
        .type-chart-container {
          position: static;
          transform: none;
          flex-direction: row;
          width: 100%;
          max-width: 600px;
          margin-top: 20px;
          justify-content: center;
          background: transparent;
          border: none;
          box-shadow: none;
        }
        .tc-arrow {
          transform: rotate(-90deg);
          margin: 0 5px;
        }
        .tc-loop-arrow {
          display: none;
        }
        .tc-node {
          width: 60px;
          height: 60px;
          font-size: 0.7rem;
        }
      }
    </style>
  </head>
  <body>
    <div id="card-tooltip"></div>
    <div id="ability-cutin">
      <div class="cutin-user" id="ac-user">PLAYER</div>
      <div class="cutin-name" id="ac-name">ABILITY NAME</div>
      <div class="cutin-desc" id="ac-desc">Description text...</div>
    </div>
    <div id="setup-screen">
      <h1>DUSTFALL - Scavenger Setup</h1>
      <div class="setup-container">
        <div class="equip-section">
          <div class="equip-title">1. WEAPON (4 Cards)</div>
          <div class="equip-options" id="opt-weapon"></div>
          <div class="preview-area" id="prev-weapon"></div>
        </div>

        <div class="equip-section">
          <div class="equip-title">2. ARMOR (3 Cards)</div>
          <div class="equip-options" id="opt-armor"></div>
          <div class="preview-area" id="prev-armor"></div>
        </div>

        <div class="equip-section">
          <div class="equip-title">3. ACCESSORY (3 Cards)</div>
          <div class="equip-options" id="opt-acc"></div>
          <div class="preview-area" id="prev-acc"></div>
        </div>

        <button class="start-btn" onclick="startGame()">BATTLE START</button>
      </div>
    </div>

    <div class="game-container">
      <div class="panel" id="e-panel">
        <div class="status-row">
          <div style="display: flex; align-items: center">
            <strong>ENEMY</strong>
            <span id="e-personality" class="personality-tag"></span>
          </div>
          <span class="burnout-tag" id="e-burnout">BURNOUT</span>
        </div>

        <div class="status-grid">
          <div>
            <div class="bar-label">
              <span>HP: <span id="e-hp"></span></span>
            </div>
            <div class="bar-wrap"><div class="hp-bar" id="e-hp-bar"></div></div>
          </div>
          <div>
            <div class="bar-label">
              <span>姿勢値: <span id="e-pos"></span></span>
            </div>
            <div class="bar-wrap">
              <div class="pos-bar" id="e-pos-bar"></div>
            </div>
          </div>
        </div>

        <div class="active-tags-container" id="e-tags"></div>

        <div class="resource-grid">
          <div>
            <div class="bar-label">
              <span>EP: <span id="e-ep"></span></span>
            </div>
            <div class="bar-wrap">
              <div class="bar-fill ep-fill" id="e-ep-fill"></div>
            </div>
          </div>
          <div>
            <div class="bar-label">
              <span>SP: <span id="e-sp"></span></span>
            </div>
            <div class="bar-wrap">
              <div class="bar-fill sp-fill" id="e-sp-fill"></div>
            </div>
          </div>
        </div>

        <div class="intel-box" id="e-intel-box">
          <span>⚠ 合計消費EP量:</span>
          <span class="intel-val" id="e-pending-cost">0 EP</span>
        </div>

        <hr style="border: 0; border-top: 1px solid #30363d; margin: 4px 0" />
        <div
          style="
            font-size: 0.8rem;
            text-align: center;
            color: #888;
            margin-bottom: 2px;
          "
        ></div>
        <div class="card-area" id="enemy-hand-view"></div>
      </div>

      <div id="battle-context" class="context-banner">
        <span id="context-msg"></span>
      </div>

      <div style="text-align: center">
        <div class="slots-wrapper">
          <div class="slot" id="e-slot1">Enemy<br />Slot 1</div>
          <div class="slot" id="e-slot2">Enemy<br />Slot 2</div>
        </div>
        <div style="font-weight: bold; color: #888; margin: 2px 0">VS</div>
        <div class="slots-wrapper">
          <div class="slot" id="p-slot1" onclick="clearSlot(1)">
            Tap Card<br />to Set
          </div>
          <div class="slot" id="p-slot2" onclick="clearSlot(2)">
            Tap Card<br />to Set
          </div>
        </div>
      </div>

      <div class="panel" id="p-panel">
        <div class="status-row">
          <strong>PLAYER</strong>
          <span class="burnout-tag" id="p-burnout">BURNOUT</span>
        </div>

        <div class="status-grid">
          <div>
            <div class="bar-label">
              <span>HP: <span id="p-hp"></span></span>
            </div>
            <div class="bar-wrap"><div class="hp-bar" id="p-hp-bar"></div></div>
          </div>
          <div>
            <div class="bar-label">
              <span>姿勢値: <span id="p-pos"></span></span>
            </div>
            <div class="bar-wrap">
              <div class="pos-bar" id="p-pos-bar"></div>
            </div>
          </div>
        </div>

        <div class="active-tags-container" id="p-tags"></div>

        <div class="resource-grid">
          <div>
            <div class="bar-label">
              <span>EP: <span id="p-ep-txt"></span></span>
            </div>
            <div class="bar-wrap">
              <div class="bar-ghost ep-ghost-bg" id="p-ep-ghost"></div>
              <div class="bar-fill ep-fill" id="p-ep-fill"></div>
            </div>
          </div>
          <div>
            <div class="bar-label">
              <span>SP: <span id="p-sp-txt"></span></span>
            </div>
            <div class="bar-wrap">
              <div class="bar-ghost sp-ghost-bg" id="p-sp-ghost"></div>
              <div class="bar-fill sp-fill" id="p-sp-fill"></div>
            </div>
          </div>
        </div>

        <hr style="border: 0; border-top: 1px solid #30363d; margin: 4px 0" />
        <div class="card-area" id="player-hand-view"></div>
      </div>

      <div class="controls">
        <button id="btn-counter" onclick="toggleCounter()">
          SP カウンター攻撃
        </button>
        <button id="btn-commit" onclick="commitTurn()">コマンド決定</button>
      </div>

      <div id="log">Game Initialized...</div>
    </div>

    <div class="type-chart-container">
      <div class="tc-title">RULE</div>
      <div class="tc-node tc-atk"><span>Attack</span></div>
      <div class="tc-arrow">↓</div>
      <div class="tc-node tc-brk"><span>Break</span></div>
      <div class="tc-arrow">↓</div>
      <div class="tc-node tc-grd"><span>Guard</span></div>
      <div class="tc-arrow">↓</div>
      <div class="tc-loop-arrow">(to Attack)</div>
      <div
        style="
          margin-top: 10px;
          border-top: 1px dashed #666;
          padding-top: 5px;
          font-size: 0.7rem;
          color: var(--sp-color);
          text-align: center;
        "
      >
        <span style="color: var(--accent-color)">ELEMENTAL SURGE!</span><br />
        チャンス発生時<br />
        指定属性で<br />
        Slot1勝利せよ！
      </div>
    </div>

    <script>
      /**
       * DUSTFALL - Equipment & Battle Logic
       */
      const isTouchDevice =
        "ontouchstart" in window || navigator.maxTouchPoints > 0;

      const MAX_HP = 50;
      const MAX_POSTURE = 20;
      const MAX_EP = 8;
      const MAX_SP = 5;
      const COUNTER_EP_COST = 4;

      const TYPE = {
        ATTACK: "Attack",
        GUARD: "Guard",
        BREAK: "Break",
        SP: "SP",
      };

      const WIN_MAP = {
        [TYPE.ATTACK]: TYPE.BREAK,
        [TYPE.BREAK]: TYPE.GUARD,
        [TYPE.GUARD]: TYPE.ATTACK,
      };

      // --- Ability Definitions ---
      const ABILITIES = {
        EP_CHARGE: {
          id: "EP_CHARGE",
          type: "INSTANT",
          name: "急速充電",
          desc: "【単発】Slot1勝利時、自身のEPを3回復する。",
        },
        SMOKE: {
          id: "SMOKE",
          type: "INSTANT",
          name: "煙幕",
          desc: "【単発】Slot1勝利時、2ターンの間 敵の手札を強制的に隠す。",
        },
        FEINT: {
          id: "FEINT",
          type: "INSTANT",
          name: "EPロスト",
          desc: "【単発】Slot1勝利時、相手のEPを2減らす（妨害）。",
        },
        PREP_ATK: {
          id: "PREP_ATK",
          type: "INSTANT",
          name: "予備動作",
          desc: "【単発】Slot1勝利時、山札から「Attack」カードを探す。",
        },
        PREDICTION: {
          id: "PREDICTION",
          type: "INSTANT",
          name: "未来予測",
          desc: "【単発】Slot1勝利時、次ターンの敵のセットカードを可視化する。",
        },
        ARMOR_BREAK: {
          id: "ARMOR_BREAK",
          type: "SETUP",
          name: "装甲溶解",
          tag: "ARMOR_BROKEN",
          tagName: "装甲劣化",
          desc: "【設置】Slot1勝利時: 敵に『装甲劣化』タグを付与。",
        },
        FATAL_THRUST: {
          id: "FATAL_THRUST",
          type: "EXECUTE",
          name: "急所突き",
          reqTag: "ARMOR_BROKEN",
          desc: "【実行】Slot2勝利時: 敵が『装甲劣化』ならダメージ3倍。",
        },
        OIL_JAR: {
          id: "OIL_JAR",
          type: "SETUP",
          name: "燃料散布",
          tag: "OILED",
          tagName: "引火性",
          desc: "【設置】Slot1勝利時: 敵に『引火性』タグを付与。",
        },
        FIRE_BLAST: {
          id: "FIRE_BLAST",
          type: "EXECUTE",
          name: "点火",
          reqTag: "OILED",
          desc: "【実行】Slot2勝利時: 敵が『引火性』ならDmg 2倍 + 敵Burnout付与。",
        },
        PURIFY: {
          id: "PURIFY",
          type: "CLEAR",
          name: "ナノ洗浄",
          desc: "【単発】Slot1勝利時: 自身の悪い状態タグを全て解除する。",
        },
        OVERCLOCK: {
          id: "OVERCLOCK",
          type: "SETUP",
          name: "リミッター解除",
          tag: "OVERLOAD",
          tagName: "暴走",
          desc: "【設置】Slot1勝利時: 自身に『暴走』付与(3T)。全コスト0になるが、終了時に強制Burnout。",
        },
        VIRUS_INSTALL: {
          id: "VIRUS_INSTALL",
          type: "SETUP",
          name: "ウイルス送信",
          tag: "INFECTED",
          tagName: "感染",
          desc: "【設置】Slot1勝利時: 敵に『感染』付与(3T)。毎ターン開始時にEP-2。",
        },
        POLARITY_SHIFT: {
          id: "POLARITY_SHIFT",
          type: "INSTANT",
          name: "位相反転",
          desc: "【単発】Slot1勝利時、このターンSlot2の三竦みを逆転させる（AttackがGuardに勝つ等）。",
        },
        GRAVITY: {
          id: "GRAVITY",
          type: "INSTANT",
          name: "グラビティ",
          desc: "【単発】Slot1勝利時、敵Slot2のコスト+3。EP不足なら強制破壊。",
        },
        IRON_WILL: {
          id: "IRON_WILL",
          type: "INSTANT",
          name: "不屈の精神",
          desc: "【単発/HP30%以下】Slot1勝利時、被ダメ0＆次ターンEP回復2倍。",
        },
        DESPERATE_STRIKE: {
          id: "DESPERATE_STRIKE",
          type: "INSTANT",
          name: "捨て身の一撃",
          desc: "【単発/劣勢時】Slot1勝利時、現在姿勢値を半減しその分攻撃力に加算。",
        },
        PHANTOM_WEIGHT: {
          id: "PHANTOM_WEIGHT",
          type: "INSTANT",
          name: "幻影質量",
          desc: "【単発】次ターン、Slot1の判定コストを6として扱う(EP消費はそのまま)。",
        },
        JAMMING: {
          id: "JAMMING",
          type: "INSTANT",
          name: "ジャミング",
          desc: "【単発】次ターン、敵の手札1枚を使用不可にする。",
        },
        MANA_BARRIER: {
          id: "MANA_BARRIER",
          type: "INSTANT",
          name: "電磁バリア",
          desc: "【単発】HPダメ無効(SP除)。代償:EP-3。",
        },
        EMERGENCY_REPAIR: {
          id: "EMERGENCY_REPAIR",
          type: "INSTANT",
          name: "緊急修復",
          desc: "【単発】HPを10回復する。",
        },
        ENERGY_DRAIN: {
          id: "ENERGY_DRAIN",
          type: "INSTANT",
          name: "EP吸収",
          desc: "【単発】敵EP-3。",
        },
        STUN_SHOT: {
          id: "STUN_SHOT",
          type: "INSTANT",
          name: "重めの一手",
          desc: "【単発】敵手札の最大コストカードのコスト+3。",
        },
        CORROSION: {
          id: "CORROSION",
          type: "INSTANT",
          name: "有毒ガス",
          desc: "【単発】敵に毒付与(2T)。毎ターンHP-3。",
        },
        SCAN: {
          id: "SCAN",
          type: "SETUP",
          name: "スキャン",
          tag: "DETECTED",
          tagName: "解析済",
          desc: "【設置】Slot1勝利時: 敵に『解析済』タグを付与。",
        },
        SONAR: {
          id: "SONAR",
          type: "SETUP",
          name: "ソナー",
          tag: "RESONANCE",
          tagName: "共鳴",
          desc: "【設置】Slot1勝利時: 敵に『共鳴』タグを付与。",
        },
        DATA_DRAIN: {
          id: "DATA_DRAIN",
          type: "EXECUTE",
          name: "SP強奪",
          reqTag: "DETECTED",
          desc: "【実行】Slot2勝利時: 敵が『解析済』ならSPを全て奪う。",
        },
        POSTURE_BREAK_EXEC: {
          id: "POSTURE_BREAK_EXEC",
          type: "EXECUTE",
          name: "クラッシュ",
          reqTag: "ARMOR_BROKEN",
          desc: "【実行】Slot2勝利時: 敵が『装甲劣化』なら強制ブレイク(姿勢0)。",
        },
        ECHO_STRIKE: {
          id: "ECHO_STRIKE",
          type: "EXECUTE",
          name: "二連撃",
          reqTag: "RESONANCE",
          desc: "【実行】Slot2勝利時: 敵が『共鳴』ならダメージを2回与える(x2)。",
        },
        MEMORY_LEAK: {
          id: "MEMORY_LEAK",
          type: "EXECUTE",
          name: "SP破壊",
          reqTag: "INFECTED",
          desc: "【実行】Slot2勝利時: 敵が『感染』なら与ダメの50%分SP減少。",
        },
      };

      const EQUIPMENT = {
        WEAPONS: {
          鉄塊の大剣: [
            {
              type: TYPE.ATTACK,
              cost: 5,
              dmg: 18,
              pos: 5,
              ability: "GRAVITY",
            },
            {
              type: TYPE.ATTACK,
              cost: 3,
              dmg: 15,
              pos: 5,
              ability: "DESPERATE_STRIKE",
            },
            { type: TYPE.BREAK, cost: 4, pos: 15 },
            { type: TYPE.SP, cost: 7, dmg: 50, pos: 20, isSP: true },
          ],
          熱断の刀: [
            { type: TYPE.ATTACK, cost: 1, dmg: 6, pos: 2, ability: "OIL_JAR" },
            {
              type: TYPE.ATTACK,
              cost: 2,
              dmg: 8,
              pos: 2,
              ability: "FIRE_BLAST",
            },
            { type: TYPE.GUARD, cost: 2, arm: 6 },
            { type: TYPE.SP, cost: 5, dmg: 30, pos: 5, isSP: true },
          ],
          スタンパイル: [
            { type: TYPE.BREAK, cost: 2, pos: 10, ability: "ARMOR_BREAK" },
            {
              type: TYPE.ATTACK,
              cost: 3,
              dmg: 14,
              pos: 6,
              ability: "FATAL_THRUST",
            },
            {
              type: TYPE.ATTACK,
              cost: 5,
              dmg: 18,
              pos: 5,
              ability: "POSTURE_BREAK_EXEC",
            },
            { type: TYPE.SP, cost: 6, dmg: 40, pos: 20, isSP: true },
          ],
          ハックナイフ: [
            {
              type: TYPE.ATTACK,
              cost: 1,
              dmg: 5,
              pos: 1,
              ability: "VIRUS_INSTALL",
            },
            {
              type: TYPE.ATTACK,
              cost: 2,
              dmg: 10,
              pos: 3,
              ability: "MEMORY_LEAK",
            },
            { type: TYPE.BREAK, cost: 2, pos: 8, ability: "JAMMING" },
            { type: TYPE.SP, cost: 4, dmg: 20, pos: 5, isSP: true },
          ],
          共鳴ブラスター: [
            { type: TYPE.BREAK, cost: 2, pos: 5, ability: "SCAN" },
            { type: TYPE.ATTACK, cost: 2, dmg: 8, pos: 2, ability: "SONAR" },
            {
              type: TYPE.ATTACK,
              cost: 4,
              dmg: 14,
              pos: 5,
              ability: "ECHO_STRIKE",
            },
            { type: TYPE.SP, cost: 6, dmg: 45, pos: 10, isSP: true },
          ],
        },
        ARMORS: {
          廃材の鎧: [
            {
              type: TYPE.GUARD,
              cost: 2,
              arm: 8,
              ability: "PREP_ATK",
            },
            { type: TYPE.GUARD, cost: 1, arm: 5 },
            { type: TYPE.BREAK, cost: 3, pos: 10 },
          ],
          光学迷彩コート: [
            { type: TYPE.GUARD, cost: 2, arm: 6, ability: "SMOKE" },
            { type: TYPE.GUARD, cost: 2, arm: 8, ability: "FEINT" },
            { type: TYPE.GUARD, cost: 1, arm: 4 },
          ],
          反応装甲: [
            {
              type: TYPE.GUARD,
              cost: 4,
              arm: 20,
              ability: "IRON_WILL",
            },
            {
              type: TYPE.GUARD,
              cost: 2,
              arm: 10,
              ability: "MANA_BARRIER",
            },
            { type: TYPE.BREAK, cost: 3, pos: 8 },
          ],
          自動修復スーツ: [
            {
              type: TYPE.GUARD,
              cost: 2,
              arm: 6,
              ability: "EMERGENCY_REPAIR",
            },
            { type: TYPE.GUARD, cost: 2, arm: 8, ability: "PURIFY" },
            { type: TYPE.GUARD, cost: 1, arm: 5 },
          ],
          EP炉心: [
            { type: TYPE.GUARD, cost: 2, arm: 8, ability: "EP_CHARGE" },
            {
              type: TYPE.BREAK,
              cost: 2,
              pos: 8,
              ability: "ENERGY_DRAIN",
            },
            { type: TYPE.GUARD, cost: 1, arm: 5 },
          ],
        },
        ACCESSORIES: {
          解除キー: [
            { type: TYPE.BREAK, cost: 3, pos: 8, ability: "OVERCLOCK" },
            { type: TYPE.BREAK, cost: 3, pos: 8 },
            { type: TYPE.ATTACK, cost: 5, dmg: 20, pos: 0 },
          ],
          戦術バイザー: [
            {
              type: TYPE.GUARD,
              cost: 2,
              arm: 6,
              ability: "PREDICTION",
            },
            { type: TYPE.BREAK, cost: 2, pos: 6, ability: "SCAN" },
            { type: TYPE.ATTACK, cost: 3, dmg: 10, pos: 5 },
          ],
          位相ズラし装置: [
            {
              type: TYPE.BREAK,
              cost: 3,
              pos: 10,
              ability: "POLARITY_SHIFT",
            },
            {
              type: TYPE.ATTACK,
              cost: 2,
              dmg: 8,
              pos: 2,
              ability: "PHANTOM_WEIGHT",
            },
            { type: TYPE.GUARD, cost: 2, arm: 6 },
          ],
          汚染アンプル: [
            {
              type: TYPE.ATTACK,
              cost: 1,
              dmg: 5,
              pos: 2,
              ability: "CORROSION",
            },
            { type: TYPE.BREAK, cost: 2, pos: 8, ability: "STUN_SHOT" },
            { type: TYPE.GUARD, cost: 1, arm: 4 },
          ],
          解析端末: [
            { type: TYPE.BREAK, cost: 3, pos: 10, ability: "DATA_DRAIN" },
            { type: TYPE.BREAK, cost: 2, pos: 5, ability: "SCAN" },
            { type: TYPE.GUARD, cost: 2, arm: 6 },
          ],
        },
      };

      let selectedWeapon = Object.keys(EQUIPMENT.WEAPONS)[0];
      let selectedArmor = Object.keys(EQUIPMENT.ARMORS)[0];
      let selectedAcc = Object.keys(EQUIPMENT.ACCESSORIES)[0];

      let turn = 1;
      let player, enemy;
      let pSlots = [null, null];
      let isCounterMode = false;
      let hasUsedCounter = false;
      let isAnimating = false;
      let pendingEnemySlots = [null, null];

      let isPolarityReversed = false;

      const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

      function initSetup() {
        renderEquipOptions("weapon", EQUIPMENT.WEAPONS, selectedWeapon);
        renderEquipOptions("armor", EQUIPMENT.ARMORS, selectedArmor);
        renderEquipOptions("acc", EQUIPMENT.ACCESSORIES, selectedAcc);
        updatePreviews();
      }

      function renderEquipOptions(category, data, currentSelection) {
        const container = document.getElementById(`opt-${category}`);
        container.innerHTML = "";
        Object.keys(data).forEach((key) => {
          const btn = document.createElement("div");
          btn.className = `equip-btn ${
            key === currentSelection ? "active" : ""
          }`;
          btn.innerText = key;
          btn.onclick = () => {
            if (category === "weapon") selectedWeapon = key;
            if (category === "armor") selectedArmor = key;
            if (category === "acc") selectedAcc = key;
            initSetup();
          };
          container.appendChild(btn);
        });
      }

      function updatePreviews() {
        renderCardsToPreview("prev-weapon", EQUIPMENT.WEAPONS[selectedWeapon]);
        renderCardsToPreview("prev-armor", EQUIPMENT.ARMORS[selectedArmor]);
        renderCardsToPreview("prev-acc", EQUIPMENT.ACCESSORIES[selectedAcc]);
      }

      function renderCardsToPreview(elementId, cards) {
        const el = document.getElementById(elementId);
        el.innerHTML = "";
        cards.forEach((c) => {
          const div = createCardDiv(c, false, -99);
          div.onclick = null;
          if (isTouchDevice) {
            div.ontouchstart = null;
            div.ontouchend = null;
            div.ontouchmove = null;
          }
          el.appendChild(div);
        });
      }

      function startGame() {
        document.getElementById("setup-screen").style.display = "none";
        document.querySelector(".game-container").style.display = "flex";
        initBattle();
      }

      function showTooltip(e, card) {
        if (!card) return;
        if (e && e.stopPropagation) e.stopPropagation();

        const tt = document.getElementById("card-tooltip");

        let statsText = "";
        if (card.dmg)
          statsText += `<span class="tooltip-stat">HP-${card.dmg} (Dmg)</span>\n`;
        if (card.pos)
          statsText += `<span class="tooltip-stat">Posture-${card.pos}</span>\n`;
        if (card.arm)
          statsText += `<span class="tooltip-stat">Armor ${card.arm}</span>\n`;
        if (card.isSP)
          statsText += `<span style="color:var(--sp-bar-color)">SP必殺技 (Cost ${card.cost})</span>\n`;

        let abilityText = "";
        if (card.ability && ABILITIES[card.ability]) {
          const ab = ABILITIES[card.ability];
          let typeColor = "#f2cc60";
          if (ab.type === "SETUP") typeColor = "#79c0ff";
          if (ab.type === "EXECUTE") typeColor = "#ff7b72";

          abilityText = `<div class="tooltip-desc">
            <span style="color:${typeColor}; font-weight:bold">${ab.name}</span><br>
            ${ab.desc}
            </div>`;
        }

        tt.innerHTML = `
       <strong>${card.type} (Cost: ${card.cost})</strong>
       <div>${statsText}</div>
       ${abilityText}
       `;

        tt.style.display = "block";
        moveTooltip(e);
      }

      function moveTooltip(e) {
        const tt = document.getElementById("card-tooltip");
        if (!e) return;

        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else if (e.clientX !== undefined) {
          clientX = e.clientX;
          clientY = e.clientY;
        } else {
          return;
        }

        const offsetX = 15;
        const offsetY = isTouchDevice ? -150 : 15;

        let leftPos = Math.min(clientX + offsetX, window.innerWidth - 350);
        if (leftPos < 10) leftPos = 10;

        let topPos = clientY + offsetY;
        if (topPos < 10) topPos = clientY + 30;

        tt.style.left = leftPos + "px";
        tt.style.top = topPos + "px";
      }

      function hideTooltip() {
        const tt = document.getElementById("card-tooltip");
        tt.style.display = "none";
      }

      function buildDeck(wKey, aKey, accKey) {
        const wCards = JSON.parse(JSON.stringify(EQUIPMENT.WEAPONS[wKey]));
        const aCards = JSON.parse(JSON.stringify(EQUIPMENT.ARMORS[aKey]));
        const accCards = JSON.parse(
          JSON.stringify(EQUIPMENT.ACCESSORIES[accKey])
        );

        let deck = [...wCards, ...aCards, ...accCards];
        const spIndex = deck.findIndex((c) => c.isSP);
        let reservedSP = null;
        if (spIndex !== -1) {
          reservedSP = deck.splice(spIndex, 1)[0];
        }

        shuffle(deck);
        return { deck, reservedSP };
      }

      function createEntity(name, wKey, aKey, accKey) {
        const { deck, reservedSP } = buildDeck(wKey, aKey, accKey);
        const secret = deck.pop();

        const entity = {
          name,
          hp: MAX_HP,
          maxHp: MAX_HP,
          pos: MAX_POSTURE,
          maxPos: MAX_POSTURE,
          ep: 5,
          sp: 0,
          deck,
          hand: [],
          secret,
          reservedSP,
          burnout: false,
          breakState: false,
          justBroken: false,
          stealthTurns: 0,
          personalityWord: "",
          isTrinityReady: false,
          trinityTarget: null,
          tags: new Set(),
          overclockTurns: 0,
          virusTurns: 0,
          corrosionTurns: 0,
          damageImmune: false,
          doubleEpNext: false,
          revealSlots: false,
          phantomWeightPending: false,
          isPhantomWeight: false,
          isJammedPending: false,
          jammedIndices: [],
          isManaBarrier: false,
        };

        if (name === "Enemy") {
          const AI_STRATEGY_NAMES = Object.keys(AI_STRATEGIES);
          const randomStrategyName =
            AI_STRATEGY_NAMES[
              Math.floor(Math.random() * AI_STRATEGY_NAMES.length)
            ];
          entity.strategy = randomStrategyName;

          const words = AI_PERSONALITIES[randomStrategyName];
          if (words) {
            entity.personalityWord =
              words[Math.floor(Math.random() * words.length)];
          }
          log(
            `[System] Enemy Type: ${randomStrategyName} (${entity.personalityWord})`
          );
        }

        return entity;
      }

      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }

      function initBattle() {
        player = createEntity(
          "Player",
          selectedWeapon,
          selectedArmor,
          selectedAcc
        );
        const wKeys = Object.keys(EQUIPMENT.WEAPONS);
        const aKeys = Object.keys(EQUIPMENT.ARMORS);
        const accKeys = Object.keys(EQUIPMENT.ACCESSORIES);
        const ew = wKeys[Math.floor(Math.random() * wKeys.length)];
        const ea = aKeys[Math.floor(Math.random() * aKeys.length)];
        const eacc = accKeys[Math.floor(Math.random() * accKeys.length)];
        enemy = createEntity("Enemy", ew, ea, eacc);
        const pTag = document.getElementById("e-personality");
        if (enemy.personalityWord) {
          pTag.innerText = `《 ${enemy.personalityWord} 》`;
          pTag.style.display = "inline-block";
        } else {
          pTag.style.display = "none";
        }
        startTurn();
      }

      // --- Advanced AI Logic ---
      function getRealCost(entity, cost) {
        if (entity.tags.has("OVERLOAD")) return 0;
        return cost;
      }

      // 予測関数: プレイヤーがどの手札を使う可能性が高いか（簡易確率モデル）
      function predictPlayerHand(p, e) {
        let predictedHand = [...p.hand];
        if (p.secret) predictedHand.push({ ...p.secret, cost: 3 }); // Secretは平均値として扱う
        if (p.reservedSP && p.sp >= MAX_SP) predictedHand.push(p.reservedSP);

        // ジャミングされたカードは除外
        predictedHand = predictedHand.filter(
          (_, i) => !p.jammedIndices.includes(i)
        );

        // コストでフィルタリング (推定)
        // プレイヤーの行動予測: コストが高い順、または三すくみで有利なものを好む傾向
        // ここでは単純化のため、全候補を返す
        return predictedHand;
      }

      // シミュレーション＆スコアリング
      function runAdvancedAI(ai, opponent, weights) {
        // 1. カウンター判断 (INFJなどは高確率)
        if (!ai.hasUsedCounter && ai.ep >= 4) {
          if (opponent.sp >= MAX_SP || opponent.pos < 5) {
            // 相手がSP使いそう、または自分がピンチ
            if (Math.random() < weights.counterBias) {
              return { slots: [null, null], action: "COUNTER" };
            }
          }
        }

        let hand = ai.hand.map((c, i) => ({ ...c, originalIndex: i }));
        // SPカードがあれば候補に追加
        if (ai.reservedSP && ai.sp >= MAX_SP && !ai.hasUsedSP) {
          hand.push({ ...ai.reservedSP, originalIndex: -1 }); // -1 indicates SP
        }

        // ジャミング除外
        hand = hand.filter((c) =>
          c.originalIndex === -1
            ? true
            : !ai.jammedIndices.includes(c.originalIndex)
        );

        let validPairs = [];
        // [Card, Card], [Card, null], [null, Card], [null, null]
        // 組み合わせ生成
        for (let i = 0; i < hand.length; i++) {
          for (let j = 0; j < hand.length; j++) {
            if (i === j) continue; // 同じカードは2回使えない
            validPairs.push([hand[i], hand[j]]);
          }
          validPairs.push([hand[i], null]);
          validPairs.push([null, hand[i]]);
        }
        validPairs.push([null, null]);

        // 予算フィルタリング
        validPairs = validPairs.filter((pair) => {
          let c1 = pair[0] ? getRealCost(ai, pair[0].cost) : 0;
          let c2 = pair[1] ? getRealCost(ai, pair[1].cost) : 0;
          return c1 + c2 <= ai.ep;
        });

        if (validPairs.length === 0)
          return { slots: [null, null], action: "WAIT" };

        let bestScore = -Infinity;
        let bestPair = validPairs[0];

        const playerLikelyCards = predictPlayerHand(opponent, ai);

        validPairs.forEach((pair) => {
          let score = 0;
          const card1 = pair[0];
          const card2 = pair[1];

          // 基本: Trinity Mission ボーナス
          if (
            card1 &&
            ai.trinityTarget &&
            card1.type === ai.trinityTarget &&
            ai.isTrinityReady
          ) {
            score += 50 * weights.trinityFocus;
          }

          // 基本: EP効率 (残EP)
          const cost =
            (card1 ? getRealCost(ai, card1.cost) : 0) +
            (card2 ? getRealCost(ai, card2.cost) : 0);
          const remainingEP = ai.ep - cost;
          if (remainingEP === 0) score -= 10 * weights.efficiency; // 完売はリスク
          if (remainingEP > 2) score += 5 * weights.efficiency; // 温存ボーナス

          // 対プレイヤー シミュレーション (期待値計算)
          let winCount1 = 0;
          let winCount2 = 0;
          let totalSims = 0;

          // ランダムにプレイヤーの手札から数枚選んでシミュレート
          // 全通りやると重いので簡易化: プレイヤーの最強カードと最弱カードに対して評価
          playerLikelyCards.forEach((pCard) => {
            totalSims++;
            // Slot 1
            let s1Res = "DRAW";
            if (card1 && pCard) {
              if (WIN_MAP[card1.type] === pCard.type) s1Res = "WIN";
              else if (WIN_MAP[pCard.type] === card1.type) s1Res = "LOSE";
              else if (card1.cost > pCard.cost) s1Res = "WIN"; // 同系
            } else if (card1) s1Res = "WIN"; // 相手が出さない想定は甘いかもしれないが

            if (s1Res === "WIN") {
              winCount1++;
              score += 10;
              // アビリティ発動ボーナス
              if (card1.ability) {
                const ab = ABILITIES[card1.ability];
                if (ab.type === "SETUP") score += 20 * weights.setupPriority;
                if (ab.type === "INSTANT") score += 10;
              }
            } else if (s1Res === "LOSE") {
              score -= 15 * weights.defense; // 負けを嫌う
            }

            // Slot 2 (Slot1の結果による倍率変動は簡易考慮)
            let s2Res = "DRAW";
            // プレイヤーの2枚目は不明だが、同じカードは出ない。ここでは簡易的に同じカードリストと戦わせる
            // (厳密なシミュレーションより傾向を見る)
            if (card2 && pCard) {
              if (WIN_MAP[card2.type] === pCard.type) s2Res = "WIN";
              else if (WIN_MAP[pCard.type] === card2.type) s2Res = "LOSE";
            }

            if (s2Res === "WIN") {
              winCount2++;
              let dmg = card2.dmg || 0;
              let brk = card2.pos || 0;

              if (s1Res === "WIN") {
                dmg *= 1.2;
                brk *= 1.2;
              } // Slot1勝ち補正
              else if (s1Res === "LOSE") {
                dmg *= 0.25;
                brk *= 0.25;
              }

              score += dmg * weights.aggression;
              score += brk * weights.breakFocus;

              // Execute Bonus
              if (card2.ability) {
                const ab = ABILITIES[card2.ability];
                if (ab.type === "EXECUTE") {
                  if (opponent.tags.has(ab.reqTag)) {
                    score += 100; // コンボ成立は大優先
                  }
                }
              }
            }
          });

          // 性格による補正
          // AggressiveなAIは防御カード(Guard)の評価を下げる
          if (card1 && card1.type === "Guard") score -= 5 * weights.aggression;
          if (card1 && card1.type === "Attack") score += 5 * weights.aggression;

          if (score > bestScore) {
            bestScore = score;
            bestPair = pair;
          }
        });

        // Convert pair back to slots (handling SP separately if needed, though SP is just a card here)
        return { slots: bestPair, action: "COMMIT" };
      }

      // MBTI Profiles (Weights)
      // aggression: 攻撃優先度 (Dmg)
      // defense: 防御優先度 (被弾嫌悪)
      // breakFocus: 姿勢破壊優先度 (Posture)
      // efficiency: EP温存優先度 (0=使い切り, high=温存)
      // setupPriority: Setupアビリティの評価
      // trinityFocus: 指定属性勝利の執着度
      // counterBias: カウンター発動率
      const AI_PROFILES = {
        ISTJ: {
          aggression: 1.0,
          defense: 3.0,
          breakFocus: 1.0,
          efficiency: 2.0,
          setupPriority: 1.0,
          trinityFocus: 3.0,
          counterBias: 0.1,
        }, // 堅実・ルール厳守
        INFJ: {
          aggression: 1.0,
          defense: 1.5,
          breakFocus: 1.0,
          efficiency: 1.0,
          setupPriority: 2.0,
          trinityFocus: 1.0,
          counterBias: 0.8,
        }, // カウンター・読み
        ESTP: {
          aggression: 3.0,
          defense: 0.1,
          breakFocus: 1.0,
          efficiency: 0.0,
          setupPriority: 0.5,
          trinityFocus: 0.5,
          counterBias: 0.2,
        }, // 猪突猛進・EP全ツッパ
        ENTJ: {
          aggression: 2.0,
          defense: 0.5,
          breakFocus: 3.0,
          efficiency: 1.0,
          setupPriority: 3.0,
          trinityFocus: 1.5,
          counterBias: 0.1,
        }, // 破壊・コンボ・支配
        INTJ: {
          aggression: 1.0,
          defense: 2.0,
          breakFocus: 1.5,
          efficiency: 2.5,
          setupPriority: 3.0,
          trinityFocus: 1.0,
          counterBias: 0.3,
        }, // 長期計画・Setup重視
        ISFJ: {
          aggression: 0.8,
          defense: 4.0,
          breakFocus: 0.5,
          efficiency: 1.5,
          setupPriority: 1.0,
          trinityFocus: 1.5,
          counterBias: 0.2,
        }, // 超防御・回復
        INTP: {
          aggression: 1.5,
          defense: 1.0,
          breakFocus: 1.0,
          efficiency: 1.5,
          setupPriority: 2.0,
          trinityFocus: 0.5,
          counterBias: 0.5,
        }, // バランス・実験的
        ENFP: {
          aggression: 2.0,
          defense: 0.5,
          breakFocus: 0.5,
          efficiency: 0.5,
          setupPriority: 1.0,
          trinityFocus: 4.0,
          counterBias: 0.4,
        }, // 気分屋・Trinity大好き
      };

      const AI_STRATEGIES = {};
      Object.keys(AI_PROFILES).forEach((key) => {
        AI_STRATEGIES[key] = (ai, opponent) =>
          runAdvancedAI(ai, opponent, AI_PROFILES[key]);
      });

      const AI_PERSONALITIES = {
        ISTJ: ["規律", "堅実", "定石"],
        INFJ: ["受動的", "静観", "見切"],
        ESTP: ["好戦的", "無謀", "自信"],
        ENTJ: ["支配的", "計画的", "姑息"],
        INTJ: ["狡猾", "合理", "計画的"],
        ISFJ: ["臆病", "保守的", "慎重"],
        INTP: ["多角的", "奇襲", "変則的"],
        ENFP: ["博打", "運任せ", "楽観的"],
      };

      // --- Main Logic ---

      function startTurn() {
        pSlots = [null, null];
        isCounterMode = false;
        isAnimating = false;
        isPolarityReversed = false;

        [player, enemy].forEach((e) => {
          if (e.stealthTurns > 0) e.stealthTurns--;
          e.damageImmune = false;
          e.isManaBarrier = false;
          e.isPhantomWeight = false;

          if (e.phantomWeightPending) {
            e.isPhantomWeight = true;
            e.phantomWeightPending = false;
            log(`>> ${e.name} Phantom Weight Active: Slot 1 is Cost 6!`);
          }

          e.jammedIndices = [];
          if (e.isJammedPending) {
            const jammedIdx = Math.floor(Math.random() * 3);
            e.jammedIndices.push(jammedIdx);
            e.isJammedPending = false;
            log(`>> ${e.name} is JAMMED! Card #${jammedIdx + 1} unusable.`);
          }

          if (e.breakState) {
            e.burnout = true;
          }
          if (!e.burnout && !e.breakState) {
            e.pos = Math.min(e.maxPos, e.pos + 2.7);
          }

          let recovery = 4;
          if (e.doubleEpNext) {
            recovery = 8;
            log(`>> ${e.name} recovers DOUBLE EP (Iron Will)!`);
            e.doubleEpNext = false;
          }
          e.ep = Math.min(MAX_EP, e.ep + recovery);
          e.sp = Math.min(MAX_SP, e.sp + 1);

          if (e.tags.has("INFECTED")) {
            e.ep = Math.max(0, e.ep - 2);
            log(`[Virus] ${e.name} loses 2 EP from Infection.`);
            e.virusTurns--;
            if (e.virusTurns <= 0) {
              e.tags.delete("INFECTED");
              log(`[Virus] ${e.name}'s Infection cured.`);
            }
          }

          if (e.corrosionTurns > 0) {
            e.hp -= 3;
            log(`[Corrosion] ${e.name} takes 3 poison damage.`);
            e.corrosionTurns--;
          }

          if (e.tags.has("OVERLOAD")) {
            e.overclockTurns--;
            if (e.overclockTurns <= 0) {
              e.tags.delete("OVERLOAD");
              e.burnout = true;
              e.ep = 0;
              log(
                `[Limit Over] ${e.name}'s Overclock ended. FORCED BURNOUT & EP DRAIN!`
              );
            }
          }

          e.trinityTarget = null;

          while (e.hand.length < 3) {
            if (e.deck.length === 0) {
              if (!e.initialDeckList) {
                e.initialDeckList = JSON.parse(JSON.stringify(e.deck));
              } else {
                e.deck = JSON.parse(JSON.stringify(e.initialDeckList));
                shuffle(e.deck);
                log(`[System] ${e.name}'s Deck Recycled`);
              }
            }
            if (e.deck.length === 0 && e.initialDeckList) {
              e.deck = JSON.parse(JSON.stringify(e.initialDeckList));
              shuffle(e.deck);
            }
            if (e.deck.length > 0) {
              e.hand.push(e.deck.pop());
            }
            if (e.hand.length >= 3) break;
          }
        });

        if (!player.initialDeckList && player.deck.length > 0) {
          player.initialDeckList = buildDeck(
            selectedWeapon,
            selectedArmor,
            selectedAcc
          ).deck.filter((c) => !c.isSP);
          enemy.initialDeckList = enemy.deck.filter((c) => !c.isSP);
        }

        if (enemy.revealSlots) {
          log(">> PREDICTION: Enemy slots are revealed this turn!");
        }

        updateSlotUI("e", [null, null]);
        document.getElementById("e-slot1").innerHTML = "Enemy<br>Slot 1";
        document.getElementById("e-slot2").innerHTML = "Enemy<br>Slot 2";

        checkTrinityReady();

        // --- AI ACTION DECISION ---
        if (enemy.burnout) {
          pendingEnemySlots = [null, null];
          enemy.isCounterMode = false;
          log("[System] Enemy is BURNOUT. Skipping turn.");
        } else {
          // New Advanced AI Call
          const aiRes = AI_STRATEGIES[enemy.strategy](enemy, player);
          pendingEnemySlots = aiRes.slots;
          enemy.isCounterMode = aiRes.action === "COUNTER";

          if (enemy.isCounterMode) {
            log(`[Intel] Enemy is preparing a COUNTER!`);
          }
        }

        log(`--- TURN ${turn} START ---`);
        render();
      }

      function checkTrinityReady() {
        const check = (ent) => {
          const types = new Set(ent.hand.map((c) => c.type));
          ent.isTrinityReady =
            types.has("Attack") && types.has("Guard") && types.has("Break");

          if (ent.isTrinityReady) {
            const targets = ["Attack", "Guard", "Break"];
            ent.trinityTarget =
              targets[Math.floor(Math.random() * targets.length)];
          } else {
            ent.trinityTarget = null;
          }
        };
        check(player);
        check(enemy);

        const ctxBanner = document.getElementById("battle-context");
        const ctxMsg = document.getElementById("context-msg");
        let activeMsgs = [];

        if (player.isTrinityReady) {
          activeMsgs.push(
            `<span style="color:#ffeb3b">PLAYER CHANCE:</span> Slot1で <span style="font-weight:bold; color:#fff; text-decoration:underline">${player.trinityTarget}</span> で勝利で効果上昇。`
          );
        }
        if (enemy.isTrinityReady) {
          activeMsgs.push(
            `<span style="color:#ef5350">ENEMY CHANCE:</span> Slot1で <span style="font-weight:bold; color:#fff; text-decoration:underline">${enemy.trinityTarget}</span> で勝利で効果上昇。`
          );
        }

        if (activeMsgs.length > 0) {
          ctxBanner.style.display = "block";
          ctxMsg.innerHTML = activeMsgs.join("<br>");
          if (player.isTrinityReady && enemy.isTrinityReady) {
            ctxBanner.style.background = "linear-gradient(90deg, #555, #999)";
            ctxBanner.style.border = "1px solid #fff";
          } else if (player.isTrinityReady) {
            ctxBanner.style.background =
              "linear-gradient(90deg, #003d8d, #3f5ad1)";
            ctxBanner.style.border = "1px solid #91c4ff";
            ctxBanner.style.color = "#fff";
          } else {
            ctxBanner.style.background =
              "linear-gradient(90deg, #3e2723, #bf360c)";
            ctxBanner.style.border = "1px solid #ffab91";
            ctxBanner.style.color = "#fff";
          }
        } else {
          ctxBanner.style.display = "none";
        }
      }

      function finishTurnProcessing() {
        [player, enemy].forEach((e) => {
          e.revealSlots = false;
          if (e.breakState) {
            if (e.justBroken) {
              e.justBroken = false;
              e.burnout = true;
            } else {
              e.pos = e.maxPos;
              e.breakState = false;
              if (e.ep > 0) e.burnout = false;
              log(`${e.name} RECOVERED from Break!`);
            }
          } else {
            if (e.ep <= 0) {
              e.burnout = true;
              log(`${e.name} enters EP BURNOUT!`);
            } else {
              e.burnout = false;
            }
          }
        });

        turn++;
        render();

        if (player.hp <= 0 || enemy.hp <= 0) {
          setTimeout(() => {
            alert(player.hp <= 0 ? "YOU LOSE..." : "YOU WIN!");
            location.reload();
          }, 500);
          return;
        }
        setTimeout(startTurn, 1000);
      }

      function selectCard(card, isSecret, handIndex) {
        if (isAnimating) return;
        hideTooltip();
        if (player.burnout) {
          alert("BURNOUT（行動不能）のため、カードを選択できません。");
          return;
        }
        if (isCounterMode) {
          alert("カウンターモード中はカードを選択できません。");
          return;
        }

        if (!isSecret && player.jammedIndices.includes(handIndex)) {
          alert("このカードはジャミングで使用不能です！");
          return;
        }

        const srcId = isSecret ? "secret" : handIndex;
        if (pSlots[0] && pSlots[0]._src === srcId) {
          pSlots[0] = null;
          render();
          return;
        }
        if (pSlots[1] && pSlots[1]._src === srcId) {
          pSlots[1] = null;
          render();
          return;
        }

        const realCost = getRealCost(player, card.cost);

        if (card.isSP) {
          if (player.sp < MAX_SP) {
            alert(`SP技を使用するにはSPゲージが最大(${MAX_SP})必要です。`);
            return;
          }
          if (player.ep < realCost) {
            alert(`SP技の発動にはEPが${realCost}必要です。`);
            return;
          }
        }

        if (player.burnout && card.type === TYPE.GUARD) {
          alert("BURNOUT中はガードカードを使用できません！");
          return;
        }

        let currentCost =
          (pSlots[0] ? getRealCost(player, pSlots[0].cost) : 0) +
          (pSlots[1] ? getRealCost(player, pSlots[1].cost) : 0);

        if (currentCost + realCost > player.ep) {
          alert(`EPが足りません！`);
          return;
        }

        if (!pSlots[0]) {
          pSlots[0] = { ...card, _src: srcId };
        } else if (!pSlots[1]) {
          pSlots[1] = { ...card, _src: srcId };
        } else {
          alert("スロットがいっぱいです。");
          return;
        }
        render();
      }

      document.addEventListener("click", (e) => {
        const tt = document.getElementById("card-tooltip");
        if (tt.style.display === "block") hideTooltip();
      });
      document.getElementById("card-tooltip").onclick = (e) => {
        e.stopPropagation();
        hideTooltip();
      };

      function clearSlot(num) {
        if (isAnimating) return;
        pSlots[num - 1] = null;
        render();
      }

      function toggleCounter() {
        if (isAnimating) return;
        if (player.burnout) {
          alert("BURNOUT（行動不能）のため、カウンターは使用できません。");
          return;
        }
        if (hasUsedCounter) {
          alert("カウンターは1試合に1回しか使用できません。");
          return;
        }
        const cost = getRealCost(player, COUNTER_EP_COST);
        if (!isCounterMode && player.ep < cost) {
          alert(
            `カウンター攻撃にはEPが ${cost} 必要です。（現在: ${player.ep}）`
          );
          return;
        }
        isCounterMode = !isCounterMode;
        if (isCounterMode) pSlots = [null, null];
        render();
      }

      async function commitTurn() {
        if (isAnimating) return;
        let pCost = 0;
        if (isCounterMode) {
          pCost = getRealCost(player, COUNTER_EP_COST);
        } else {
          pCost =
            (pSlots[0] ? getRealCost(player, pSlots[0].cost) : 0) +
            (pSlots[1] ? getRealCost(player, pSlots[1].cost) : 0);
        }

        if (!player.burnout && !isCounterMode && !pSlots[0] && !pSlots[1]) {
          alert("カードを選択するか、カウンターを選択してください。");
          return;
        }

        isAnimating = true;

        const eSlots = pendingEnemySlots;
        const eCost = enemy.isCounterMode
          ? getRealCost(enemy, COUNTER_EP_COST)
          : (eSlots[0] ? getRealCost(enemy, eSlots[0].cost) : 0) +
            (eSlots[1] ? getRealCost(enemy, eSlots[1].cost) : 0);

        player.ep -= pCost;
        enemy.ep -= eCost;

        if (pSlots.some((c) => c?.isSP)) player.sp = Math.max(0, player.sp - 5);
        if (!enemy.isCounterMode && eSlots.some((c) => c?.isSP)) {
          enemy.sp = Math.max(0, enemy.sp - 5);
          enemy.hasUsedSP = true; // Flag for AI logic
        }

        processHandUsage(player, pSlots);
        if (!enemy.isCounterMode) processHandUsage(enemy, eSlots);
        render();

        if (player.burnout) log("Player is Stunned (Burnout)...");
        if (enemy.burnout) log("Enemy is Stunned (Burnout)...");

        const pAction = isCounterMode ? "COUNTER" : `Cost ${pCost}`;
        const eAction = enemy.isCounterMode ? "COUNTER" : `Cost ${eCost}`;
        log(`Battle! P:[${pAction}] vs E:[${eAction}]`);

        await sleep(600);

        let pCards = [...pSlots];
        let eCards = [...eSlots];
        const pSP = pCards.some((c) => c?.isSP);
        const eSP = eCards.some((c) => c?.isSP);

        if (pSP && eSP) {
          log("!!! SP CLASH !!! 双方がSPを使用 -> 相殺！");
          pCards = [null, null];
          eCards = [null, null];
          await sleep(1000);
        } else if (eSP && isCounterMode) {
          log("!!! PLAYER COUNTER SUCCESS !!!");
          hasUsedCounter = true;
          eCards = [null, null];
          await sleep(1000);
        } else if (pSP && enemy.isCounterMode) {
          log("!!! ENEMY COUNTER SUCCESS !!!");
          enemy.hasUsedCounter = true;
          pCards = [null, null];
          await sleep(1000);
        } else {
          if (isCounterMode) {
            log("Player Counter Missed... (EP consumed)");
            hasUsedCounter = true;
          }
          if (enemy.isCounterMode) {
            log("Enemy Counter Missed... (EP consumed)");
            enemy.hasUsedCounter = true;
          }
        }

        let pMul = 1.0;
        let eMul = 1.0;

        log("--- SLOT 1 ---");
        const res1 = await resolveStep(
          1,
          pCards[0],
          eCards[0],
          pMul,
          eMul,
          null
        );

        if (res1 === "WIN" && pCards[0]?.ability === "GRAVITY" && eCards[1]) {
          log(">> GRAVITY Effect: Enemy Slot 2 Cost +3!");
          eCards[1].cost += 3;
          if (enemy.ep < 3) {
            log(
              ">> GRAVITY: Enemy lacks EP for increased weight! Slot 2 Crushed!"
            );
            eCards[1] = null;
          } else {
            enemy.ep -= 3;
            log(">> GRAVITY: Enemy pays 3 extra EP to maintain stance.");
          }
          render();
          await sleep(800);
        }

        if (res1 === "WIN") {
          pMul = 1.2;
          eMul = 0.25;
          log(">> WIN Bonus: Next x1.2");
        } else if (res1 === "LOSE") {
          pMul = 0.25;
          eMul = 1.2;
          log(">> LOSE Penalty: Next x0.25");
        }

        log("--- SLOT 2 ---");
        await resolveStep(2, pCards[1], eCards[1], pMul, eMul, res1);

        finishTurnProcessing();
      }

      function getMatchupResult(pCard, eCard, isSlot2 = false) {
        if (!eCard) return "WIN";
        if (pCard.type === eCard.type) {
          let pCost = pCard.cost;
          let eCost = eCard.cost;

          if (!isSlot2 && player.isPhantomWeight) pCost = 6;
          if (!isSlot2 && enemy.isPhantomWeight) eCost = 6;

          if (pCost > eCost) return "WIN";
          if (eCost > pCost) return "LOSE";
          return "DRAW";
        }
        if (pCard.type === TYPE.SP) return "WIN";
        if (eCard.type === TYPE.SP) return "LOSE";

        if (isSlot2 && isPolarityReversed) {
          if (WIN_MAP[eCard.type] === pCard.type) return "WIN";
          return "LOSE";
        } else {
          if (WIN_MAP[pCard.type] === eCard.type) return "WIN";
          return "LOSE";
        }
      }

      async function resolveStep(
        slotNum,
        pCard,
        eCard,
        pMul,
        eMul,
        prevResult
      ) {
        const pSlotEl = document.getElementById(`p-slot${slotNum}`);
        const eSlotEl = document.getElementById(`e-slot${slotNum}`);
        pSlotEl.classList.add("active-battle-slot");
        eSlotEl.classList.add("active-battle-slot");

        if (eCard) {
          eSlotEl.className = `slot type-${eCard.type} active-battle-slot`;
          eSlotEl.innerHTML = renderCardContent(eCard);
        } else {
          eSlotEl.className = `slot active-battle-slot`;
          eSlotEl.innerHTML = "Empty";
        }

        if (pCard) {
          pSlotEl.className = `slot type-${pCard.type} active-battle-slot`;
          pSlotEl.innerHTML = renderCardContent(pCard);
        } else {
          pSlotEl.className = `slot active-battle-slot`;
          pSlotEl.innerHTML = "Empty";
        }

        await sleep(1500);

        let result = "DRAW";
        const isSlot2 = slotNum === 2;
        if (!pCard && !eCard) result = "DRAW";
        else if (!pCard) result = "LOSE";
        else if (!eCard) result = "WIN";
        else result = getMatchupResult(pCard, eCard, isSlot2);

        let pBonusMul = 1.0;
        let eBonusMul = 1.0;
        let pFlatDmgBonus = 0;
        let eFlatDmgBonus = 0;
        let pForceBreak = false;
        let eForceBreak = false;
        let pMemoryLeakActive = false;
        let eMemoryLeakActive = false;

        if (slotNum === 1) {
          if (
            result === "WIN" &&
            player.trinityTarget &&
            pCard &&
            pCard.type === player.trinityTarget
          ) {
            pBonusMul *= 1.5;
            showTrinitySuccess(pSlotEl, "PLAYER");
            log(`>>> PLAYER MISSION COMPLETE! (Dmg x1.5)`);
          }
          if (
            result === "LOSE" &&
            enemy.trinityTarget &&
            eCard &&
            eCard.type === enemy.trinityTarget
          ) {
            eBonusMul *= 1.5;
            showTrinitySuccess(eSlotEl, "ENEMY");
            log(`>>> ENEMY MISSION COMPLETE! (Dmg x1.5)`);
          }
        }

        if (result === "WIN" && pCard?.ability) {
          const ab = ABILITIES[pCard.ability];
          if (
            slotNum === 1 &&
            ["INSTANT", "SETUP", "CLEAR"].includes(ab.type)
          ) {
            let conditionMet = true;
            if (ab.id === "IRON_WILL" && player.hp > MAX_HP * 0.3)
              conditionMet = false;
            if (ab.id === "DESPERATE_STRIKE" && player.hp >= enemy.hp)
              conditionMet = false;

            if (conditionMet) {
              log(`★ Player Trigger: ${ab.name}`);
              await showAbilityAnnouncement(player.name, ab.name, ab.desc);

              if (ab.type === "SETUP") {
                addTag(enemy, ab.tag, ab.tagName);
                if (ab.id === "OVERCLOCK") {
                  player.tags.add(ab.tag);
                  player.overclockTurns = 3;
                  log(">> LIMIT OVER: All Costs 0 for 3 turns!");
                } else if (ab.id === "VIRUS_INSTALL") {
                  enemy.virusTurns = 3;
                }
              } else if (ab.type === "CLEAR") {
                clearTags(player);
              } else if (ab.type === "INSTANT") {
                const bonus = await resolveInstantAbility(player, enemy, ab.id);
                if (ab.id === "DESPERATE_STRIKE" && bonus)
                  pFlatDmgBonus = bonus;
              }
            }
          } else if (slotNum === 2 && ab.type === "EXECUTE") {
            if (hasTag(enemy, ab.reqTag)) {
              log(`★ Player Trigger: ${ab.name}`);
              await showAbilityAnnouncement(player.name, ab.name, ab.desc);
              log(`>>> SYNERGY EXECUTION! [${ab.name}] Activated!`);

              if (ab.id === "FIRE_BLAST") {
                pBonusMul *= 3.0;
                enemy.burnout = true;
                log(">> Execute Effect: Enemy Burnout Applied!");
              } else if (ab.id === "FATAL_THRUST") {
                pBonusMul *= 3.0;
              } else if (ab.id === "DATA_DRAIN") {
                const drain = enemy.sp;
                enemy.sp = 0;
                player.sp = Math.min(MAX_SP, player.sp + drain);
                log(`>> DATA DRAIN: Stole ${drain} SP!`);
              } else if (ab.id === "POSTURE_BREAK_EXEC") {
                pForceBreak = true;
                log(">> POSTURE BREAK: Immediate Break Status!");
              } else if (ab.id === "ECHO_STRIKE") {
                pBonusMul *= 2.0;
                log(">> ECHO STRIKE: Damage x2!");
              } else if (ab.id === "MEMORY_LEAK") {
                pMemoryLeakActive = true;
              }
            }
          }
        } else if (result === "LOSE" && eCard?.ability) {
          const ab = ABILITIES[eCard.ability];

          if (
            slotNum === 1 &&
            ["INSTANT", "SETUP", "CLEAR"].includes(ab.type)
          ) {
            let conditionMet = true;
            if (ab.id === "IRON_WILL" && enemy.hp > MAX_HP * 0.3)
              conditionMet = false;
            if (ab.id === "DESPERATE_STRIKE" && enemy.hp >= player.hp)
              conditionMet = false;

            if (conditionMet) {
              log(`★ Enemy Trigger: ${ab.name}`);
              await showAbilityAnnouncement(enemy.name, ab.name, ab.desc);

              if (ab.type === "SETUP") {
                addTag(player, ab.tag, ab.tagName);
                if (ab.id === "OVERCLOCK") {
                  enemy.tags.add(ab.tag);
                  enemy.overclockTurns = 3;
                } else if (ab.id === "VIRUS_INSTALL") {
                  player.virusTurns = 3;
                }
              } else if (ab.type === "CLEAR") {
                clearTags(enemy);
              } else if (ab.type === "INSTANT") {
                const bonus = await resolveInstantAbility(enemy, player, ab.id);
                if (ab.id === "DESPERATE_STRIKE" && bonus)
                  eFlatDmgBonus = bonus;
              }
            }
          } else if (slotNum === 2 && ab.type === "EXECUTE") {
            if (hasTag(player, ab.reqTag)) {
              log(`★ Enemy Trigger: ${ab.name}`);
              await showAbilityAnnouncement(enemy.name, ab.name, ab.desc);
              log(`>>> SYNERGY EXECUTION! [${ab.name}] Activated!`);

              if (ab.id === "FIRE_BLAST") {
                eBonusMul *= 3.0;
                player.burnout = true;
                log(">> Execute Effect: Player Burnout Applied!");
              } else if (ab.id === "FATAL_THRUST") {
                eBonusMul *= 3.0;
              } else if (ab.id === "DATA_DRAIN") {
                const drain = player.sp;
                player.sp = 0;
                enemy.sp = Math.min(MAX_SP, enemy.sp + drain);
                log(`>> DATA DRAIN: Stole ${drain} SP!`);
              } else if (ab.id === "POSTURE_BREAK_EXEC") {
                eForceBreak = true;
                log(">> POSTURE BREAK: Immediate Break Status!");
              } else if (ab.id === "ECHO_STRIKE") {
                eBonusMul *= 2.0;
                log(">> ECHO STRIKE: Damage x2!");
              } else if (ab.id === "MEMORY_LEAK") {
                eMemoryLeakActive = true;
              }
            }
          }
        }

        const isPlayerGuardVsAtk =
          result === "WIN" &&
          pCard?.type === TYPE.GUARD &&
          eCard?.type === TYPE.ATTACK;
        const isEnemyGuardVsAtk =
          result === "LOSE" &&
          eCard?.type === TYPE.GUARD &&
          pCard?.type === TYPE.ATTACK;

        if (isPlayerGuardVsAtk) {
          log(`Guard Logic: Enemy Attack x0.5 vs Player Armor`);
          await resolveGuardDeflect(player, pCard, eCard, eMul * eBonusMul);
        } else if (isEnemyGuardVsAtk) {
          log(`Guard Logic: Player Attack x0.5 vs Enemy Armor`);
          await resolveGuardDeflect(enemy, eCard, pCard, pMul * pBonusMul);
        } else {
          if (result === "DRAW") {
            if (prevResult === "WIN") {
              const dmg = applyDmg(
                enemy,
                pCard,
                1.5 * pBonusMul,
                pFlatDmgBonus,
                pForceBreak
              );
              if (pMemoryLeakActive && dmg > 0) {
                const loss = Math.floor(dmg * 0.5);
                enemy.sp = Math.max(0, enemy.sp - loss);
                log(`>> MEMORY LEAK: Enemy lost ${loss} SP!`);
              }
              result = "WIN";
            } else if (prevResult === "LOSE") {
              const dmg = applyDmg(
                player,
                eCard,
                1.5 * eBonusMul,
                eFlatDmgBonus,
                eForceBreak
              );
              if (eMemoryLeakActive && dmg > 0) {
                const loss = Math.floor(dmg * 0.5);
                player.sp = Math.max(0, player.sp - loss);
                log(`>> MEMORY LEAK: Player lost ${loss} SP!`);
              }
              result = "LOSE";
            } else {
              if (pCard && eCard) {
                player.hp -= 2;
                enemy.hp -= 2;
                log("Draw (Clash)! Both take 2 dmg.");
              }
            }
          } else {
            if (result === "WIN") {
              const dmg = applyDmg(
                enemy,
                pCard,
                pMul * pBonusMul,
                pFlatDmgBonus,
                pForceBreak
              );
              if (pMemoryLeakActive && dmg > 0) {
                const loss = Math.floor(dmg * 0.5);
                enemy.sp = Math.max(0, enemy.sp - loss);
                log(`>> MEMORY LEAK: Enemy lost ${loss} SP!`);
              }
            } else if (result === "LOSE") {
              const dmg = applyDmg(
                player,
                eCard,
                eMul * eBonusMul,
                eFlatDmgBonus,
                eForceBreak
              );
              if (eMemoryLeakActive && dmg > 0) {
                const loss = Math.floor(dmg * 0.5);
                player.sp = Math.max(0, player.sp - loss);
                log(`>> MEMORY LEAK: Player lost ${loss} SP!`);
              }
            }
          }
        }

        render();
        let overlayText = result;
        if (isSlot2 && isPolarityReversed) overlayText += "?!";

        showResultOverlay(pSlotEl, overlayText);
        showResultOverlay(
          eSlotEl,
          result === "WIN" ? "LOSE" : result === "LOSE" ? "WIN" : "DRAW"
        );

        await sleep(1200);

        pSlotEl.classList.remove("active-battle-slot");
        eSlotEl.classList.remove("active-battle-slot");
        clearOverlays(pSlotEl);
        clearOverlays(eSlotEl);

        return result;
      }

      function addTag(target, tagCode, tagName) {
        if (tagCode === "OVERLOAD") {
          return;
        }
        target.tags.add(tagCode);
        log(`>> Effect: ${target.name} is now [${tagName}]!`);
      }

      function hasTag(target, tagCode) {
        return target.tags.has(tagCode);
      }

      function clearTags(target) {
        target.tags.clear();
        target.virusTurns = 0;
        target.corrosionTurns = 0;
        target.overclockTurns = 0;
        log(`>> Effect: ${target.name} Cleansed all status tags!`);
      }

      function showTrinitySuccess(el, who) {
        const div = document.createElement("div");
        div.className = "trinity-success-overlay";
        div.innerHTML = `★ ${who} CRITICAL ★<br>x1.5 BOOST!`;
        el.appendChild(div);
      }

      async function resolveInstantAbility(user, opponent, abilityId) {
        switch (abilityId) {
          case "EP_CHARGE":
            user.ep = Math.min(MAX_EP, user.ep + 3);
            log(`>> [Instant] ${user.name} recovered 3 EP!`);
            break;
          case "SMOKE":
            opponent.stealthTurns = 2;
            log(`>> [Instant] ${user.name} deploys Smokescreen!`);
            break;
          case "FEINT":
            opponent.ep = Math.max(0, opponent.ep - 2);
            log(`>> [Instant] Feint! ${opponent.name} lost 2 EP.`);
            break;
          case "PREP_ATK":
            const atkIdx = user.deck.findIndex(
              (c) => c.type === TYPE.ATTACK && !c.isSP
            );
            if (atkIdx !== -1) {
              const c = user.deck.splice(atkIdx, 1)[0];
              user.deck.push(c);
              log(`>> [Instant] ${user.name} prepares Attack card.`);
            }
            break;
          case "POLARITY_SHIFT":
            isPolarityReversed = true;
            log(`>> [Polarity Shift] Slot 2 Matchups REVERSED!`);
            break;
          case "GRAVITY":
            break;
          case "IRON_WILL":
            user.damageImmune = true;
            user.doubleEpNext = true;
            log(`>> [Iron Will] Immune this turn & Double EP next turn!`);
            break;
          case "DESPERATE_STRIKE":
            const sacrifice = Math.floor(user.pos / 2);
            user.pos -= sacrifice;
            log(
              `>> [Desperate Strike] Sacrificed ${sacrifice} Pos for Attack!`
            );
            return sacrifice;
            break;
          case "PREDICTION":
            opponent.revealSlots = true;
            log(`>> [Prediction] Enemy slots will be exposed next turn!`);
            break;
          case "PHANTOM_WEIGHT":
            user.phantomWeightPending = true;
            log(`>> [Phantom Weight] Next turn Slot 1 acts as Cost 6!`);
            break;
          case "JAMMING":
            opponent.isJammedPending = true;
            log(`>> [Jamming] Opponent card will be disabled next turn!`);
            break;
          case "MANA_BARRIER":
            user.isManaBarrier = true;
            user.ep = Math.max(0, user.ep - 3);
            log(`>> [Mana Barrier] Barrier Active! (Cost 3 EP)`);
            break;
          case "EMERGENCY_REPAIR":
            user.hp = Math.min(user.maxHp, user.hp + 10);
            log(`>> [Repair] Recovered 10 HP!`);
            break;
          case "ENERGY_DRAIN":
            opponent.ep = Math.max(0, opponent.ep - 3);
            log(`>> [Energy Drain] Drained 3 EP from opponent!`);
            break;
          case "STUN_SHOT":
            let maxCost = -1;
            let maxIdx = -1;
            opponent.hand.forEach((c, i) => {
              if (c.cost > maxCost) {
                maxCost = c.cost;
                maxIdx = i;
              }
            });
            if (maxIdx !== -1) {
              opponent.hand[maxIdx].cost += 3;
              log(`>> [Stun Shot] Opponent's highest cost card +3 Cost!`);
            }
            break;
          case "CORROSION":
            opponent.corrosionTurns = 2;
            log(`>> [Corrosion] Opponent Poisoned for 2 turns!`);
            break;
          case "SCAN":
            break;
          case "SONAR":
            break;
        }
        return 0;
      }

      function showAbilityAnnouncement(userName, abilityName, abilityDesc) {
        return new Promise((resolve) => {
          const container = document.getElementById("ability-cutin");
          const userEl = document.getElementById("ac-user");
          const nameEl = document.getElementById("ac-name");
          const descEl = document.getElementById("ac-desc");

          userEl.innerText = `${userName}'s Ability!`;
          nameEl.innerText = abilityName;
          descEl.innerText = abilityDesc;

          container.classList.remove("active");
          void container.offsetWidth;
          container.classList.add("active");

          setTimeout(() => {
            resolve();
          }, 1800);
        });
      }

      async function resolveGuardDeflect(
        defender,
        guardCard,
        attackCard,
        attackerMul
      ) {
        if (defender.damageImmune || defender.isManaBarrier) {
          log(`IMMUNE! ${defender.name} takes no damage!`);
          return;
        }
        const rawAtk = (attackCard.dmg || 0) * attackerMul;
        const reducedAtk = Math.floor(rawAtk * 0.5);
        const armor = guardCard.arm || 0;
        const finalDmg = Math.max(0, reducedAtk - armor);

        if (finalDmg > 0) {
          defender.hp -= finalDmg;
          log(`GUARD! Dmg: ${finalDmg}`);
        } else {
          log(`BLOCKED!`);
        }
      }

      function showResultOverlay(el, text) {
        const div = document.createElement("div");
        div.className = "slot-result-overlay";
        if (text.includes("WIN")) div.classList.add("res-win");
        if (text.includes("LOSE")) div.classList.add("res-lose");
        if (text.includes("DRAW")) div.classList.add("res-draw");
        div.innerText = text;
        el.appendChild(div);
      }

      function clearOverlays(el) {
        const overs = el.querySelectorAll(
          ".slot-result-overlay, .trinity-success-overlay"
        );
        overs.forEach((o) => o.remove());
      }

      function processHandUsage(entity, slots) {
        slots.forEach((s) => {
          if (!s) return;
          if (s._src === "secret") {
            if (entity.deck.length > 0) entity.secret = entity.deck.pop();
            else entity.secret = null;
          } else {
            const idx = entity.hand.findIndex(
              (c) => c.type === s.type && c.cost === s.cost
            );
            if (idx !== -1) entity.hand.splice(idx, 1);
          }
        });
      }

      function applyDmg(target, card, mul, flatBonus = 0, forceBreak = false) {
        if (!card && flatBonus === 0) return 0;

        if (target.isManaBarrier && card && !card.isSP) {
          log(`BARRIER! ${target.name} negates damage!`);
          return 0;
        }

        if (target.damageImmune) {
          log(`IMMUNE! ${target.name} takes no damage (Iron Will)!`);
          return 0;
        }

        let finalMul = mul;

        if (target.breakState) finalMul *= 2.0;
        if (target.burnout && !target.breakState) finalMul *= 1.5;

        let dmg = 0;
        if (card && card.type !== TYPE.BREAK) {
          dmg = Math.floor((card.dmg || 0) * finalMul);
        }

        if (flatBonus > 0) {
          dmg += flatBonus;
        }

        let pos = 0;
        if (card) {
          pos = Math.floor((card.pos || 0) * finalMul);
        }

        target.hp -= dmg;
        target.pos -= pos;

        let logMsg = `${target.name} takes `;
        if (dmg > 0) logMsg += `${dmg} HP Dmg`;
        if (dmg > 0 && pos > 0) logMsg += " & ";
        if (pos > 0) logMsg += `${pos} Posture Dmg`;
        if (dmg === 0 && pos === 0) logMsg += "no damage";
        log(logMsg);

        if (forceBreak && !target.breakState) {
          target.pos = 0;
          target.breakState = true;
          target.justBroken = true;
          log(`!!! ${target.name} FORCED BREAK !!!`);
        } else if (target.pos <= 0 && !target.breakState) {
          target.breakState = true;
          target.justBroken = true;
          target.pos = 0;
          log(`!!! ${target.name} POSTURE BREAK !!!`);
        } else if (target.pos < 0) {
          target.pos = 0;
        }
        return dmg;
      }

      function render() {
        ["p", "e"].forEach((prefix) => {
          const e = prefix === "p" ? player : enemy;
          document.getElementById(`${prefix}-hp`).innerText = e.hp;
          if (prefix === "e") {
            document.getElementById(`e-ep`).innerText = e.ep;
            document.getElementById(`e-sp`).innerText = e.sp;
          }

          document.getElementById(`${prefix}-pos`).innerText = Math.floor(
            e.pos
          );

          document.getElementById(`${prefix}-hp-bar`).style.width = `${Math.max(
            0,
            (e.hp / MAX_HP) * 100
          )}%`;
          document.getElementById(
            `${prefix}-pos-bar`
          ).style.width = `${Math.max(0, (e.pos / MAX_POSTURE) * 100)}%`;
          document.getElementById(`${prefix}-burnout`).style.display = e.burnout
            ? "inline"
            : "none";

          const tagContainer = document.getElementById(`${prefix}-tags`);
          tagContainer.innerHTML = "";
          e.tags.forEach((t) => {
            let name = t;
            for (let key in ABILITIES) {
              if (ABILITIES[key].tag === t) name = ABILITIES[key].tagName || t;
            }
            const badge = document.createElement("span");
            badge.className = "tag-badge";
            badge.innerText = name;
            tagContainer.appendChild(badge);
          });
          if (e.damageImmune) {
            const badge = document.createElement("span");
            badge.className = "tag-badge";
            badge.style.background = "#fff176";
            badge.style.color = "#000";
            badge.innerText = "DMG IMMUNE";
            tagContainer.appendChild(badge);
          }
          if (e.revealSlots) {
            const badge = document.createElement("span");
            badge.className = "tag-badge";
            badge.style.background = "#d2a8ff";
            badge.innerText = "PREDICTED";
            tagContainer.appendChild(badge);
          }
          if (e.corrosionTurns > 0) {
            const badge = document.createElement("span");
            badge.className = "tag-badge";
            badge.style.background = "#ab47bc";
            badge.innerText = `POISON (${e.corrosionTurns})`;
            tagContainer.appendChild(badge);
          }
          if (e.isPhantomWeight) {
            const badge = document.createElement("span");
            badge.className = "tag-badge";
            badge.style.background = "#90a4ae";
            badge.innerText = `COST OVERRIDE`;
            tagContainer.appendChild(badge);
          }
        });

        const pendingCost = isCounterMode
          ? getRealCost(player, COUNTER_EP_COST)
          : (pSlots[0] ? getRealCost(player, pSlots[0].cost) : 0) +
            (pSlots[1] ? getRealCost(player, pSlots[1].cost) : 0);

        const pendingSP = pSlots.some((c) => c?.isSP) ? 5 : 0;
        const predictedEP = Math.max(0, player.ep - pendingCost);
        const predictedSP = Math.max(0, player.sp - pendingSP);

        const epTxt =
          pendingCost > 0
            ? `${player.ep} <span style="color:#aaa; font-size:0.8em">(-${pendingCost})</span>`
            : player.ep;
        document.getElementById("p-ep-txt").innerHTML = epTxt;

        const spTxt =
          pendingSP > 0
            ? `${player.sp} <span style="color:#aaa; font-size:0.8em">(-${pendingSP})</span>`
            : player.sp;
        document.getElementById("p-sp-txt").innerHTML = spTxt;

        document.getElementById("p-ep-ghost").style.width = `${
          (player.ep / MAX_EP) * 100
        }%`;
        document.getElementById("p-ep-fill").style.width = `${
          (predictedEP / MAX_EP) * 100
        }%`;
        document.getElementById("p-sp-ghost").style.width = `${
          (player.sp / MAX_SP) * 100
        }%`;
        document.getElementById("p-sp-fill").style.width = `${
          (predictedSP / MAX_SP) * 100
        }%`;

        document.getElementById("e-ep-fill").style.width = `${
          (enemy.ep / MAX_EP) * 100
        }%`;
        document.getElementById("e-sp-fill").style.width = `${
          (enemy.sp / MAX_SP) * 100
        }%`;

        const intelBox = document.getElementById("e-intel-box");
        intelBox.style.display = "flex";
        const cost = enemy.isCounterMode
          ? getRealCost(enemy, COUNTER_EP_COST)
          : (pendingEnemySlots[0]
              ? getRealCost(enemy, pendingEnemySlots[0].cost)
              : 0) +
            (pendingEnemySlots[1]
              ? getRealCost(enemy, pendingEnemySlots[1].cost)
              : 0);
        document.getElementById("e-pending-cost").innerText = cost + " EP";

        const eZone = document.getElementById("enemy-hand-view");
        eZone.innerHTML = "";
        const secretDiv = document.createElement("div");
        secretDiv.className = "card type-Secret";
        secretDiv.innerHTML = `<div class="card-type">SECRET</div><div class="card-cost">?</div>`;
        eZone.appendChild(secretDiv);

        enemy.hand.forEach((c) => {
          const isBlinded = player.stealthTurns > 0;
          const cardDiv = document.createElement("div");
          if (isBlinded) {
            cardDiv.className = "card type-Secret";
            cardDiv.innerHTML = `<div class="card-type">SECRET</div><div class="card-cost">?</div>`;
          } else {
            cardDiv.className = `card type-${c.type}`;
            let statsHtml = "";
            if (c.dmg)
              statsHtml += `<div class="stat-row"><span>⚔️</span><span>${c.dmg}</span></div>`;
            if (c.pos)
              statsHtml += `<div class="stat-row"><span style="font-size:0.7em">POS</span><span>${c.pos}</span></div>`;
            if (c.arm)
              statsHtml += `<div class="stat-row"><span>🛡️</span><span>${c.arm}</span></div>`;

            let abilityHtml = "";
            if (c.ability && ABILITIES[c.ability]) {
              const ab = ABILITIES[c.ability];
              let cls = "";
              if (ab.type === "SETUP") cls = "ability-setup";
              if (ab.type === "EXECUTE") cls = "ability-exec";
              abilityHtml = `<div class="ability-badge ${cls}">${ab.name}</div>`;
            }

            cardDiv.innerHTML = `
                <div class="card-type">${c.type}</div>
                <div class="card-cost">${c.cost}</div>
                <div class="card-stats">${statsHtml}</div>
                ${abilityHtml}`;
          }

          if (!isAnimating && !isBlinded) {
            if (pSlots[0]) {
              const res1 = getMatchupResult(pSlots[0], c);
              const badge1 = document.createElement("span");
              badge1.className = `matchup-badge mb-slot1 mb-${res1.toLowerCase()}`;
              badge1.innerText = res1;
              cardDiv.appendChild(badge1);
            }
            if (pSlots[1]) {
              const res2 = getMatchupResult(pSlots[1], c, true);
              const badge2 = document.createElement("span");
              badge2.className = `matchup-badge mb-slot2 mb-${res2.toLowerCase()}`;
              badge2.innerText = res2;
              cardDiv.appendChild(badge2);
            }
          }

          if (!isBlinded) {
            if (!isTouchDevice) {
              cardDiv.onmouseenter = (e) => showTooltip(e, c);
              cardDiv.onmousemove = (e) => moveTooltip(e);
              cardDiv.onmouseleave = () => hideTooltip();
            } else {
              cardDiv.onclick = (e) => {
                showTooltip(e, c);
              };
            }
          }
          eZone.appendChild(cardDiv);
        });

        const pZone = document.getElementById("player-hand-view");
        pZone.innerHTML = "";

        if (player.secret) {
          pZone.appendChild(createCardDiv(player.secret, true, -1));
        }
        player.hand.forEach((c, i) => {
          const div = createCardDiv(c, false, i);
          if (player.jammedIndices.includes(i)) {
            div.classList.add("jammed");
            div.classList.add("disabled");
          }
          pZone.appendChild(div);
        });

        if (!isAnimating) {
          updateSlotUI("p", pSlots);
          updateSlotUI("e", pendingEnemySlots, enemy.revealSlots);
        }

        const btnC = document.getElementById("btn-counter");
        const counterCost = getRealCost(player, COUNTER_EP_COST);
        btnC.innerText = hasUsedCounter
          ? "使用不可"
          : isCounterMode
          ? `カウンター準備中 (Cost: ${counterCost})`
          : `SP カウンター攻撃 (Cost: ${counterCost})`;
        btnC.className = isCounterMode ? "active" : "";
        btnC.disabled = hasUsedCounter || isAnimating || player.burnout;

        const btnCommit = document.getElementById("btn-commit");
        if (isAnimating) {
          btnCommit.innerText = "BATTLE IN PROGRESS...";
          btnCommit.disabled = true;
        } else if (player.burnout) {
          btnCommit.innerText = "ターンをスキップ (BURNOUT)";
          btnCommit.disabled = false;
          btnCommit.style.background = "#555";
        } else {
          btnCommit.innerText = `コマンド決定 (Cost: ${pendingCost})`;
          btnCommit.disabled = pendingCost > player.ep;
          btnCommit.style.background = "var(--accent-color)";
        }
      }

      function createCardDiv(card, isSecret, idx) {
        const div = document.createElement("div");
        div.className = `card type-${card.type}`;
        let disabled = false;
        if (typeof player !== "undefined" && player) {
          if (player.burnout && card.type === TYPE.GUARD) disabled = true;
          const realCost = getRealCost(player, card.cost);
          if (card.isSP && (player.sp < MAX_SP || player.ep < realCost))
            disabled = true;
          const isSel =
            pSlots[0]?._src === (isSecret ? "secret" : idx) ||
            pSlots[1]?._src === (isSecret ? "secret" : idx);
          if (isSel) {
            div.classList.add("selected");
            div.classList.remove("disabled");
          }
        }
        if (disabled) div.classList.add("disabled");

        let statsHtml = "";
        if (card.dmg)
          statsHtml += `<div class="stat-row"><span>⚔️</span><span>${card.dmg}</span></div>`;
        if (card.pos)
          statsHtml += `<div class="stat-row"><span style="font-size:0.7em">POS</span><span>${card.pos}</span></div>`;
        if (card.arm)
          statsHtml += `<div class="stat-row"><span>🛡️</span><span>${card.arm}</span></div>`;

        let abilityHtml = "";
        if (card.ability && ABILITIES[card.ability]) {
          const ab = ABILITIES[card.ability];
          let cls = "";
          if (ab.type === "SETUP") cls = "ability-setup";
          if (ab.type === "EXECUTE") cls = "ability-exec";
          abilityHtml = `<div class="ability-badge ${cls}">${ab.name}</div>`;
        }

        div.innerHTML = `<div class="card-type">${card.type}</div>
             <div class="card-cost">${card.cost}</div>
             <div class="card-stats">${statsHtml}</div>
             ${abilityHtml}
             ${
               isSecret
                 ? '<div style="position:absolute; top:2px; right:2px; font-size:0.5rem; color:#90a4ae; background:rgba(0,0,0,0.7); padding:1px 3px; border-radius:2px;">SECRET</div>'
                 : ""
             }`;

        if (!isTouchDevice) {
          div.onclick = () => selectCard(card, isSecret, idx);
          div.onmouseenter = (e) => showTooltip(e, card);
          div.onmousemove = (e) => moveTooltip(e);
          div.onmouseleave = () => hideTooltip();
        } else {
          let pressTimer;
          let isLongPress = false;
          let isScrolling = false;

          div.addEventListener(
            "touchstart",
            (e) => {
              isLongPress = false;
              isScrolling = false;
              pressTimer = setTimeout(() => {
                isLongPress = true;
                if (navigator.vibrate) navigator.vibrate(50);
                showTooltip(e, card);
              }, 500);
            },
            { passive: true }
          );

          div.addEventListener(
            "touchmove",
            () => {
              clearTimeout(pressTimer);
              isScrolling = true;
            },
            { passive: true }
          );

          div.addEventListener("touchend", (e) => {
            clearTimeout(pressTimer);
            if (isLongPress) {
              if (e.cancelable) e.preventDefault();
            }
          });

          div.onclick = (e) => {
            if (!isLongPress && !isScrolling) {
              selectCard(card, isSecret, idx);
            }
          };
        }
        return div;
      }

      function updateSlotUI(prefix, slots, forceReveal = false) {
        for (let i = 1; i <= 2; i++) {
          const el = document.getElementById(`${prefix}-slot${i}`);
          const c = slots[i - 1];
          if (c) {
            el.className = `slot type-${c.type}`;
            if (prefix === "e" && !forceReveal) {
              el.className = `slot`;
              el.innerHTML = `Enemy<br>Slot ${i}`;
            } else {
              el.innerHTML = renderCardContent(c);
            }
          } else {
            el.className = "slot";
            if (prefix === "p") {
              el.innerHTML = `Tap Card<br>to Set`;
            } else {
              el.innerHTML = `Slot ${i}`;
            }
          }
        }
      }

      function renderCardContent(c) {
        if (!c) return "Empty";
        let abHtml = "";
        if (c.ability && ABILITIES[c.ability]) {
          abHtml = `<div style="font-size:0.6rem; color:var(--accent-color); margin-top:-2px">${
            ABILITIES[c.ability].name
          }</div>`;
        }
        return `<div style="font-weight:bold">${c.type}</div><div style="font-size:1.2rem">${c.cost}</div>${abHtml}`;
      }

      function log(msg) {
        const l = document.getElementById("log");
        l.innerHTML += `<div>${msg}</div>`;
        l.scrollTop = l.scrollHeight;
      }

      window.onload = initSetup;
    </script>
  </body>
</html>
