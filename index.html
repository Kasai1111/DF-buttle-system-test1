<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DUST FALL Ver.38.2 - Craft & Equip Fix</title>
    <style>
      /* --- CSS Reset & Base Styles --- */
      :root {
        --bg-color: #0a0a0a;
        --text-color: #e0e0e0;
        --accent-color: #c3073f;
        --ui-bg: #1f1f1f;
        --ui-border: #444;
      }
      body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: "Segoe UI", monospace;
        user-select: none;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
      }
      #game-container {
        width: 1024px;
        height: 768px;
        position: relative;
        background: #000;
        border: 2px solid #333;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
      }

      /* --- Screen Management --- */
      .screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        flex-direction: column;
        background: var(--bg-color);
        z-index: 10;
      }
      .screen.active {
        display: flex;
        z-index: 20;
      }

      /* --- UI Components --- */
      .title-text {
        font-size: 100px;
      }
      h1,
      h2,
      h3 {
        margin: 0;
        padding: 5px;
        color: #ffd700;
        text-shadow: 1px 1px 0 #000;
      }
      button {
        background: #333;
        color: #fff;
        border: 1px solid #666;
        padding: 8px 16px;
        cursor: pointer;
        font-family: inherit;
        transition: 0.2s;
      }
      button:hover {
        background: #555;
        border-color: #fff;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* --- Title Screen --- */
      #title-screen {
        justify-content: center;
        align-items: center;
        background: linear-gradient(45deg, #232324, rgb(0, 0, 0));
      }

      /* --- Base Screen --- */
      #base-screen {
        padding: 20px;
      }
      .base-layout {
        display: flex;
        height: 80%;
        gap: 10px;
        margin-top: 10px;
      }
      .panel {
        flex: 1;
        border: 1px solid var(--ui-border);
        background: var(--ui-bg);
        padding: 10px;
        overflow-y: auto;
      }
      .item-row {
        display: flex;
        justify-content: space-between;
        padding: 8px;
        border-bottom: 1px dashed #444;
        cursor: pointer;
        font-size: 14px;
        align-items: center;
      }
      .item-row:hover {
        background: #333;
      }
      /* Ë£ÖÂÇô„Ç¢„Ç§„ÉÜ„É†Âº∑Ë™ø */
      .item-row.equipped {
        background: #152;
        color: #0f0;
        font-weight: bold;
        border-left: 5px solid #0f0;
        box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
      }
      .item-row.locked {
        color: #666;
        opacity: 0.5;
        cursor: default;
      }
      .item-buyable {
        background: #242;
        border-left: 5px solid #0f0;
      }
      .item-buyable:hover {
        background: #353;
      }
      .item-cost {
        font-size: 10px;
        color: #aaa;
      }

      /* --- Explore Screen --- */
      #explore-screen {
        position: relative;
      }
      canvas {
        display: block;
        background: #000;
      }
      #explore-ui {
        position: absolute;
        top: 10px;
        left: 10px;
        pointer-events: none;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border: 1px solid #555;
      }
      #stealth-indicator {
        font-weight: bold;
        color: #444;
      }
      #stealth-indicator.active {
        color: #0ff;
        text-shadow: 0 0 5px #0ff;
      }
      #explore-log {
        position: absolute;
        bottom: 10px;
        left: 10px;
        width: 400px;
        height: 120px;
        background: rgba(0, 0, 0, 0.6);
        font-size: 12px;
        overflow: hidden;
        display: flex;
        flex-direction: column-reverse;
        pointer-events: none;
      }
      .log-msg {
        padding: 2px;
        border-bottom: 1px solid #333;
      }

      /* --- Explore Equipment Panel --- */
      #explore-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 350px;
        max-height: 600px;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #555;
        padding: 10px;
        overflow-y: auto;
        display: none;
        z-index: 100;
        pointer-events: auto;
      }
      #explore-panel.visible {
        display: block;
      }
      #explore-panel-toggle {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 101;
        pointer-events: auto;
        padding: 8px 12px;
        font-size: 12px;
      }
      .deck-list {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-top: 10px;
        max-height: 200px;
        overflow-y: auto;
      }
      .deck-card {
        background: #2a2a2a;
        border: 1px solid #555;
        padding: 4px 8px;
        border-radius: 3px;
        font-size: 11px;
        color: #fff;
      }
      .deck-card-name {
        font-weight: bold;
      }
      .deck-card-type {
        font-size: 9px;
        color: #aaa;
        text-transform: uppercase;
      }

      /* --- Battle Screen --- */
      #battle-screen {
        padding: 10px;
        background: #221;
      }
      #battle-area {
        flex: 1;
        display: flex;
        justify-content: space-between;
        padding: 40px;
        align-items: center;
      }

      .unit-display {
        text-align: center;
        width: 200px;
        position: relative;
      }
      .sprite {
        width: 100px;
        height: 100px;
        background: #444;
        margin: 0 auto 10px;
        border: 2px solid #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 40px;
        position: relative;
      }
      .sprite.enemy {
        border-color: #f55;
        background: #311;
      }

      .intent-icon {
        position: absolute;
        top: -30px;
        right: -10px;
        background: #222;
        border: 1px solid #fff;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 14px;
        color: #fff;
        min-width: 50px;
      }
      .intent-icon.atk {
        background: #a33;
        border-color: #f00;
      }
      .intent-icon.def {
        background: #33a;
        border-color: #00f;
      }
      .intent-icon.debuff {
        background: #333;
        border-color: #888;
      }

      .bar-bg {
        width: 100%;
        height: 10px;
        background: #333;
        margin: 2px 0;
      }
      .hp-fill {
        height: 100%;
        background: #d44;
        width: 100%;
        transition: width 0.3s;
      }
      .pos-fill {
        height: 100%;
        background: #eb2;
        width: 100%;
        transition: width 0.3s;
      }

      #p-blk-text {
        position: absolute;
        top: 15px;
        left: 15px;
        background: #007bff;
        color: #fff;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        border: 2px solid #fff;
        font-size: 16px;
      }

      #enemy-status {
        margin-top: 5px;
        min-height: 20px;
      }
      .status-badge {
        display: inline-block;
        padding: 2px 6px;
        margin-right: 5px;
        border-radius: 3px;
        font-size: 10px;
        color: #fff;
        font-weight: bold;
      }

      #hand-container {
        height: 180px;
        display: flex;
        justify-content: center;
        align-items: flex-end;
        gap: 10px;
        padding-bottom: 10px;
      }
      .card {
        width: 100px;
        height: 140px;
        background: #eee;
        color: #000;
        border-radius: 5px;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 5px;
        cursor: pointer;
        transition: 0.2s;
        position: relative;
        box-shadow: 0 5px 15px #000;
      }
      .card:hover {
        transform: translateY(-20px);
        z-index: 100;
      }
      .card-cost {
        position: absolute;
        top: -10px;
        left: -10px;
        width: 25px;
        height: 25px;
        background: #007bff;
        color: #fff;
        border-radius: 50%;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid #fff;
      }
      .card-type {
        font-size: 10px;
        color: #555;
        text-transform: uppercase;
        margin-bottom: 5px;
      }
      .card-name {
        font-weight: bold;
        font-size: 12px;
        text-align: center;
        margin-bottom: auto;
      }
      .card-desc {
        font-size: 10px;
        text-align: center;
      }
      .unplayable {
        filter: grayscale(1);
        opacity: 0.6;
        cursor: not-allowed;
      }
      /* „É™„Ç∂„É´„ÉàÁîªÈù¢Áî®„ÅÆ„Çπ„Çø„Ç§„É´ */
      #result-screen h1 {
        font-size: 60px;
        margin-bottom: 20px;
      }
      .result-stat {
        font-size: 24px;
        margin: 10px 0;
        color: #ddd;
      }
      .score-text {
        font-size: 40px;
        color: #ffd700; /* ÈáëËâ≤ */
        margin-top: 20px;
        font-weight: bold;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      }
      .game-over-text {
        font-size: 80px;
        color: #f00;
        font-family: "Courier New", monospace;
        text-shadow: 0 0 20px #f00;
      }
      /* --- ËøΩÂä†„Éª‰øÆÊ≠£ CSS --- */

      /* Flux Gauge (ÁÜ±Èáè) */
      .flux-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 300px;
        text-align: center;
        z-index: 50;
        pointer-events: none; /* „ÇØ„É™„ÉÉ„ÇØ„ÇíÈÇ™È≠î„Åó„Å™„ÅÑ */
        display: none; /* Êà¶Èóò‰∏≠„ÅÆ„ÅøË°®Á§∫ */
      }
      .flux-container.active {
        display: block;
      }

      .flux-bar-bg {
        width: 100%;
        height: 20px;
        background: #222;
        border: 2px solid #555;
        margin-top: 5px;
        position: relative;
      }
      .flux-fill {
        height: 100%;
        background: linear-gradient(90deg, #0af, #fa0, #f00);
        width: 0%;
        transition: width 0.1s linear;
      }
      .flux-danger {
        animation: pulse-red 0.5s infinite;
      }
      @keyframes pulse-red {
        0% {
          box-shadow: 0 0 5px #f00;
        }
        50% {
          box-shadow: 0 0 20px #f00;
        }
        100% {
          box-shadow: 0 0 5px #f00;
        }
      }

      /* AIS Probability Display (Ë™≠„ÅøÂêà„ÅÑUI) */
      .ais-panel {
        position: absolute;
        top: 60px;
        right: 20px;
        width: 180px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #777;
        padding: 10px;
        font-size: 12px;
        color: #fff;
      }
      .ais-bar-row {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
      }
      .ais-label {
        width: 40px;
      }
      .ais-bar-track {
        flex: 1;
        height: 8px;
        background: #333;
        margin-left: 5px;
      }
      .ais-bar-val {
        height: 100%;
        background: #fff;
      }

      /* Command Slots (Êóß„Éè„É≥„Éâ„Ç®„É™„Ç¢„ÅÆÂà∑Êñ∞) */
      #command-container {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        width: 90%;
        justify-content: center;
        flex-wrap: wrap;
      }
      .cmd-btn {
        width: 80px;
        height: 100px;
        background: #333;
        border: 2px solid #555;
        color: #fff;
        font-size: 11px;
        position: relative;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 4px;
        transition: 0.1s;
      }
      .cmd-btn:hover {
        border-color: #fff;
        background: #444;
      }
      .cmd-btn.disabled {
        opacity: 0.4;
        pointer-events: none;
        filter: grayscale(1);
      }
      .cmd-btn.active-chain {
        border-color: #0ff;
        box-shadow: 0 0 10px #0ff;
      }

      .cmd-tag {
        font-size: 9px;
        color: #aaa;
        margin-bottom: 2px;
      }
      .cmd-flux {
        color: #f55;
        font-weight: bold;
      }
      .cmd-durability {
        position: absolute;
        bottom: 2px;
        right: 2px;
        font-size: 10px;
        color: #0f0;
      }
      .cmd-type-atk {
        border-top: 3px solid #d44;
      }
      .cmd-type-def {
        border-top: 3px solid #44d;
      }
      .cmd-type-skill {
        border-top: 3px solid #ea0;
      }

      /* Chain Mode Overlay */
      .chain-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        z-index: 40;
        display: none;
        box-shadow: inset 0 0 50px #0ff;
      }
      .chain-overlay.active {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <!-- 1. TITLE SCREEN -->
      <div id="title-screen" class="screen">
        <h1 class="title-text">THREE DAYS‚öî</h1>
        <p>Ver.38.2 - Craft Fix</p>
        <p>3Êó•Âæå„Å´ÂØæÂ≥ô„Åô„ÇãÂ∑®Â§ß„Å™Êïµ„ÇíÂÄí„Åõ„ÄÇ</p>
        <p>„Åù„Çå„Åæ„Åß„Å´Êé¢Á¥¢„ÄÅ„ÇØ„É©„Éï„Éà„ÇíÁπ∞„ÇäËøî„Åó„Å¶Ê∫ñÂÇô„Åõ„Çà„ÄÇ</p>
        <button
          onclick="game.startNewGame()"
          style="font-size: 20px; padding: 15px 40px; margin-top: 20px"
        >
          START GAME
        </button>
      </div>

      <!-- 2. BASE SCREEN -->
      <div id="base-screen" class="screen">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
          "
        >
          <h2>Êã†ÁÇπ (DAY <span id="base-day">1</span>)</h2>
          <div id="base-nav">
            <button onclick="game.startExplore()">Êé¢Á¥¢„Å´Âá∫„Çã</button>
            <button onclick="game.rest()">‰ºëÊÜ© (Ê¨°„ÅÆÊó•„Å´ÈÄ≤„ÇÄ)</button>
          </div>
        </div>
        <div class="base-layout">
          <div class="panel">
            <h3>Ë£ÖÂÇô</h3>
            <div id="loadout-list">
              <!-- Loadout items will be rendered here -->
            </div>
          </div>
          <div class="panel">
            <h3>„Çπ„ÉÜ„Éº„Çø„Çπ & ÊâãËç∑Áâ©</h3>
            <div style="padding: 10px">
              <p>
                HP: <span id="base-hp"></span>/<span id="base-maxhp"></span>
              </p>
              <p>Á¥†Êùê: <span id="base-mats"></span></p>
              <p>„Éá„ÉÉ„Ç≠„Çµ„Ç§„Ç∫: <span id="base-decksize"></span> Êûö</p>
              <p style="margin-top: 10px; color: #ffd700">
                ÊâãËç∑Áâ©: <span id="inventory-count">0</span>/25
              </p>
            </div>
            <div
              style="
                margin-top: 20px;
                border-top: 1px solid #555;
                padding: 10px;
              "
            >
              <h4 style="margin: 0 0 10px 0; color: #ffd700">„Éá„ÉÉ„Ç≠</h4>
              <div id="base-deck-list" class="deck-list"></div>
            </div>
            <div
              style="
                margin-top: 20px;
                border-top: 1px solid #555;
                padding: 10px;
              "
            >
              <h4 style="margin: 0 0 10px 0; color: #ffd700">ÊâãËç∑Áâ©</h4>
              <div
                id="inventory-list"
                style="max-height: 150px; overflow-y: auto"
              ></div>
            </div>
          </div>
          <div class="panel">
            <h3>ÂÄâÂ∫´</h3>
            <div
              style="
                padding: 10px;
                font-size: 12px;
                color: #aaa;
                margin-bottom: 10px;
              "
            >
              „Åì„Åì„Å´‰øùÁÆ°„Åó„Åü„ÇÇ„ÅÆ„ÅØ„ÄÅÊ¨°ÂõûËµ∑ÂãïÊôÇ„Å´„ÇÇ‰øùÊåÅ„Åï„Çå„Åæ„Åô
            </div>
            <div
              id="storage-list"
              style="max-height: 400px; overflow-y: auto"
            ></div>
          </div>
        </div>
      </div>

      <!-- 3. EXPLORE SCREEN -->
      <div
        id="explore-screen"
        class="screen"
        style="justify-content: center; align-items: center"
      >
        <canvas id="dungeonCanvas" width="984" height="728"></canvas>
        <button id="explore-panel-toggle" onclick="game.toggleExplorePanel()">
          Ë£ÖÂÇô (E)
        </button>
        <div id="explore-ui">
          <div>Âº∑Âà∂Â∏∞ÈÇÑ„Åæ„Åß: <span id="exp-time">180</span>s</div>
          <div>
            HP: <span id="exp-hp"></span> | „Çπ„Çø„Éü„Éä: <span id="exp-st"></span>
          </div>
          <div id="stealth-indicator">„Çπ„ÉÜ„É´„Çπ„É¢„Éº„Éâ (Shift)</div>
        </div>
        <div id="explore-log"></div>
        <div id="explore-panel">
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 10px;
            "
          >
            <h3 style="margin: 0">Ë£ÖÂÇô & „Éá„ÉÉ„Ç≠</h3>
            <button
              onclick="game.toggleExplorePanel()"
              style="padding: 4px 8px; font-size: 11px"
            >
              √ó Close
            </button>
          </div>
          <div
            style="
              margin-bottom: 10px;
              padding: 8px;
              background: rgba(255, 255, 255, 0.05);
              border-radius: 4px;
              font-size: 11px;
            "
          >
            <div><strong>Á¥†Êùê:</strong> <span id="explore-mats"></span></div>
          </div>
          <div id="explore-loadout-list"></div>
          <div
            style="
              margin-top: 20px;
              border-top: 1px solid #555;
              padding-top: 10px;
            "
          >
            <h4 style="margin: 0 0 10px 0; color: #ffd700">„Éá„ÉÉ„Ç≠</h4>
            <div id="explore-deck-list" class="deck-list"></div>
          </div>
        </div>
      </div>

      <!-- 4. BATTLE SCREEN -->
      <div id="battle-screen" class="screen">
        <div class="flux-container active">
          <div
            style="color: #0ff; font-weight: bold; text-shadow: 0 0 5px #0ff"
          >
            FLUX (ÁÜ±Èáè)
          </div>
          <div class="flux-bar-bg"><div class="flux-fill"></div></div>
        </div>

        <div id="ais-panel" class="ais-panel" style="display: none">
          <div style="color: #fa0; margin-bottom: 5px">AIS PREDICTION</div>
          <div class="ais-bar-row">
            <span class="ais-label">ATK</span>
            <div class="ais-bar-track">
              <div
                id="ais-atk-val"
                class="ais-bar-val"
                style="background: #d44"
              ></div>
            </div>
          </div>
          <div class="ais-bar-row">
            <span class="ais-label">DEF</span>
            <div class="ais-bar-track">
              <div
                id="ais-def-val"
                class="ais-bar-val"
                style="background: #44d"
              ></div>
            </div>
          </div>
          <div class="ais-bar-row">
            <span class="ais-label">SKL</span>
            <div class="ais-bar-track">
              <div
                id="ais-skl-val"
                class="ais-bar-val"
                style="background: #ea0"
              ></div>
            </div>
          </div>
        </div>

        <div style="position: absolute; top: 20px; right: 20px; z-index: 100">
          <button
            id="btn-end-chain"
            onclick="battle.endChain()"
            style="
              background: #d44;
              display: none;
              padding: 15px 30px;
              font-weight: bold;
            "
          >
            FINISH CHAIN („Çø„Éº„É≥ÁµÇ‰∫Ü)
          </button>
        </div>

        <div id="battle-area">
          <div class="unit-display">
            <div class="sprite" style="border-color: #4f4; color: #4f4">
              ü§ñ <span id="p-blk-text">0</span>
            </div>
            <div>PLAYER</div>
            <div class="bar-bg"><div class="hp-fill" id="p-hp-bar"></div></div>
            <div>HP: <span id="p-hp-text"></span></div>
            <div style="color: #0ff; font-weight: bold; font-size: 16px">
              <span id="p-en-text">EP: 10/10</span>
            </div>
          </div>

          <div class="unit-display">
            <div class="sprite enemy">üëæ</div>
            <div id="e-name">Enemy</div>
            <div class="bar-bg"><div class="hp-fill" id="e-hp-bar"></div></div>
            <div class="bar-bg">
              <div class="pos-fill" id="e-pos-bar"></div>
            </div>
            <div style="font-size: 15px; color: #ea0">‰ΩìÂππ</div>
            <div id="enemy-status"></div>
          </div>
        </div>

        <div id="command-container"></div>

        <div
          style="
            position: absolute;
            bottom: 5px;
            right: 10px;
            font-size: 12px;
            color: #888;
          "
        >
          ‚Äª „ÇØ„É™„ÉÉ„ÇØ„ÅßÂÆüË°å / Flux 100„Åß„Ç™„Éº„Éê„Éº„É≠„Éº„Éâ
        </div>
      </div>
      <div
        id="result-screen"
        class="screen"
        style="justify-content: center; align-items: center; text-align: center"
      >
        <div id="result-content"></div>
        <button
          onclick="location.reload()"
          style="margin-top: 30px; padding: 10px 20px"
        >
          „Çø„Ç§„Éà„É´„Å´Êàª„Çã
        </button>
      </div>
    </div>

    <script>
      /* --- 1. DATA DEFINITIONS --- */
      /* --- 1. DATA DEFINITIONS (AIS-Flux System) --- */

      // „Ç≥„Éû„É≥„ÉâÂÆöÁæ©Ôºö„Åô„Åπ„Å¶„ÅÆÊäÄ„ÅØ„Åì„Åì„Å´„ÅÇ„Çã
      const COMMANDS = {
        // --- Ê≠¶Âô®Á≥ª (ATTACK) ---
        slash: {
          name: "Êñ¨ÊíÉ",
          type: "ATTACK",
          tags: ["SLASH"],
          chain: "LINK",
          flux: 15,
          cost: 0,
          val: 12,
          pos: 5,
          dur: 1,
        },
        heavy_slash: {
          name: "Âº∑Êñ¨„Çä",
          type: "ATTACK",
          tags: ["SLASH"],
          chain: "FINISH",
          flux: 30,
          cost: 0,
          val: 25,
          pos: 15,
          dur: 2,
        },
        smash: {
          name: "Á≤âÁ†ï",
          type: "ATTACK",
          tags: ["IMPACT"],
          chain: "LINK",
          flux: 20,
          cost: 0,
          val: 15,
          pos: 20,
          dur: 2,
        },
        poke: {
          name: "Á™Å„Åç",
          type: "ATTACK",
          tags: ["PIERCE"],
          chain: "START",
          flux: 10,
          cost: 0,
          val: 8,
          pos: 3,
          dur: 1,
        },
        snipe: {
          name: "ÁãôÊíÉ",
          type: "ATTACK",
          tags: ["PIERCE"],
          chain: "FINISH",
          flux: 25,
          cost: 0,
          val: 30,
          pos: 5,
          dur: 3,
        },

        // --- Èò≤ÂÖ∑Á≥ª (DEFEND) ---
        guard: {
          name: "„Ç¨„Éº„Éâ",
          type: "DEFEND",
          tags: ["BLOCK"],
          chain: "START",
          flux: 5,
          cost: 0,
          val: 8,
          dur: 1,
        },
        parry: {
          name: "„Éë„É™„Ç£",
          type: "DEFEND",
          tags: ["BLOCK"],
          chain: "LINK",
          flux: 10,
          cost: 0,
          val: 12,
          dur: 2,
          desc: "FluxËªΩÊ∏õ",
        },
        dodge: {
          name: "ÂõûÈÅø",
          type: "DEFEND",
          tags: ["MOVE"],
          chain: "START",
          flux: 0,
          cost: 0,
          val: 5,
          dur: 1,
        },

        // --- „Çπ„Ç≠„É´/„Ç¢„ÇØ„Çª„Çµ„É™Á≥ª (SKILL/VENT) ---
        vent: {
          name: "ÊéíÁÜ±",
          type: "SKILL",
          tags: ["VENT"],
          chain: "ANY",
          flux: -50,
          cost: 3,
          val: 0,
          dur: 0,
          desc: "Flux-50 (EP3)",
        },
        feint: {
          name: "„Éï„Çß„Ç§„É≥„Éà",
          type: "SKILL",
          tags: ["TRICK"],
          chain: "START",
          flux: 5,
          cost: 1,
          val: 0,
          dur: 1,
          desc: "AISÊìç‰Ωú",
        },
        focus: {
          name: "ÈõÜ‰∏≠",
          type: "SKILL",
          tags: ["BUFF"],
          chain: "START",
          flux: 5,
          cost: 1,
          val: 0,
          dur: 1,
          desc: "EP+1",
        },
        analyze: {
          name: "Ëß£Êûê",
          type: "SKILL",
          tags: ["TECH"],
          chain: "START",
          flux: 0,
          cost: 0,
          val: 0,
          dur: 0,
          desc: "Á¢∫ÁéáÈñãÁ§∫",
        },
      };

      // Ë£ÖÂÇôÂìÅÂÆöÁæ©Ôºö„É≠„Éº„Éâ„Ç¢„Ç¶„Éà„Åå„Ç≥„Éû„É≥„Éâ„Çπ„É≠„ÉÉ„Éà„ÇíÊ±∫„ÇÅ„Çã
      const WEAPONS = {
        sword: {
          name: "Ââ£",
          slots: ["slash", "slash", "slash", "heavy_slash", "poke"],
          type: "w",
          craft_cost: { scrap: 2 },
          durability: 50,
        },
        hammer: {
          name: "„Éè„É≥„Éû„Éº",
          slots: ["smash", "smash", "smash", "guard", "guard"],
          type: "w",
          craft_cost: { scrap: 3 },
          durability: 60,
        },
        sniper: {
          name: "„É©„Ç§„Éï„É´",
          slots: ["snipe", "snipe", "poke", "poke", "dodge"],
          type: "w",
          craft_cost: { chip: 2 },
          durability: 40,
        },
      };

      const ARMORS = {
        light: {
          name: "ËªΩË£ÖÁî≤",
          slots: ["dodge", "dodge", "guard"],
          type: "a",
          craft_cost: { chip: 1 },
          durability: 40,
        },
        heavy: {
          name: "ÈáçË£ÖÁî≤",
          slots: ["guard", "guard", "parry"],
          type: "a",
          craft_cost: { scrap: 2 },
          durability: 80,
        },
      };

      const GADGETS = {
        none: {
          name: "„Å™„Åó",
          slots: ["focus", "focus"],
          type: "g",
          craft_cost: {},
        },
        cooler: {
          name: "ÂÜ∑Âç¥Ë£ÖÁΩÆ",
          slots: ["vent", "vent"],
          type: "g",
          craft_cost: { chip: 1 },
        },
        sensor: {
          name: "„Çª„É≥„Çµ„Éº",
          slots: ["analyze", "feint"],
          type: "g",
          craft_cost: { data: 1 },
        },
      };

      // Êïµ„ÅÆÊÄßÊ†ºÂÆöÁæ© (AIS)
      const AI_PERSONALITIES = {
        AGGRESSIVE: {
          name: "ÊîªÊíÉË°ùÂãïÂûã",
          weights: { ATTACK: 70, DEFEND: 20, SKILL: 10 },
        },
        CAUTIOUS: {
          name: "ÊÖéÈáçÂûã",
          weights: { ATTACK: 30, DEFEND: 50, SKILL: 20 },
        },
        TRICKSTER: {
          name: "Êíπ‰π±Âûã",
          weights: { ATTACK: 40, DEFEND: 20, SKILL: 40 },
        },
        BALANCED: {
          name: "„Éê„É©„É≥„ÇπÂûã",
          weights: { ATTACK: 34, DEFEND: 33, SKILL: 33 },
        },
      };

      const ENEMY_INTENTS = {
        ATTACK: {
          name: "ÊîªÊíÉ",
          icon: "‚öîÔ∏è",
          css: "atk",
          dmg: 10,
          posRegen: 10,
        },
        DEFEND: {
          name: "Èò≤Âæ°",
          icon: "üõ°Ô∏è",
          css: "def",
          block: 8,
          posRegen: 5,
        },
        DEBUFF: {
          name: "„Éá„Éê„Éï",
          icon: "üíÄ",
          css: "debuff",
          effect: "WEAK",
          posRegen: 0,
        },
      };

      /* --- 2. GAME ENGINE --- */
      const game = {
        state: "INIT",
        day: 1,
        /* --- 2. GAME ENGINE UPDATE --- */
        // game„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂÜÖ„ÅÆ player ÂÆöÁæ©„Çí‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´‰øÆÊ≠£„ÉªÊã°Âºµ„Åô„Çã
        // (game.player „ÅÆ‰∏≠Ë∫´„ÅÆ„ÅøÊäúÁ≤ã)
        player: {
          hp: 100,
          maxHp: 100,
          ep: 10,
          maxEp: 10, // Stamina„ÅØEP„Å´Áµ±Âêà
          loadout: { weapon: "sword", armor: "light", gadget: "cooler" }, // ÂàùÊúü„Ç¨„Ç∏„Çß„ÉÉ„Éà„Çícooler„Å´Â§âÊõ¥ÔºàVentÁî®Ôºâ
          // ËÄê‰πÖÂÄ§ÁÆ°ÁêÜ: ÁèæÂú®„ÅÆËÄê‰πÖÂÄ§„ÇíË®òÈå≤
          durability: { weapon: 50, armor: 40, gadget: 999 },
          mats: { scrap: 5, chip: 2, herb: 1, data: 0 },
          unlocked: {
            weapon: ["sword"],
            armor: ["light"],
            gadget: ["none", "cooler"],
          },
          inventory: [],
        },

        // game.init „ÇÑ startNewGame „ÅßËÄê‰πÖÂÄ§„Çí„É™„Çª„ÉÉ„Éà„Åô„ÇãÂá¶ÁêÜ„ÇíÂÖ•„Çå„Çã„Åì„Å®
        // game„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂÜÖ„Å´Ë®òËø∞„Åï„Çå„Å¶„ÅÑ„ÇãÂÜÖÂÆπ„Åò„ÇÉÔºÅ

        resetDurability() {
          const wDur = WEAPONS[this.player.loadout.weapon].durability;
          const aDur = ARMORS[this.player.loadout.armor].durability;

          // „Ç¨„Ç∏„Çß„ÉÉ„Éà„ÅØËÄê‰πÖÂÄ§„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÊåÅ„Åü„Å™„ÅÑÔºàÂ£ä„Çå„Å™„ÅÑÔºâÊÉ≥ÂÆö„ÅÆ„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØËÄê‰πÖÂÄ§„ÇíÂõ∫ÂÆöÂÄ§„ÅßÂàùÊúüÂåñ„Åô„Çã
          // „ÇÇ„ÅóGADGETSÂÆöÁæ©„Å´ËÄê‰πÖÂÄ§„Éó„É≠„Éë„ÉÜ„Ç£„Åå„ÅÇ„Çå„Å∞„Åù„Çå„ÇíÂèÇÁÖß„Åô„Çã„Çà„ÅÜ„Å´‰øÆÊ≠£„Åò„ÇÉ
          this.player.durability.weapon = wDur;
          this.player.durability.armor = aDur;
          this.player.durability.gadget = 999; // Â£ä„Çå„Å™„ÅÑÂ§ß„Åç„Å™ÂÄ§„ÅßÂàùÊúüÂåñ„Åò„ÇÉ
        },
        storage: {
          materials: { scrap: 0, chip: 0, herb: 0, data: 0 },
          equipment: [], // ‰øùÁÆ°Â∫´„ÅÆË£ÖÂÇô„É™„Çπ„Éà
        },
        MAX_INVENTORY_SIZE: 25,

        init() {
          this.loadStorage(); // ‰øùÁÆ°Â∫´„ÇíË™≠„ÅøËæº„Åø
          this.showScreen("title-screen");
        },
        // ‰øùÁÆ°Â∫´„ÇílocalStorage„Åã„ÇâË™≠„ÅøËæº„Åø
        loadStorage() {
          const saved = localStorage.getItem("dustfall_storage");
          if (saved) {
            try {
              this.storage = JSON.parse(saved);
            } catch (e) {
              console.error("Failed to load storage:", e);
            }
          }
        },
        // ‰øùÁÆ°Â∫´„ÇílocalStorage„Å´‰øùÂ≠ò
        saveStorage() {
          try {
            localStorage.setItem(
              "dustfall_storage",
              JSON.stringify(this.storage)
            );
          } catch (e) {
            console.error("Failed to save storage:", e);
          }
        },
        // ÊâÄÊåÅÂìÅÊï∞„ÅÆË®àÁÆó
        getInventoryCount() {
          let count = 0;
          // Á¥†Êùê„ÅÆÊï∞„Çí„Ç´„Ç¶„É≥„Éà
          for (const [mat, amount] of Object.entries(this.player.mats)) {
            count += amount;
          }
          // „Ç§„É≥„Éô„É≥„Éà„É™ÂÜÖ„ÅÆË£ÖÂÇôÊï∞„Çí„Ç´„Ç¶„É≥„Éà
          count += this.player.inventory.length;
          return count;
        },
        showScreen(id) {
          document
            .querySelectorAll(".screen")
            .forEach((el) => el.classList.remove("active"));
          const target = document.getElementById(id);
          if (target) target.classList.add("active");
        },
        // game„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂÜÖ„Å´Ë®òËø∞„Åï„Çå„Å¶„ÅÑ„ÇãÂÜÖÂÆπ„Åò„ÇÉÔºÅ

        equipItem(type, itemId) {
          if (!this.player.unlocked[type].includes(itemId)) {
            this.log(`Error: ${itemId}„ÅØÊú™ÈñãÊîæ„Åò„ÇÉ„ÄÇ`);
            return;
          }
          this.player.loadout[type] = itemId;
          this.log(`${type}„Çí${itemId}„Å´Ë£ÖÂÇôÂ§âÊõ¥„Åó„Åü„ÅûÔºÅ`);

          // Ë£ÖÂÇôÂ§âÊõ¥„Åó„Åü„ÇâËÄê‰πÖÂÄ§„Çí„É™„Çª„ÉÉ„Éà„Åô„ÇãÔºàÊñ∞„Åó„ÅÑË£ÖÂÇô„ÅØÊñ∞ÂìÅ„ÅÆÁä∂ÊÖã„Åò„ÇÉÔºâ
          this.resetDurability();

          this.updateBaseUI(); // UI„ÇíÂÜçÊèèÁîª„Åô„Çã
        },
        startNewGame() {
          this.day = 1;
          this.player.hp = 100;
          this.updateBaseUI();
          this.showScreen("base-screen");
          this.state = "BASE";
        },
        startExplore() {
          try {
            dungeon.init(this.day);
            this.showScreen("explore-screen");
            this.state = "EXPLORE";
            dungeon.start();
          } catch (error) {
            console.error("Error in startExplore:", error);
            alert("„Éû„ÉÉ„ÉóÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: " + error.message);
          }
        },
        rest() {
          this.day++;
          this.player.hp = this.player.maxHp;
          this.updateBaseUI();
          alert(`‰ºëÊÜ©„ÇíÁµÇ„Åà„Åæ„Åó„Åü„ÄÇDAY ${this.day} „ÅåÂßã„Åæ„Çä„Åæ„Åô„ÄÇ`);
        },
        // rest() „É°„ÇΩ„ÉÉ„Éâ„ÅÆ‰∏ã„ÅÇ„Åü„Çä„Å´ËøΩÂä†„Åò„ÇÉ
        startBossBattle() {
          if (!confirm("Ê∫ñÂÇô„ÅØ„ÅÑ„ÅÑ„ÅãÔºü „Åì„Çå„ÅåÊúÄÂæå„ÅÆÊà¶„ÅÑ„Å†„ÄÇ")) return;

          // „Éú„Çπ„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÂÆöÁæ©Ôºà„Åã„Å™„ÇäÂº∑„ÅèË®≠ÂÆö„Åô„Çã„ÅûÔºâ
          const boss = {
            hp: 300, // ÈÄöÂ∏∏Êïµ„ÅÆ3ÂÄç
            maxHp: 300,
            pos: 200, // ‰ΩìÂππ„ÇÇÂº∑„ÅÑ
            maxPos: 200,
            isBroken: false,
            brokenTurns: 0,
            enemyBlock: 0,
            status: { mark: 0 },
            nextIntent: null,
            // „Éú„ÇπÂ∞ÇÁî®„ÅÆÁâπÂà•„Å™„Éï„É©„Ç∞„ÇÑÂêçÂâç„ÇíÊåÅ„Åü„Åõ„Å¶„ÇÇ„Çà„ÅÑ„Åå„ÄÅ‰ªäÂõû„ÅØ„Ç∑„É≥„Éó„É´„Å´
            // ÂêçÂâçË°®Á§∫„Å™„Å©„ÅØ battle.updateUI „Åß "Enemy" „Å®„Å™„Çã„Åå„ÄÅÂæå„ÅßÂ§â„Åà„Çã„Åì„Å®„ÇÇÂèØËÉΩ
          };

          // Áä∂ÊÖã„ÇíBATTLE„Å´Â§âÊõ¥
          this.state = "BATTLE";
          dungeon.stop(); // Âøµ„ÅÆ„Åü„ÇÅ„ÉÄ„É≥„Ç∏„Éß„É≥„Çø„Ç§„Éû„ÉºÂÅúÊ≠¢
          battle.isBossBattle = true;
          // Êà¶ÈóòÈñãÂßãÔºÅ
          // Á¨¨1ÂºïÊï∞„ÅØ„ÉÄ„É≥„Ç∏„Éß„É≥‰∏ä„ÅÆ„Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£„Å†„Åå„ÄÅ„Éú„Çπ„ÅØ„Éû„ÉÉ„Éó„Å´„ÅÑ„Å™„ÅÑ„ÅÆ„Åß null „ÇíÊ∏°„Åô
          // Á¨¨2ÂºïÊï∞„ÅØÂ•áË•≤„Éï„É©„Ç∞„ÄÇ„Éú„ÇπÊà¶„ÅßÂ•áË•≤„ÅØ„Åß„Åç„Å™„ÅÑ„ÅÆ„Åß false
          battle.start(null, false);

          // battle.start„ÅÆ‰∏≠„Åß‰Ωú„Çâ„Çå„Çã this.enemy „Çí„Éú„Çπ„Éá„Éº„Çø„Åß‰∏äÊõ∏„Åç„Åô„Çã
          // (battle.start „ÅØÈÄöÂ∏∏„ÅÆÊïµHP100„Åß‰Ωú„Å£„Å¶„Åó„Åæ„ÅÜ„Åü„ÇÅ)
          battle.enemy = boss;
          battle.selectIntent(); // „Éú„Çπ„ÅÆÊúÄÂàù„ÅÆË°åÂãï„ÇíÊ±∫ÂÆö

          // ÁîªÈù¢Âàá„ÇäÊõø„Åà
          this.showScreen("battle-screen");

          // „Éú„ÇπÊà¶„Åß„ÅÇ„Çã„Åì„Å®„Çí„É≠„Ç∞„Å´Âá∫„Åô
          this.log("‚ö†Ô∏è BOSS BATTLE START ‚ö†Ô∏è");
        },
        returnToDungeon(enemyKilled) {
          this.log(enemyKilled ? "Êïµ„ÇíÂÄí„Åó„Åæ„Åó„ÅüÔºÅ" : "Êà¶Èóò„Åã„ÇâÈÄÉ„Çå„Åæ„Åó„Åü„ÄÇ");
          this.player.playerBlock = 0;
          this.showScreen("explore-screen");
          this.state = "EXPLORE";
          dungeon.start();
        },
        returnToBase(success) {
          dungeon.stop();
          this.day++;
          if (!success) {
            this.player.hp = Math.max(1, this.player.hp * 0.1);
            alert(
              `Âº∑Âà∂Â∏∞ÈÇÑ„ÄÇÁèæÂú®„ÅÆÊâãËç∑Áâ©„ÅØÂÖ®„Å¶Âñ™Â§±„Åó„Åæ„Åô„ÄÇ\n(DAY ${this.day} „Å´„Å™„Çä„Åæ„Åó„Åü)`
            );
          } else {
            alert(`ÂÆâÂÖ®„Å´Â∏∞ÈÇÑ„Åó„Åæ„Åó„Åü„ÄÇ\n(DAY ${this.day} „Å´„Å™„Çä„Åæ„Åó„Åü)`);
          }
          this.player.playerBlock = 0;
          this.updateBaseUI();
          this.showScreen("base-screen");
          this.state = "BASE";
        },
        log(message) {
          const logEl = document.getElementById("explore-log");
          if (logEl) {
            const msgEl = document.createElement("div");
            msgEl.className = "log-msg";
            msgEl.innerText = message;
            logEl.prepend(msgEl);
            while (logEl.children.length > 20)
              logEl.removeChild(logEl.lastChild);
          }
        },
        buyAndEquip(itemKey, type, itemCost) {
          // ‰øÆÊ≠£ÁÇπ: itemCost (craft_cost) „ÇíÊ≠£„Åó„Åè„ÉÅ„Çß„ÉÉ„ÇØ
          // Êé¢Á¥¢‰∏≠„ÅÆÁ¥†Êùê„ÅÆ„Åø„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºà‰øùÁÆ°Â∫´„ÅÆÁ¥†Êùê„ÅØ‰ΩøÁî®‰∏çÂèØÔºâ
          for (const [mat, amount] of Object.entries(itemCost)) {
            if (this.player.mats[mat] < amount) {
              alert("Ë≥áÊùê„ÅåË∂≥„Çä„Å™„ÅÑ„ÄÇ\n(‰øùÁÆ°Â∫´„ÅÆÁ¥†Êùê„ÅØÊé¢Á¥¢‰∏≠„ÅØ‰ΩøÁî®„Åß„Åç„Åæ„Åõ„Çì)");
              return false;
            }
          }
          for (const [mat, amount] of Object.entries(itemCost)) {
            this.player.mats[mat] -= amount;
          }

          // Êó¢„Å´„Ç¢„É≥„É≠„ÉÉ„ÇØÊ∏à„Åø„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøËøΩÂä†
          if (!this.player.unlocked[type].includes(itemKey)) {
            this.player.unlocked[type].push(itemKey);
          }
          this.player.loadout[type] = itemKey; // Ë£ÖÂÇôÊõ¥Êñ∞
          this.updateBaseUI();
          // Êé¢Á¥¢‰∏≠„ÅÆÂ†¥Âêà„ÄÅ„Éë„Éç„É´„ÇÇÊõ¥Êñ∞
          if (this.state === "EXPLORE") {
            this.updateExplorePanel();
          }
          this.log(`„Äê${itemKey}„Äë„Çí‰ΩúÊàê„Åó„ÄÅË£ÖÂÇô„Åó„Åü„ÄÇ`);
          return true;
        },
        buildCommandList() {
          const l = this.player.loadout;
          const list = [];
          // Ë£ÖÂÇôÂìÅ„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„Åå .cards „Åã„Çâ .slots „Å´Â§â„Çè„Å£„Åü„Åü„ÇÅ‰øÆÊ≠£„Åò„ÇÉ
          list.push(...WEAPONS[l.weapon].slots);
          list.push(...ARMORS[l.armor].slots);
          list.push(...GADGETS[l.gadget].slots);
          return list;
        },
        renderCommandList(containerId) {
          const container = document.getElementById(containerId);
          if (!container) return;
          container.innerHTML = "";

          // „Ç≥„Éû„É≥„Éâ„É™„Çπ„Éà„ÇíÂèñÂæó
          const list = this.buildCommandList();

          const commandCounts = {};
          list.forEach((cmdId) => {
            commandCounts[cmdId] = (commandCounts[cmdId] || 0) + 1;
          });

          Object.keys(commandCounts).forEach((cmdId) => {
            // CARDS[cardId] „Å†„Å£„ÅüÈÉ®ÂàÜ„Çí COMMANDS[cmdId] „Å´‰øÆÊ≠£„Åò„ÇÉ
            const cmd = COMMANDS[cmdId];
            const count = commandCounts[cmdId];
            const el = document.createElement("div");
            el.className = "deck-card";
            el.innerHTML = `
            <div class="deck-card-name">${cmd.name}${
              count > 1 ? ` x${count}` : ""
            }</div>
            <div class="deck-card-type">${cmd.type} / Flux:${cmd.flux}</div>
        `;
            container.appendChild(el);
          });
        },
        startNewGame() {
          this.day = 1;
          this.player.hp = this.player.maxHp; // HP„ÇíÊúÄÂ§ßÂÄ§„ÅßÂàùÊúüÂåñ
          this.player.ep = this.player.maxEp; // EP„ÇÇÊúÄÂ§ßÂÄ§„ÅßÂàùÊúüÂåñ
          this.resetDurability(); // Ë£ÖÂÇôËÄê‰πÖÂÄ§„ÅÆÂàùÊúüÂåñÔºàÂâçÂõû„ÅÆÊåáÁ§∫„ÅßËøΩÂä†„Åó„Åü„ÅØ„Åö„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„Åò„ÇÉÔºâ
          this.updateBaseUI();
          this.showScreen("base-screen");
          this.state = "BASE";
        },
        // game„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂÜÖ„Å´Ë®òËø∞„Åï„Çå„Å¶„ÅÑ„ÇãÂÜÖÂÆπ„Åò„ÇÉÔºÅ

        renderLoadoutList(containerEl, onEquip) {
          containerEl.innerHTML = "";
          const currentLoadout = this.player.loadout;

          const renderList = (data, type, currentId) => {
            let html = `<h3>${type.toUpperCase()} - ${currentId.toUpperCase()}</h3>`;
            Object.keys(data).forEach((itemId) => {
              const item = data[itemId];
              const isEquipped = itemId === currentId;
              const isUnlocked = this.player.unlocked[type].includes(itemId);

              html += `
                <div class="loadout-item ${isEquipped ? "equipped" : ""} ${
                isUnlocked ? "" : "locked"
              }">
                    ${item.name} 
                    ${
                      isUnlocked
                        ? isEquipped
                          ? " (Ë£ÖÂÇô‰∏≠)"
                          : `<button onclick="game.equipItem('${type}', '${itemId}')">Ë£ÖÂÇô</button>`
                        : "(Êú™ÈñãÊîæ)"
                    }
                </div>
            `;
            });
            return html;
          };

          // WEAPONS, ARMORS, GADGETS „ÅÆÂÆöÁæ©„ÅØÊ≠£„Åó„ÅÑ„ÇÇ„ÅÆ„Å®„Åó„Å¶ÂèÇÁÖß„Åô„Çã„Åû
          containerEl.innerHTML += renderList(
            WEAPONS,
            "weapon",
            currentLoadout.weapon
          );
          containerEl.innerHTML += renderList(
            ARMORS,
            "armor",
            currentLoadout.armor
          );
          containerEl.innerHTML += renderList(
            GADGETS,
            "gadget",
            currentLoadout.gadget
          );

          // ÊúÄÂæå„Å´ onEquipÔºàË£ÖÂÇôÂæå„ÅÆUIÂÜçÊèèÁîª„Ç≥„Éº„É´„Éê„ÉÉ„ÇØÔºâ„ÇíÂÆüË°å„Åô„Çã
          if (onEquip) onEquip();
        },
        toggleExplorePanel() {
          const panel = document.getElementById("explore-panel");
          if (panel) {
            panel.classList.toggle("visible");
            if (panel.classList.contains("visible")) {
              this.updateExplorePanel();
            }
          }
        },
        updateExplorePanel() {
          const list = document.getElementById("explore-loadout-list");
          if (list) {
            this.renderLoadoutList(list, () => {
              this.updateExplorePanel();
            });
          }
          this.renderDeckList("explore-deck-list");

          // Á¥†ÊùêÊÉÖÂ†±„ÇíÊõ¥Êñ∞
          const matsEl = document.getElementById("explore-mats");
          if (matsEl) {
            const m = this.player.mats;
            matsEl.innerText = `Scrap:${m.scrap} Chip:${m.chip} Herb:${m.herb} Data:${m.data}`;
          }
        },
        updateBaseUI() {
          document.getElementById("base-day").innerText = this.day;
          document.getElementById("base-hp").innerText = this.player.hp;
          document.getElementById("base-maxhp").innerText = this.player.maxHp;
          const m = this.player.mats;
          document.getElementById(
            "base-mats"
          ).innerText = `Scrap:${m.scrap} Chip:${m.chip} Herb:${m.herb} Data:${m.data}`;
          document.getElementById("base-decksize").innerText =
            this.buildCommandList().length;

          const nav = document.getElementById("base-nav");
          if (nav) {
            // DAY„Åå4‰ª•‰∏äÔºà3Êó•ÁõÆ„ÅÆÊé¢Á¥¢ÁµÇ‰∫ÜÂæåÔºâ„Å™„Çâ„ÄÅ„Éú„ÇπÊà¶„É¢„Éº„Éâ„Å∏
            if (this.day > 3) {
              nav.innerHTML = `
                <button 
                  onclick="game.startBossBattle()" 
                  style="background: #c3073f; border-color: #f00; width: 100%; font-size: 18px; font-weight: bold;">
                  ‚ö†Ô∏è Ê±∫Êà¶„Å´Êåë„ÇÄ (FINAL BATTLE) ‚ö†Ô∏è
                </button>
              `;
            } else {
              // ÈÄöÂ∏∏ÊôÇ„ÅØ„ÅÑ„Å§„ÇÇ„ÅÆ„Éú„Çø„É≥„ÇíË°®Á§∫
              nav.innerHTML = `
                <button onclick="game.startExplore()">Êé¢Á¥¢„Å´Âá∫„Çã</button>
                <button onclick="game.rest()">‰ºëÊÜ© (Ê¨°„ÅÆÊó•„Å´ÈÄ≤„ÇÄ)</button>
              `;
            }
          }

          // „Ç§„É≥„Éô„É≥„Éà„É™Êï∞„ÅÆË°®Á§∫
          const invCount = this.getInventoryCount();
          const invCountEl = document.getElementById("inventory-count");
          if (invCountEl) invCountEl.innerText = invCount;

          const list = document.getElementById("loadout-list");
          if (list) {
            this.renderLoadoutList(list);
          }
          this.renderCommandList("base-deck-list");

          // „Ç§„É≥„Éô„É≥„Éà„É™„Å®‰øùÁÆ°Â∫´„ÅÆË°®Á§∫
          this.renderInventory();
          this.renderStorage();
        },
        // „Ç§„É≥„Éô„É≥„Éà„É™„ÅÆË°®Á§∫
        renderInventory() {
          const container = document.getElementById("inventory-list");
          if (!container) return;
          container.innerHTML = "";

          // Á¥†Êùê„ÇíË°®Á§∫
          const matTypes = ["scrap", "chip", "herb", "data"];
          matTypes.forEach((mat) => {
            const amount = this.player.mats[mat] || 0;
            if (amount > 0) {
              const el = document.createElement("div");
              el.className = "item-row";
              el.style.fontSize = "12px";
              el.innerHTML = `<span>${mat.toUpperCase()}: ${amount}</span><button onclick="game.moveToStorage('${mat}', ${amount})" style="padding: 2px 6px; font-size: 10px;">‚Üí Storage</button>`;
              container.appendChild(el);
            }
          });

          // „Ç§„É≥„Éô„É≥„Éà„É™ÂÜÖ„ÅÆË£ÖÂÇô„ÇíË°®Á§∫ÔºàÁèæÂú®„ÅØË£ÖÂÇô„Çí„Ç§„É≥„Éô„É≥„Éà„É™„Å´‰øùÂ≠ò„Åô„ÇãÊ©üËÉΩ„Åå„Å™„ÅÑ„Åü„ÇÅ„ÄÅÂ∞ÜÊù•„ÅÆÊã°ÂºµÁî®Ôºâ
          if (this.player.inventory.length > 0) {
            this.player.inventory.forEach((item, idx) => {
              const el = document.createElement("div");
              el.className = "item-row";
              el.style.fontSize = "12px";
              el.innerHTML = `<span>${
                item.name || item
              }</span><button onclick="game.moveToStorage('equip', ${idx})" style="padding: 2px 6px; font-size: 10px;">‚Üí Storage</button>`;
              container.appendChild(el);
            });
          }

          if (container.children.length === 0) {
            container.innerHTML =
              '<div style="color: #666; font-size: 11px; padding: 5px;">Empty</div>';
          }
        },
        // ‰øùÁÆ°Â∫´„ÅÆË°®Á§∫
        renderStorage() {
          const container = document.getElementById("storage-list");
          if (!container) return;
          container.innerHTML = "";

          // ‰øùÁÆ°Â∫´„ÅÆÁ¥†Êùê„ÇíË°®Á§∫
          const matTypes = ["scrap", "chip", "herb", "data"];
          matTypes.forEach((mat) => {
            const amount = this.storage.materials[mat] || 0;
            if (amount > 0) {
              const el = document.createElement("div");
              el.className = "item-row";
              el.style.fontSize = "12px";
              el.innerHTML = `<span>${mat.toUpperCase()}: ${amount}</span><div><button onclick="game.moveFromStorage('${mat}', 1)" style="padding: 2px 6px; font-size: 10px; margin-right: 2px;">‚Üê 1</button><button onclick="game.takeFromStorage('${mat}')" style="padding: 2px 6px; font-size: 10px;">‚Üê All</button></div>`;
              container.appendChild(el);
            }
          });

          // ‰øùÁÆ°Â∫´„ÅÆË£ÖÂÇô„ÇíË°®Á§∫
          if (this.storage.equipment && this.storage.equipment.length > 0) {
            this.storage.equipment.forEach((item, idx) => {
              const el = document.createElement("div");
              el.className = "item-row";
              el.style.fontSize = "12px";
              el.innerHTML = `<span>${
                item.name || item
              }</span><button onclick="game.moveFromStorage('equip', ${idx})" style="padding: 2px 6px; font-size: 10px;">‚Üê Take</button>`;
              container.appendChild(el);
            });
          }

          if (container.children.length === 0) {
            container.innerHTML =
              '<div style="color: #666; font-size: 11px; padding: 5px;">Empty</div>';
          }
        },
        // Á¥†Êùê„Çí‰øùÁÆ°Â∫´„Å´ÁßªÂãï
        moveToStorage(type, amountOrIndex) {
          if (type === "equip") {
            // Ë£ÖÂÇô„Çí‰øùÁÆ°Â∫´„Å´ÁßªÂãïÔºàÂ∞ÜÊù•„ÅÆÊã°ÂºµÁî®Ôºâ
            if (this.player.inventory[amountOrIndex]) {
              this.storage.equipment.push(this.player.inventory[amountOrIndex]);
              this.player.inventory.splice(amountOrIndex, 1);
              this.saveStorage();
              this.updateBaseUI();
            }
          } else {
            // Á¥†Êùê„Çí‰øùÁÆ°Â∫´„Å´ÁßªÂãï
            const amount = Math.min(amountOrIndex, this.player.mats[type] || 0);
            if (amount > 0) {
              this.player.mats[type] -= amount;
              this.storage.materials[type] =
                (this.storage.materials[type] || 0) + amount;
              this.saveStorage();
              this.updateBaseUI();
            }
          }
        },
        // ‰øùÁÆ°Â∫´„Åã„ÇâÁ¥†Êùê„ÇíÂèñ„ÇäÂá∫„Åô
        moveFromStorage(type, amountOrIndex) {
          if (type === "equip") {
            // Ë£ÖÂÇô„ÇíÂèñ„ÇäÂá∫„ÅôÔºàÊâÄÊåÅÂìÅÊï∞„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØÔºâ
            if (this.getInventoryCount() >= this.MAX_INVENTORY_SIZE) {
              alert("ÊâãËç∑Áâ©„Åå‰∏ÄÊùØ„Åß„Åô„ÄÇ(ÊúÄÂ§ß25ÂÄã)");
              return;
            }
            if (this.storage.equipment[amountOrIndex]) {
              this.player.inventory.push(this.storage.equipment[amountOrIndex]);
              this.storage.equipment.splice(amountOrIndex, 1);
              this.saveStorage();
              this.updateBaseUI();
            }
          } else {
            // Á¥†Êùê„ÇíÂèñ„ÇäÂá∫„ÅôÔºàÊâÄÊåÅÂìÅÊï∞„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØÔºâ
            const available = this.storage.materials[type] || 0;
            if (available === 0) return;

            const currentInvCount = this.getInventoryCount();
            const spaceAvailable = this.MAX_INVENTORY_SIZE - currentInvCount;
            if (spaceAvailable <= 0) {
              alert("ÊâãËç∑Áâ©„Åå‰∏ÄÊùØ„Åß„Åô„ÄÇ(ÊúÄÂ§ß25ÂÄã)");
              return;
            }

            // ÂÖ®ÈÉ®Âèñ„ÇäÂá∫„Åô„Åã„ÄÅ‰∏ÄÈÉ®„Å†„ÅëÂèñ„ÇäÂá∫„Åô„Åã„ÇíÈÅ∏Êäû
            const takeAmount = Math.min(
              amountOrIndex,
              available,
              spaceAvailable
            );
            if (takeAmount > 0) {
              this.storage.materials[type] -= takeAmount;
              this.player.mats[type] =
                (this.player.mats[type] || 0) + takeAmount;
              this.saveStorage();
              this.updateBaseUI();
            }
          }
        },
        // ‰øùÁÆ°Â∫´„Åã„ÇâÁ¥†Êùê„Çí‰∏ÄÈÉ®Âèñ„ÇäÂá∫„ÅôÔºà„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÅßÊï∞ÈáèÂÖ•ÂäõÔºâ
        takeFromStorage(type) {
          const available = this.storage.materials[type] || 0;
          if (available === 0) return;

          const currentInvCount = this.getInventoryCount();
          const spaceAvailable = this.MAX_INVENTORY_SIZE - currentInvCount;
          if (spaceAvailable <= 0) {
            alert("ÊâãËç∑Áâ©„Åå‰∏ÄÊùØ„Åß„Åô„ÄÇ(ÊúÄÂ§ß25ÂÄã)");
            return;
          }

          const maxTake = Math.min(available, spaceAvailable);
          const input = prompt(
            `How many ${type.toUpperCase()} to take? (Available: ${available}, Space: ${spaceAvailable})`,
            maxTake
          );
          if (input === null) return;

          const takeAmount = parseInt(input);
          if (isNaN(takeAmount) || takeAmount <= 0 || takeAmount > maxTake) {
            alert("Invalid amount!");
            return;
          }

          this.storage.materials[type] -= takeAmount;
          this.player.mats[type] = (this.player.mats[type] || 0) + takeAmount;
          this.saveStorage();
          this.updateBaseUI();
        },
        enterBattle(enemy, isAmbush) {
          dungeon.stop();
          this.state = "BATTLE";
          battle.start(enemy, isAmbush);
          this.showScreen("battle-screen");
        },
        // ... game„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰∏≠„Å´ËøΩÂä† ...

        // „Çπ„Ç≥„Ç¢Ë®àÁÆó„É≠„Ç∏„ÉÉ„ÇØ
        calculateScore(turns) {
          const hpBonus = this.player.hp * 20;
          // 50„Çø„Éº„É≥„ÇíÂü∫Ê∫ñ„Å´„ÄÅÊó©„Åë„Çå„Å∞Êó©„ÅÑ„Åª„Å©È´òÂæóÁÇπÔºà„Éû„Ç§„Éä„Çπ„Å´„ÅØ„Åó„Å™„ÅÑÔºâ
          const speedBonus = Math.max(0, (50 - turns) * 30);
          // ÊâÄÊåÅ„Åó„Å¶„ÅÑ„ÇãÁ¥†Êùê„ÅÆÁ∑è
          return hpBonus + speedBonus;
        },

        // „É™„Ç∂„É´„ÉàÁîªÈù¢„ÇíË°®Á§∫„Åô„ÇãÂá¶ÁêÜ
        showResult(isWin, turns) {
          const container = document.getElementById("result-content");

          if (isWin) {
            // ÂãùÂà©ÊôÇÔºöË©≥Á¥∞„ÇíË°®Á§∫
            const score = this.calculateScore(turns);
            container.innerHTML = `
              <h1 style="color: #4f4;">GAME CLEAR</h1>
              <div class="result-stat">ÊíÉÁ†¥„Çø„Éº„É≥Êï∞: <strong>${turns}</strong></div>
              <div class="result-stat">ÊÆã„ÇäHP: <strong>${this.player.hp}</strong></div>
              <div class="score-text">Á∑èÂêà„Éù„Ç§„É≥„Éà: ${score}ÁÇπ</div>
            `;
          } else {
            // ÊïóÂåóÊôÇÔºö„Ç∑„É≥„Éó„É´„Å´GAME OVER
            container.innerHTML = `
              <div class="game-over-text">GAME OVER</div>
            `;
          }

          this.showScreen("result-screen");
        },
      };

      /* --- 3. DUNGEON LOGIC --- */
      const MAP_WIDTH = 50;
      const MAP_HEIGHT = 50;
      const TILE_SIZE = 15;
      const dungeon = {
        canvas: null,
        ctx: null,
        gridX: MAP_WIDTH,
        gridY: MAP_HEIGHT,
        tile: TILE_SIZE,
        map: [],
        entities: [],
        p: { x: 1, y: 1 },
        timer: null,
        timeLeft: 180,
        lastTime: 0,
        enemyMoveTimer: 0,
        init(difficulty) {
          this.canvas = document.getElementById("dungeonCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.map = [];
          for (let y = 0; y < this.gridY; y++) {
            let row = [];
            for (let x = 0; x < this.gridX; x++) row.push(1);
            this.map.push(row);
          }

          // Room-and-Corridor ÊñπÂºè„ÅÆ„Éû„ÉÉ„ÉóÁîüÊàê
          const rooms = [];
          const minRoomSize = 4;
          const maxRoomSize = 8;
          const roomAttempts = 50;

          // 1. ÈÉ®Â±ã„ÇíÁîüÊàê
          for (let i = 0; i < roomAttempts; i++) {
            const width =
              minRoomSize +
              Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1));
            const height =
              minRoomSize +
              Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1));

            // Â¢ÉÁïå„ÉÅ„Çß„ÉÉ„ÇØ
            const maxX = Math.max(2, this.gridX - width - 4);
            const maxY = Math.max(2, this.gridY - height - 4);
            if (maxX <= 2 || maxY <= 2) continue; // „Éû„ÉÉ„Éó„ÅåÂ∞è„Åï„Åô„Åé„ÇãÂ†¥Âêà„Çπ„Ç≠„ÉÉ„Éó

            const x = 2 + Math.floor(Math.random() * (maxX - 2));
            const y = 2 + Math.floor(Math.random() * (maxY - 2));

            // ‰ªñ„ÅÆÈÉ®Â±ã„Å®Èáç„Å™„Å£„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            let overlaps = false;
            for (const room of rooms) {
              if (
                x < room.x + room.width + 2 &&
                x + width + 2 > room.x &&
                y < room.y + room.height + 2 &&
                y + height + 2 > room.y
              ) {
                overlaps = true;
                break;
              }
            }

            if (!overlaps) {
              rooms.push({ x, y, width, height });
              // ÈÉ®Â±ã„ÇíÊèèÁîªÔºàÂ£Å„ÇíÂê´„ÇÅ„Å¶Ôºâ
              for (let ry = y; ry < y + height; ry++) {
                for (let rx = x; rx < x + width; rx++) {
                  if (
                    ry >= 1 &&
                    ry < this.gridY - 1 &&
                    rx >= 1 &&
                    rx < this.gridX - 1
                  ) {
                    this.map[ry][rx] = 0;
                  }
                }
              }
            }
          }

          // 2. ÈÉ®Â±ãÂêåÂ£´„ÇíÈÄöË∑Ø„ÅßÁπã„ÅêÔºàMinimum Spanning TreeÈ¢®Ôºâ
          if (rooms.length > 1) {
            // ÂêÑÈÉ®Â±ã„ÅÆ‰∏≠ÂøÉÁÇπ„ÇíË®àÁÆó
            const centers = rooms.map((room) => ({
              x: Math.floor(room.x + room.width / 2),
              y: Math.floor(room.y + room.height / 2),
            }));

            // Ëøë„ÅÑÈÉ®Â±ãÂêåÂ£´„ÇíÁπã„ÅêÔºàÂÖ®„Éö„Ç¢„Åß„ÅØ„Å™„Åè„ÄÅËøë„ÅÑ„ÇÇ„ÅÆ„Å†„ÅëÔºâ
            for (let i = 0; i < centers.length - 1; i++) {
              // ÊúÄ„ÇÇËøë„ÅÑÈÉ®Â±ã„ÇíÊé¢„Åô
              let closestIdx = i + 1;
              let closestDist = Infinity;
              for (let j = i + 1; j < centers.length; j++) {
                const dist =
                  Math.abs(centers[i].x - centers[j].x) +
                  Math.abs(centers[i].y - centers[j].y);
                if (dist < closestDist) {
                  closestDist = dist;
                  closestIdx = j;
                }
              }

              // ÈÄöË∑Ø„Çí‰Ωú„ÇãÔºàÂπÖ1„Éû„Çπ„ÄÅLÂ≠óÂûãÔºâ
              this.createLShapedCorridor(
                centers[i].x,
                centers[i].y,
                centers[closestIdx].x,
                centers[closestIdx].y
              );
            }

            // ËøΩÂä†„ÅÆÈÄöË∑Ø„Çí„É©„É≥„ÉÄ„É†„Å´ËøΩÂä†ÔºàÂàÜÂ≤êÁÇπ„ÇíÂ¢ó„ÇÑ„Åô„ÄÅ‰∏ÄÈÉ®„ÅØÂπÖ2„Éû„ÇπÔºâ
            for (let i = 0; i < Math.floor(rooms.length / 3); i++) {
              const r1 = Math.floor(Math.random() * centers.length);
              const r2 = Math.floor(Math.random() * centers.length);
              if (r1 !== r2) {
                // 30%„ÅÆÁ¢∫Áéá„ÅßÂπÖ2„Éû„Çπ„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅØ1„Éû„Çπ
                if (Math.random() < 0.3) {
                  this.createCorridor(
                    centers[r1].x,
                    centers[r1].y,
                    centers[r2].x,
                    centers[r2].y,
                    1.5
                  );
                } else {
                  this.createLShapedCorridor(
                    centers[r1].x,
                    centers[r1].y,
                    centers[r2].x,
                    centers[r2].y
                  );
                }
              }
            }
          }

          // 3. „Çπ„Çø„Éº„ÉàÂú∞ÁÇπ„Å®„Ç¥„Éº„É´Âú∞ÁÇπ„ÇíË®≠ÂÆö
          this.startRoom = null; // „Çπ„Çø„Éº„ÉàÈÉ®Â±ã„Çí‰øùÂ≠òÔºàÊïµ„ÅÆ„Çπ„Éù„Éº„É≥„ÇíÈÅø„Åë„Çã„Åü„ÇÅÔºâ
          if (rooms.length > 0) {
            // „Çπ„Çø„Éº„ÉàÂú∞ÁÇπÔºàÊúÄÂàù„ÅÆÈÉ®Â±ãÔºâ
            const startRoom = rooms[0];
            this.startRoom = startRoom; // „Çπ„Çø„Éº„ÉàÈÉ®Â±ã„Çí‰øùÂ≠ò
            this.p = {
              x: Math.floor(startRoom.x + startRoom.width / 2),
              y: Math.floor(startRoom.y + startRoom.height / 2),
            };

            // „Ç¥„Éº„É´Âú∞ÁÇπÔºàÊúÄÂæå„ÅÆÈÉ®Â±ãÔºâ
            const endRoom = rooms[rooms.length - 1];
            const endX = Math.floor(endRoom.x + endRoom.width / 2);
            const endY = Math.floor(endRoom.y + endRoom.height / 2);
            this.map[endY][endX] = 2;
          } else {
            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºöÈÉ®Â±ã„ÅåÁîüÊàê„Åß„Åç„Å™„Åã„Å£„ÅüÂ†¥Âêà
            this.p = { x: 2, y: 2 };
            this.map[2][2] = 0;
            this.map[this.gridY - 3][this.gridX - 3] = 2;
            this.startRoom = { x: 1, y: 1, width: 3, height: 3 }; // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®
          }

          // 4. ÈÄöË∑Ø„ÅÆÊã°Âºµ„ÅØÁÑ°ÂäπÂåñÔºàËø∑Ë∑ØÊßãÈÄ†„Çí‰øù„Å§„Åü„ÇÅÔºâ
          // this.expandCorridors();

          // 5. „Éó„É¨„Ç§„É§„Éº‰ΩçÁΩÆ„ÅÆÁ¢∫Ë™çÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
          if (!this.p || this.map[this.p.y][this.p.x] !== 0) {
            // „Éó„É¨„Ç§„É§„Éº‰ΩçÁΩÆ„ÅåÁÑ°Âäπ„Å™Â†¥Âêà„ÄÅÊúÄÂàù„ÅÆÁ©∫„Åç„Éû„Çπ„ÇíÊé¢„Åô
            let found = false;
            for (let y = 1; y < this.gridY - 1 && !found; y++) {
              for (let x = 1; x < this.gridX - 1 && !found; x++) {
                if (this.map[y][x] === 0) {
                  this.p = { x, y };
                  found = true;
                }
              }
            }
            if (!found) {
              this.p = { x: 1, y: 1 };
              this.map[1][1] = 0;
            }
          }

          // 6. „Éó„É¨„Ç§„É§„Éº„Å®„Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£„ÅÆÂàùÊúüÂåñ
          game.player.stamina = 100;
          this.timeLeft = 180;
          this.entities = [];
          // Êïµ„ÅÆÊï∞„ÇíÊ∏õ„Çâ„ÅôÔºà8 + difficultyÔºâ
          for (let i = 0; i < 8 + difficulty; i++) this.spawnEntity("enemy");
          // „É´„Éº„Éà„Ç¢„Ç§„ÉÜ„É†„ÅÆÊï∞„ÇÇÂ∞ë„ÅóÊ∏õ„Çâ„Åô
          for (let i = 0; i < 12; i++) this.spawnEntity("loot");
          window.onkeydown = (e) => {
            if (game.state !== "EXPLORE") return;
            const k = e.key.toLowerCase();

            // E„Ç≠„Éº„ÅßË£ÖÂÇô„Éë„Éç„É´„ÇíÈñãÈñâ
            if (k === "e") {
              game.toggleExplorePanel();
              return;
            }

            // „Éë„Éç„É´„ÅåÈñã„ÅÑ„Å¶„ÅÑ„Çã„Å®„Åç„ÅØÁßªÂãï„ÇíÁÑ°ÂäπÂåñ
            const panel = document.getElementById("explore-panel");
            if (panel && panel.classList.contains("visible")) return;

            if (e.shiftKey) game.player.isStealth = true;
            let dx = 0,
              dy = 0;
            if (k === "w" || k === "arrowup") dy = -1;
            if (k === "s" || k === "arrowdown") dy = 1;
            if (k === "a" || k === "arrowleft") dx = -1;
            if (k === "d" || k === "arrowright") dx = 1;
            if (dx !== 0 || dy !== 0) this.movePlayer(dx, dy);
          };
          window.onkeyup = (e) => {
            if (e.key === "Shift") game.player.isStealth = false;
          };
        },
        // LÂ≠óÂûã„ÅÆÈÄöË∑Ø„Çí‰Ωú„ÇãÈñ¢Êï∞Ôºà„Çà„ÇäËø∑Ë∑Ø„Çâ„Åó„ÅèÔºâ
        createLShapedCorridor(x1, y1, x2, y2) {
          // „É©„É≥„ÉÄ„É†„Å´Ê®™‚ÜíÁ∏¶„Åæ„Åü„ÅØÁ∏¶‚ÜíÊ®™„ÇíÈÅ∏Êäû
          if (Math.random() < 0.5) {
            // Ê®™‚ÜíÁ∏¶: (x1,y1) ‚Üí (x2,y1) ‚Üí (x2,y2)
            const startX = Math.min(x1, x2);
            const endX = Math.max(x1, x2);
            for (let x = startX; x <= endX; x++) {
              if (
                x >= 1 &&
                x < this.gridX - 1 &&
                y1 >= 1 &&
                y1 < this.gridY - 1
              ) {
                this.map[y1][x] = 0;
              }
            }
            const startY = Math.min(y1, y2);
            const endY = Math.max(y1, y2);
            for (let y = startY; y <= endY; y++) {
              if (
                x2 >= 1 &&
                x2 < this.gridX - 1 &&
                y >= 1 &&
                y < this.gridY - 1
              ) {
                this.map[y][x2] = 0;
              }
            }
          } else {
            // Á∏¶‚ÜíÊ®™: (x1,y1) ‚Üí (x1,y2) ‚Üí (x2,y2)
            const startY = Math.min(y1, y2);
            const endY = Math.max(y1, y2);
            for (let y = startY; y <= endY; y++) {
              if (
                x1 >= 1 &&
                x1 < this.gridX - 1 &&
                y >= 1 &&
                y < this.gridY - 1
              ) {
                this.map[y][x1] = 0;
              }
            }
            const startX = Math.min(x1, x2);
            const endX = Math.max(x1, x2);
            for (let x = startX; x <= endX; x++) {
              if (
                x >= 1 &&
                x < this.gridX - 1 &&
                y2 >= 1 &&
                y2 < this.gridY - 1
              ) {
                this.map[y2][x] = 0;
              }
            }
          }
        },
        // ÈÄöË∑Ø„Çí‰Ωú„ÇãÈñ¢Êï∞ÔºàÂπÖÊåáÂÆöÂèØËÉΩ„ÄÅ‰∏ª„Å´ÂàÜÂ≤êÁÇπÁî®Ôºâ
        createCorridor(x1, y1, x2, y2, width = 1) {
          const dx = x2 - x1;
          const dy = y2 - y1;
          const steps = Math.max(Math.abs(dx), Math.abs(dy));

          for (let i = 0; i <= steps; i++) {
            const t = steps === 0 ? 0 : i / steps;
            const cx = Math.floor(x1 + dx * t);
            const cy = Math.floor(y1 + dy * t);

            // ÈÄöË∑Ø„ÅÆÂπÖÂàÜ„ÄÅÂë®Ëæ∫„ÇÇÈñã„Åë„ÇãÔºà1.5„ÅÆÂ†¥Âêà„ÅØ2„Éû„ÇπÂπÖÔºâ
            const halfWidth = width >= 1.5 ? 1 : 0;
            for (let wy = -halfWidth; wy <= halfWidth; wy++) {
              for (let wx = -halfWidth; wx <= halfWidth; wx++) {
                const nx = cx + wx;
                const ny = cy + wy;
                if (
                  nx >= 1 &&
                  nx < this.gridX - 1 &&
                  ny >= 1 &&
                  ny < this.gridY - 1
                ) {
                  this.map[ny][nx] = 0;
                }
              }
            }
          }
        },
        // ÈÄöË∑Ø„ÇíÂ∞ë„ÅóÊã°Âºµ„Åô„ÇãÔºà„Çà„ÇäÂ∫É„ÅÑÂç∞Ë±°„Å´„Åô„ÇãÔºâ
        expandCorridors() {
          // „Éû„ÉÉ„Éó„ÅÆ„Ç≥„Éî„Éº„Çí‰ΩúÊàê
          const expanded = [];
          for (let y = 0; y < this.gridY; y++) {
            expanded.push([]);
            for (let x = 0; x < this.gridX; x++) {
              expanded[y].push(this.map[y][x]);
            }
          }

          for (let y = 1; y < this.gridY - 1; y++) {
            for (let x = 1; x < this.gridX - 1; x++) {
              if (this.map[y][x] === 0) {
                // ÈÄöË∑Ø„ÅÆÂë®Ëæ∫„ÇíÂ∞ë„ÅóÈñã„Åë„ÇãÔºàÁ¢∫ÁéáÁöÑ„Å´Ôºâ
                if (Math.random() < 0.3) {
                  const dirs = [
                    [0, 1],
                    [0, -1],
                    [1, 0],
                    [-1, 0],
                  ];
                  for (const [dx, dy] of dirs) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (
                      nx >= 1 &&
                      nx < this.gridX - 1 &&
                      ny >= 1 &&
                      ny < this.gridY - 1
                    ) {
                      if (this.map[ny][nx] === 1 && Math.random() < 0.4) {
                        expanded[ny][nx] = 0;
                      }
                    }
                  }
                }
              }
            }
          }

          // Êã°Âºµ„Åó„Åü„Éû„ÉÉ„Éó„ÇíÈÅ©Áî®
          for (let y = 1; y < this.gridY - 1; y++) {
            for (let x = 1; x < this.gridX - 1; x++) {
              this.map[y][x] = expanded[y][x];
            }
          }
        },
        spawnEntity(type) {
          let x, y;
          let attempts = 0;
          let isValid = false;
          do {
            x = Math.floor(Math.random() * (this.gridX - 2)) + 1;
            y = Math.floor(Math.random() * (this.gridY - 2)) + 1;
            attempts++;
            if (attempts > 1000) {
              // 1000ÂõûË©¶Ë°å„Åó„Å¶„ÇÇË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
              console.warn(`Could not spawn ${type} after 1000 attempts`);
              return;
            }

            // „ÉÅ„Çß„ÉÉ„ÇØÊù°‰ª∂
            const isWalkable = this.map[y][x] === 0;
            const isPlayerPos = x === this.p.x && y === this.p.y;

            // „Çπ„Çø„Éº„ÉàÈÉ®Â±ãÂÜÖ„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºà„Éû„Éº„Ç∏„É≥‰ªò„ÅçÔºâ
            let isInStartRoom = false;
            if (this.startRoom) {
              const margin = 2; // Âë®Ëæ∫2„Éû„Çπ„ÇÇÂÆâÂÖ®Âú∞Â∏Ø
              isInStartRoom =
                x >= this.startRoom.x - margin &&
                x < this.startRoom.x + this.startRoom.width + margin &&
                y >= this.startRoom.y - margin &&
                y < this.startRoom.y + this.startRoom.height + margin;
            }

            // „Éó„É¨„Ç§„É§„Éº„Åã„Çâ‰∏ÄÂÆöË∑ùÈõ¢‰ª•ÂÜÖ„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÊïµ„ÅÆ„ÅøÔºâ
            const distFromPlayer =
              Math.abs(x - this.p.x) + Math.abs(y - this.p.y);
            const tooCloseToPlayer = type === "enemy" && distFromPlayer < 8; // 8„Éû„Çπ‰ª•ÂÜÖ„ÅØÊïµ„ÇíÈÖçÁΩÆ„Åó„Å™„ÅÑ

            isValid =
              isWalkable && !isPlayerPos && !isInStartRoom && !tooCloseToPlayer;
          } while (!isValid);
          let visionRange = 4;
          let armorNoise = ARMORS[game.player.loadout.armor].noise;
          if (type === "enemy") visionRange = 4 + armorNoise;
          this.entities.push({
            x,
            y,
            type,
            active: true,
            facing: Math.floor(Math.random() * 4),
            aggro: false,
            vision: visionRange,
            lastSeenPlayer: null,
            aggroTimer: 0,
          });
        },
        start() {
          this.lastTime = Date.now();
          if (this.timer) clearInterval(this.timer);
          this.timer = setInterval(() => this.loop(), 50);
        },
        stop() {
          if (this.timer) clearInterval(this.timer);
        },
        loop() {
          if (game.state !== "EXPLORE") return;
          const now = Date.now();
          const dt = (now - this.lastTime) / 1000;
          this.lastTime = now;
          this.timeLeft -= dt;
          if (this.timeLeft <= 0) {
            this.timeLeft = 0;
            game.returnToBase(false);
            return;
          }
          this.enemyMoveTimer += dt;
          if (this.enemyMoveTimer >= 0.65) {
            this.updateEnemies();
            this.enemyMoveTimer = 0;
          }
          if (!game.player.isStealth && game.player.stamina < 100)
            game.player.stamina += 0.5;
          this.draw();
          this.updateUI();
        },
        movePlayer(dx, dy) {
          let cost = 0;
          if (game.player.isStealth) {
            const currentArmor = ARMORS[game.player.loadout.armor];
            const currentWeapon = WEAPONS[game.player.loadout.weapon];
            cost = 1 + currentArmor.noise + currentWeapon.noise;
            if (game.player.stamina < cost) {
              game.player.isStealth = false;
              cost = 0;
            } else {
              game.player.stamina -= cost;
            }
          }
          const nx = this.p.x + dx;
          const ny = this.p.y + dy;
          if (this.map[ny][nx] === 1) return;
          if (this.map[ny][nx] === 2) {
            game.returnToBase(true);
            return;
          }
          const hit = this.entities.find(
            (e) => e.x === nx && e.y === ny && e.active
          );
          if (hit) {
            if (hit.type === "enemy") {
              let pDir = -1;
              if (dy === -1) pDir = 0;
              if (dx === 1) pDir = 1;
              if (dy === 1) pDir = 2;
              if (dx === -1) pDir = 3;
              const isFrontal = Math.abs(pDir - hit.facing) === 2;
              let isAmbush = game.player.isStealth && !isFrontal;
              game.enterBattle(hit, isAmbush);
              return;
            } else if (hit.type === "loot") {
              hit.active = false;
              // ÊâÄÊåÅÂìÅÊï∞„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
              if (game.getInventoryCount() >= game.MAX_INVENTORY_SIZE) {
                game.log("Inventory full! Cannot pick up Scrap.");
                return;
              }
              game.player.mats.scrap++;
              game.log("Found Scrap!");
            }
          }
          this.p.x = nx;
          this.p.y = ny;
          if (!game.player.isStealth) {
            this.entities.forEach((e) => {
              if (e.type === "enemy" && e.active && !e.aggro) {
                const dist = Math.abs(e.x - nx) + Math.abs(e.y - ny);
                if (dist <= 4) {
                  e.aggro = true;
                  if (Math.abs(e.x - nx) > Math.abs(e.y - ny))
                    e.facing = e.x > nx ? 3 : 1;
                  else e.facing = e.y > ny ? 0 : 2;
                }
              }
            });
          }
        },
        // „Éó„É¨„Ç§„É§„Éº„Åæ„Åß„ÅÆË∑ùÈõ¢„ÇíË®àÁÆóÔºà„Éû„É≥„Éè„ÉÉ„Çø„É≥Ë∑ùÈõ¢Ôºâ
        getDistance(x1, y1, x2, y2) {
          return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        },
        // ÂπÖÂÑ™ÂÖàÊé¢Á¥¢ÔºàBFSÔºâ„Åß„Çø„Éº„Ç≤„ÉÉ„Éà„Åæ„Åß„ÅÆ„Éë„Çπ„ÇíË®àÁÆóÔºàÊúÄÂ§ßÊ∑±Â∫¶Âà∂Èôê‰ªò„ÅçÔºâ
        findPath(startX, startY, targetX, targetY, maxDepth = 25) {
          const queue = [[startX, startY, []]];
          const visited = new Set();
          visited.add(`${startX},${startY}`);
          const directions = [
            [0, -1],
            [1, 0],
            [0, 1],
            [-1, 0],
          ];

          while (queue.length > 0) {
            const [x, y, path] = queue.shift();

            // ÊúÄÂ§ßÊ∑±Â∫¶„ÉÅ„Çß„ÉÉ„ÇØ
            if (path.length >= maxDepth) continue;

            // „Çø„Éº„Ç≤„ÉÉ„Éà„Å´Âà∞ÈÅî
            if (x === targetX && y === targetY) {
              return path;
            }

            // 4ÊñπÂêë„ÇíÊé¢Á¥¢
            for (const [dx, dy] of directions) {
              const nx = x + dx;
              const ny = y + dy;
              const key = `${nx},${ny}`;

              if (!visited.has(key) && this.isWalkable(nx, ny)) {
                visited.add(key);
                queue.push([nx, ny, [...path, [dx, dy]]]);
              }
            }
          }

          // „Éë„Çπ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÄÅnull„ÇíËøî„Åô
          return null;
        },
        // ÊúÄËâØ„ÅÆÁßªÂãïÊñπÂêë„ÇíÈÅ∏ÊäûÔºà„Éë„Çπ„Éï„Ç°„Ç§„É≥„Éá„Ç£„É≥„Ç∞„Çí‰ΩøÁî®Ôºâ
        findBestMove(e, targetX, targetY) {
          const directions = [
            [0, -1, 0], // ‰∏ä
            [1, 0, 1], // Âè≥
            [0, 1, 2], // ‰∏ã
            [-1, 0, 3], // Â∑¶
          ];

          // „Éë„Çπ„Éï„Ç°„Ç§„É≥„Éá„Ç£„É≥„Ç∞„ÅßÊúÄÁü≠ÁµåË∑Ø„ÇíÊé¢„Åô
          const path = this.findPath(e.x, e.y, targetX, targetY);

          if (path && path.length > 0) {
            // „Éë„Çπ„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÄÅÊúÄÂàù„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„ÇíÂÆüË°å
            const [dx, dy] = path[0];
            const facing = directions.findIndex(
              (d) => d[0] === dx && d[1] === dy
            );
            const nx = e.x + dx;
            const ny = e.y + dy;

            if (this.isWalkable(nx, ny)) {
              return {
                x: nx,
                y: ny,
                facing: facing >= 0 ? facing : e.facing,
                dx: dx,
                dy: dy,
              };
            }
          }

          // „Éë„Çπ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÄÅÁõ¥Êé•Ë∑ùÈõ¢„ÅßÊúÄËâØ„ÅÆÊñπÂêë„ÇíÈÅ∏„Å∂Ôºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
          let bestMove = null;
          let bestDistance = Infinity;
          const currentDist = this.getDistance(e.x, e.y, targetX, targetY);

          // ÂêÑÊñπÂêë„ÇíË©ï‰æ°Ôºà2„Çπ„ÉÜ„ÉÉ„ÉóÂÖà„ÇÇËÄÉÊÖÆÔºâ
          for (const [dx, dy, facing] of directions) {
            const nx = e.x + dx;
            const ny = e.y + dy;

            if (this.isWalkable(nx, ny)) {
              const newDist = this.getDistance(nx, ny, targetX, targetY);

              // „Åï„Çâ„Å´2„Çπ„ÉÜ„ÉÉ„ÉóÂÖà„ÇíË¶ã„Å¶„ÄÅÁßªÂãïÂèØËÉΩ„Å™ÁµåË∑Ø„Åå„ÅÇ„Çã„ÅãÁ¢∫Ë™ç
              let hasPathAhead = false;
              for (const [dx2, dy2] of directions) {
                const nx2 = nx + dx2;
                const ny2 = ny + dy2;
                if (this.isWalkable(nx2, ny2)) {
                  hasPathAhead = true;
                  break;
                }
              }

              // „Çà„ÇäËøë„Å•„Åë„ÇãÊñπÂêë„ÄÅ„Åæ„Åü„ÅØË°å„ÅçË©∞„Åæ„Çä„Åß„Å™„ÅÑÊñπÂêë„ÇíÂÑ™ÂÖà
              const score = newDist - (hasPathAhead ? 0.5 : -10);
              if (score < bestDistance) {
                bestDistance = score;
                bestMove = { x: nx, y: ny, facing: facing, dx: dx, dy: dy };
              }
            }
          }

          // „Å©„ÅÆÊñπÂêë„ÇÇÁßªÂãï„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÄÅÁèæÂú®‰ΩçÁΩÆ„ÇíÁ∂≠ÊåÅ
          if (!bestMove) {
            return { x: e.x, y: e.y, facing: e.facing, dx: 0, dy: 0 };
          }

          return bestMove;
        },
        updateEnemies() {
          this.entities.forEach((e) => {
            if (e.type !== "enemy" || !e.active) return;
            const dx = this.p.x - e.x;
            const dy = this.p.y - e.y;
            const dist = Math.abs(dx) + Math.abs(dy);

            // Ë¶ñÁïåÂà§ÂÆöÔºà„Çà„ÇäÂ∫É„ÅÑË¶ñÈáéËßíÔºâ
            let inSight = false;
            if (dist <= e.vision) {
              // Ë¶ñÈáéËßí„ÇíÂ∫É„Åí„ÇãÔºàÂ∑¶Âè≥90Â∫¶Ôºâ
              if (e.facing === 0 && dy < 0 && Math.abs(dx) <= Math.abs(dy) * 2)
                inSight = true;
              if (e.facing === 1 && dx > 0 && Math.abs(dy) <= Math.abs(dx) * 2)
                inSight = true;
              if (e.facing === 2 && dy > 0 && Math.abs(dx) <= Math.abs(dy) * 2)
                inSight = true;
              if (e.facing === 3 && dx < 0 && Math.abs(dy) <= Math.abs(dx) * 2)
                inSight = true;
            }

            // „Éó„É¨„Ç§„É§„Éº„ÅåË¶ñÁïåÂÜÖ„Åß„Çπ„ÉÜ„É´„ÇπÁä∂ÊÖã„Åß„Å™„ÅÑÂ†¥Âêà„ÄÅaggroÁä∂ÊÖã„Å´„Åô„Çã
            if (inSight && !game.player.isStealth) {
              e.aggro = true;
              e.lastSeenPlayer = { x: this.p.x, y: this.p.y };
              e.aggroTimer = 30; // 30„Çø„Éº„É≥ËøΩË∑°„ÇíÁ∂ôÁ∂ö
            }

            // ‰∏ÄÂÆöË∑ùÈõ¢‰ª•ÂÜÖ„Å™„ÇâËøΩË∑°„ÇíÁ∂ôÁ∂öÔºàË¶ñÁïåÂ§ñ„Åß„ÇÇÔºâ
            if (e.aggro && dist <= e.vision * 4 && !game.player.isStealth) {
              e.lastSeenPlayer = { x: this.p.x, y: this.p.y };
              e.aggroTimer = Math.max(e.aggroTimer, 15);
            }

            // aggroÁä∂ÊÖã„ÅÆÂá¶ÁêÜ
            if (e.aggro) {
              // „Çø„Ç§„Éû„Éº„ÇíÊ∏õ„Çâ„ÅôÔºà„Éó„É¨„Ç§„É§„Éº„ÇíË¶ãÂ§±„Å£„ÅüÂ†¥Âêà„ÅÆËøΩË∑°ÊôÇÈñìÔºâ
              if (e.aggroTimer) e.aggroTimer--;

              // ÁèæÂú®„Éó„É¨„Ç§„É§„Éº„ÅåË¶ã„Åà„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºà„Çπ„ÉÜ„É´„Çπ„Åß„Å™„Åè„ÄÅË¶ñÁïåÂÜÖÔºâ
              const currentlyVisible =
                !game.player.isStealth && dist <= e.vision && inSight;

              // „Çø„Éº„Ç≤„ÉÉ„Éà‰ΩçÁΩÆ„ÇíÊ±∫ÂÆö
              let targetX = this.p.x;
              let targetY = this.p.y;

              if (currentlyVisible) {
                // „Éó„É¨„Ç§„É§„Éº„ÅåË¶ã„Åà„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÁõ¥Êé•ËøΩË∑°
                e.lastSeenPlayer = { x: this.p.x, y: this.p.y };
                e.aggroTimer = Math.max(e.aggroTimer, 30);
                targetX = this.p.x;
                targetY = this.p.y;
              } else if (e.lastSeenPlayer) {
                // „Éó„É¨„Ç§„É§„Éº„ÅåË¶ã„Åà„Å™„ÅÑÂ†¥Âêà
                const distToLastSeen = this.getDistance(
                  e.x,
                  e.y,
                  e.lastSeenPlayer.x,
                  e.lastSeenPlayer.y
                );

                // ÊúÄÂæå„Å´Ë¶ã„Åü‰ΩçÁΩÆ„Å´Âà∞ÈÅî„Åó„Å¶„ÅÑ„Çã„ÄÅ„Åæ„Åü„ÅØ„Éó„É¨„Ç§„É§„Éº„ÅåËøë„ÅÑÂ†¥Âêà„ÅØ„Éó„É¨„Ç§„É§„Éº„ÇíÁõ¥Êé•ËøΩË∑°
                if (distToLastSeen <= 2 || dist <= e.vision * 3) {
                  // „Éó„É¨„Ç§„É§„Éº„Å∏„ÅÆ„Éë„Çπ„Åå„ÅÇ„Çã„ÅãË©¶„Åô
                  const pathToPlayer = this.findPath(
                    e.x,
                    e.y,
                    this.p.x,
                    this.p.y,
                    20
                  );
                  if (pathToPlayer && pathToPlayer.length > 0) {
                    targetX = this.p.x;
                    targetY = this.p.y;
                    e.lastSeenPlayer = { x: this.p.x, y: this.p.y };
                  } else {
                    // „Éë„Çπ„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÊúÄÂæå„Å´Ë¶ã„Åü‰ΩçÁΩÆ„Å∏
                    targetX = e.lastSeenPlayer.x;
                    targetY = e.lastSeenPlayer.y;
                  }
                } else {
                  // „Åæ„Å†ÊúÄÂæå„Å´Ë¶ã„Åü‰ΩçÁΩÆ„Å´Âà∞ÈÅî„Åó„Å¶„ÅÑ„Å™„ÅÑ
                  targetX = e.lastSeenPlayer.x;
                  targetY = e.lastSeenPlayer.y;
                }
              }

              // ÊúÄËâØ„ÅÆÁßªÂãïÊñπÂêë„ÇíÈÅ∏ÊäûÔºà„Éë„Çπ„Éï„Ç°„Ç§„É≥„Éá„Ç£„É≥„Ç∞‰ΩøÁî®Ôºâ
              const bestMove = this.findBestMove(e, targetX, targetY);

              // ÁßªÂãï„ÅåÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅÆ„Åø‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
              if (bestMove.x !== e.x || bestMove.y !== e.y) {
                e.x = bestMove.x;
                e.y = bestMove.y;
                e.facing = bestMove.facing;
              }

              // „Éó„É¨„Ç§„É§„Éº„Å®Âêå„Åò‰ΩçÁΩÆ„Å´„Å™„Å£„Åü„ÇâÊà¶ÈóòÈñãÂßã
              if (e.x === this.p.x && e.y === this.p.y) {
                game.enterBattle(e, false);
              }

              // „Çø„Ç§„Éû„ÉºÂàá„Çå„ÅßËøΩË∑°„Çí„ÇÑ„ÇÅ„ÇãÔºàË∑ùÈõ¢„ÅåÈÅ†„Åô„Åé„ÇãÂ†¥Âêà„ÅÆ„ÅøÔºâ
              if (e.aggroTimer <= 0 && dist > e.vision * 5) {
                e.aggro = false;
                e.lastSeenPlayer = null;
              }
            } else {
              // aggro„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆÈÄöÂ∏∏Ë°åÂãï
              if (Math.random() < 0.3) {
                const dirs = [
                  [0, -1, 0],
                  [1, 0, 1],
                  [0, 1, 2],
                  [-1, 0, 3],
                ];
                const dIdx = Math.floor(Math.random() * 4);
                const d = dirs[dIdx];
                const nx = e.x + d[0];
                const ny = e.y + d[1];
                e.facing = d[2];
                if (this.isWalkable(nx, ny)) {
                  e.x = nx;
                  e.y = ny;
                }
              }
            }
          });
        },
        isWalkable(x, y) {
          if (y < 0 || y >= this.gridY || x < 0 || x >= this.gridX)
            return false;
          if (this.map[y][x] === 1) return false;
          if (
            this.entities.some(
              (e) => e.active && e.x === x && e.y === y && e.type !== "loot"
            )
          )
            return false;
          return true;
        },
        draw() {
          const ctx = this.ctx;
          const ts = this.tile;
          const cw = this.canvas.width;
          const ch = this.canvas.height;
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, cw, ch);
          const offsetX = Math.floor(cw / 2 / ts) - this.p.x;
          const offsetY = Math.floor(ch / 2 / ts) - this.p.y;
          for (let y = 0; y < this.gridY; y++) {
            for (let x = 0; x < this.gridX; x++) {
              const drawX = (x + offsetX) * ts;
              const drawY = (y + offsetY) * ts;
              if (drawX < -ts || drawX > cw || drawY < -ts || drawY > ch)
                continue;
              const dist = Math.sqrt((x - this.p.x) ** 2 + (y - this.p.y) ** 2);
              if (dist < 10) {
                if (this.map[y][x] === 1) {
                  ctx.fillStyle = "#444";
                  ctx.fillRect(drawX, drawY, ts, ts);
                } else if (this.map[y][x] === 2) {
                  ctx.fillStyle = "#0f0";
                  ctx.fillRect(drawX, drawY, ts, ts);
                } else {
                  ctx.fillStyle = "#222";
                  ctx.fillRect(drawX, drawY, ts - 1, ts - 1);
                }
              }
            }
          }
          this.entities.forEach((e) => {
            if (!e.active) return;
            const dist = Math.sqrt(
              (e.x - this.p.x) ** 2 + (e.y - this.p.y) ** 2
            );
            if (dist < 10) {
              const drawX = (e.x + offsetX) * ts;
              const drawY = (e.y + offsetY) * ts;
              if (e.type === "enemy") {
                ctx.fillStyle = e.aggro ? "#f00" : "#d44";
                ctx.fillRect(drawX + 2, drawY + 2, ts - 4, ts - 4);
                ctx.fillStyle = "rgba(255, 0, 0, 0.2)";
                ctx.beginPath();
                ctx.moveTo(drawX + ts / 2, drawY + ts / 2);
                let startAng = 0;
                if (e.facing === 0) startAng = 1.5 * Math.PI;
                if (e.facing === 1) startAng = 0;
                if (e.facing === 2) startAng = 0.5 * Math.PI;
                if (e.facing === 3) startAng = Math.PI;
                ctx.arc(
                  drawX + ts / 2,
                  drawY + ts / 2,
                  6 * ts,
                  startAng - 0.5,
                  startAng + 0.5
                );
                ctx.lineTo(drawX + ts / 2, drawY + ts / 2);
                ctx.fill();
              } else {
                ctx.fillStyle = "#ff0";
                ctx.beginPath();
                ctx.arc(drawX + ts / 2, drawY + ts / 2, 3, 0, 6.28);
                ctx.fill();
              }
            }
          });
          const pDrawX = Math.floor(cw / 2 - ts / 2);
          const pDrawY = Math.floor(ch / 2 - ts / 2);
          ctx.fillStyle = game.player.isStealth ? "#00f" : "#0ff";
          ctx.beginPath();
          ctx.arc(pDrawX + ts / 2, pDrawY + ts / 2, 5, 0, 6.28);
          ctx.fill();
        },
        updateUI() {
          document.getElementById("exp-hp").innerText = game.player.hp;
          document.getElementById("exp-st").innerText = Math.floor(
            game.player.stamina
          );
          document.getElementById("exp-time").innerText = Math.floor(
            this.timeLeft
          );
          const stInd = document.getElementById("stealth-indicator");
          if (game.player.isStealth) stInd.className = "active";
          else stInd.className = "";
        },
      };

      /* --- 4. BATTLE LOGIC --- */
      /* --- 4. AIS-FLUX BATTLE LOGIC --- */
      const battle = {
        state: "INIT", // AIS_PHASE, CHAIN_PHASE, RESOLVE
        enemy: null,
        slots: [], // Deck/Hand„ÅÆ‰ª£„Çè„Çä„ÄÇ10ÂÄã„ÅÆ„Ç≥„Éû„É≥„Éâ

        flux: 0,
        maxFlux: 100,
        chainTimer: 0,

        // AISÈñ¢ÈÄ£
        aiPersonality: null,
        enemyIntent: null,
        intentProb: {}, // Á¢∫ÁéáÂàÜÂ∏É { ATTACK: 60, ... }

        start(dungeonEnemy, isAmbush) {
          this.isBossBattle = !!(dungeonEnemy === null && battle.isBossBattle); // „Éï„É©„Ç∞Âºï„ÅçÁ∂ô„Åé

          // ÊïµÁîüÊàê
          this.enemy = {
            hp: this.isBossBattle ? 300 : 100,
            maxHp: this.isBossBattle ? 300 : 100,
            pos: 50,
            maxPos: 50,
            isBroken: false,
            status: { mark: 0 },
            name: this.isBossBattle ? "BOSS" : "Enemy",
          };

          // AIÊÄßÊ†º„ÅÆÊ±∫ÂÆö
          const types = Object.keys(AI_PERSONALITIES);
          const pKey = types[Math.floor(Math.random() * types.length)];
          this.aiPersonality = AI_PERSONALITIES[pKey];
          game.log(
            `Encounter: ${this.enemy.name} (${this.aiPersonality.name})`
          );

          // „Éó„É¨„Ç§„É§„ÉºÁä∂ÊÖã„É™„Çª„ÉÉ„Éà
          this.flux = 0;
          game.player.playerBlock = 0;
          game.player.ep = game.player.maxEp; // Êà¶ÈóòÈñãÂßãÊôÇEPÂÖ®Âø´

          // „Ç≥„Éû„É≥„Éâ„Çπ„É≠„ÉÉ„ÉàÊßãÁØâ (WAACD)
          this.buildSlots();

          if (isAmbush) {
            this.enemy.hp -= 20;
            game.log("Ambush success! Enemy took 20 damage.");
          }

          this.startAISPhase();
        },

        buildSlots() {
          const l = game.player.loadout;
          const wCmds = WEAPONS[l.weapon].slots;
          const aCmds = ARMORS[l.armor].slots;
          const gCmds = GADGETS[l.gadget].slots;

          // 10„Çπ„É≠„ÉÉ„Éà„Å´ÈÖçÁΩÆ (Ê≠¶Âô®5, Èò≤ÂÖ∑3, „Ç¨„Ç∏„Çß„ÉÉ„Éà2)
          this.slots = [];
          const addSlot = (cmdId, source) => {
            this.slots.push({
              id: cmdId,
              source: source, // 'weapon', 'armor', 'gadget'
              data: COMMANDS[cmdId],
              active: true,
            });
          };
          wCmds.slice(0, 5).forEach((c) => addSlot(c, "weapon"));
          aCmds.slice(0, 3).forEach((c) => addSlot(c, "armor"));
          gCmds.slice(0, 2).forEach((c) => addSlot(c, "gadget"));
        },

        // --- PHASE 1: AIS (Ë™≠„ÅøÂêà„ÅÑ) ---
        startAISPhase() {
          this.state = "AIS_PHASE";
          this.calculateIntent();
          this.updateUI();
          game.log("--- AIS PHASE: Êïµ„ÅÆË°åÂãï„ÇíË™≠„ÇÅ ---");
        },

        calculateIntent() {
          // ÊÄßÊ†º„Å´Âü∫„Å•„ÅçÁ¢∫Áéá„ÇíË®àÁÆó
          // „Åì„Åì„Å´HPÊ∏õÂ∞ë„ÇÑ„Éó„É¨„Ç§„É§„ÉºË°åÂãï„Å´„Çà„ÇãË£úÊ≠£„ÇíÂÖ•„Çå„Çã„Å®„Åï„Çâ„Å´ËâØ„ÅÑ
          this.intentProb = { ...this.aiPersonality.weights };

          // ÂÆüÈöõ„ÅÆË°åÂãï„ÇíÊ±∫ÂÆö („Éó„É¨„Ç§„É§„Éº„Å´„ÅØÈö†„Åô)
          const rand = Math.random() * 100;
          let cum = 0;
          if ((cum += this.intentProb.ATTACK) > rand)
            this.enemyIntent = "ATTACK";
          else if ((cum += this.intentProb.DEFEND) > rand)
            this.enemyIntent = "DEFEND";
          else this.enemyIntent = "SKILL";
        },

        // „Éó„É¨„Ç§„É§„Éº„Åå„Ç™„Éº„Éó„Éä„Éº(ÂßãÂãïÊäÄ)„ÇíÈÅ∏„Çì„Å†ÊôÇ„ÅÆÂá¶ÁêÜ
        selectOpener(slotIndex) {
          if (this.state !== "AIS_PHASE") return;
          const slot = this.slots[slotIndex];

          // ËÄê‰πÖÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ
          if (game.player.durability[slot.source] <= 0) {
            game.log("„Åù„ÅÆË£ÖÂÇô„ÅØÂ£ä„Çå„Å¶„ÅÑ„ÇãÔºÅ");
            return;
          }

          // ‰∏â„Åô„Åè„ÅøÂà§ÂÆö (RPS Logic)
          const pType = slot.data.type; // ATTACK, DEFEND, SKILL
          const eType = this.enemyIntent;

          let result = "DRAW";
          if (pType === "ATTACK" && eType === "DEFEND") result = "WIN"; // Â¥©„Åó
          else if (pType === "DEFEND" && eType === "SKILL")
            result = "WIN"; // Âºæ„Åç
          else if (pType === "SKILL" && eType === "ATTACK")
            result = "WIN"; // „ÅÑ„Å™„Åó
          else if (pType === eType) result = "DRAW";
          else result = "LOSE";

          game.log(`Player: ${pType} vs Enemy: ${eType} -> ${result}`);

          if (result === "WIN" || result === "DRAW") {
            // Ë™≠„ÅøÂãù„Å°/Âºï„ÅçÂàÜ„Åë -> „ÉÅ„Çß„Éº„É≥„Éï„Çß„Éº„Ç∫„Å∏
            // ÂßãÂãïÊäÄ„ÅÆÂäπÊûú„ÇíÈÅ©Áî®
            this.executeCommand(slot, true);
            this.startChainPhase(slot);
          } else {
            // Ë™≠„ÅøË≤†„Åë -> ‰∏ÄÊñπÁöÑ„Å´„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Çã
            this.takeEnemyAction(true); // true = Counter bonus
            this.endTurn();
          }
        },

        // --- PHASE 2: FOCUS CHAIN (ÂÆüË°å) ---
        startChainPhase(openerSlot) {
          this.state = "CHAIN_PHASE";
          this.lastChainTag = openerSlot.data.tags[0]; // ÈÄ£Êê∫Áî®„Çø„Ç∞
          game.log(">>> FOCUS CHAIN START! <<<");
          this.updateUI();
        },

        // „ÉÅ„Çß„Éº„É≥‰∏≠„ÅÆ„Ç≥„Éû„É≥„ÉâÂÆüË°å
        clickCommand(slotIndex) {
          if (this.state !== "CHAIN_PHASE") {
            // AIS„Éï„Çß„Éº„Ç∫„Å™„Çâ„Ç™„Éº„Éó„Éä„Éº„Å®„Åó„Å¶Âá¶ÁêÜ
            if (this.state === "AIS_PHASE") this.selectOpener(slotIndex);
            return;
          }

          const slot = this.slots[slotIndex];
          const cmd = slot.data;

          // 1. ÊéíÁÜ± (Vent) „ÅØ„ÅÑ„Å§„Åß„ÇÇÂèØËÉΩ
          if (cmd.tags.includes("VENT")) {
            if (game.player.ep >= cmd.cost) {
              game.player.ep -= cmd.cost;
              this.flux = Math.max(0, this.flux + cmd.flux); // flux„ÅØ„Éû„Ç§„Éä„ÇπÂÄ§Ë®≠ÂÆö
              game.log(`VENTING! Flux: ${this.flux}`);
              this.updateUI();
            } else {
              game.log("EP‰∏çË∂≥ÔºÅ");
            }
            return;
          }

          // 2. ÈÄ£Êê∫„ÉÅ„Çß„ÉÉ„ÇØ (Á∞°ÊòìÁâà: ÊîªÊíÉ‚ÜíÊîªÊíÉ„Å™„Å©„ÅåÁπã„Åå„Çã„Åã)
          // ‰ªäÂõû„ÅØ„ÄåFlux„Åå100Êú™Ê∫Ä„Å™„Çâ‰Ωï„Åß„ÇÇÁπã„Åå„Çã„Äç+„ÄåOverload„É™„Çπ„ÇØ„Äç„Å®„Åô„Çã

          // ËÄê‰πÖÊ∂àË≤ª
          if (game.player.durability[slot.source] > 0) {
            game.player.durability[slot.source] -= cmd.dur;
          } else {
            game.log("Ë£ÖÂÇôÁ†¥ÊêçÔºÅ");
            return;
          }

          // ÂÆüË°å
          this.executeCommand(slot, false);

          // Flux‰∏äÊòá
          this.flux += cmd.flux;

          // OverloadÂà§ÂÆö
          if (this.flux >= this.maxFlux) {
            game.log("‚ö†Ô∏è OVERLOAD!! ‚ö†Ô∏è");
            game.player.playerBlock = 0; // „Éö„Éä„É´„ÉÜ„Ç£
            this.takeEnemyAction(false); // Êïµ„ÅÆË°åÂãï„ÇÇÂèó„Åë„Çã
            this.endTurn();
            return;
          }

          this.updateUI();
        },

        executeCommand(slot, isOpener) {
          const cmd = slot.data;
          let val = cmd.val;

          if (cmd.type === "ATTACK") {
            // „ÉÄ„É°„Éº„Ç∏Ë®àÁÆó
            if (this.enemy.isBroken) val *= 2;
            this.enemy.hp -= val;
            // ÂßøÂã¢Ââä„Çä
            if (cmd.pos) this.enemy.pos -= cmd.pos;
            game.log(`Hit: ${cmd.name} (${val} dmg)`);
          } else if (cmd.type === "DEFEND") {
            game.player.playerBlock += val;
            game.log(`Block: ${val}`);
          } else if (cmd.type === "SKILL") {
            // ÁâπÊÆäÂäπÊûú
            if (cmd.name === "ÈõÜ‰∏≠") game.player.ep += 1;
          }

          // BreakÂà§ÂÆö
          if (this.enemy.pos <= 0 && !this.enemy.isBroken) {
            this.enemy.isBroken = true;
            this.enemy.brokenTurns = 1;
            game.log("ENEMY BREAK! (Chance!)");
          }
        },

        endChain() {
          game.log("Chain Finished.");
          // Êïµ„ÅåÁîü„Åç„Å¶„ÅÑ„Çå„Å∞ÂèçÊíÉ„ÇíÂèó„Åë„ÇãÔºàBreak‰∏≠„Å™„Çâ„Çπ„Ç≠„ÉÉ„ÉóÔºâ
          if (!this.enemy.isBroken) {
            this.takeEnemyAction(false);
          }
          this.endTurn();
        },

        // Êïµ„ÅÆ„Çø„Éº„É≥Âá¶ÁêÜ
        takeEnemyAction(isCounter) {
          if (this.enemy.hp <= 0) return;

          let dmg = 10; // Âü∫Êú¨„ÉÄ„É°„Éº„Ç∏
          if (this.enemyIntent === "ATTACK") dmg = 15;
          if (isCounter) dmg *= 1.5;

          if (this.enemyIntent !== "DEFEND") {
            // Èò≤Âæ°‰ª•Â§ñ„Å™„ÇâÊîªÊíÉ„Åó„Å¶„Åè„Çã
            let blocked = Math.min(game.player.playerBlock, dmg);
            let take = Math.floor(dmg - blocked);
            game.player.hp -= take;
            game.log(`Enemy acts! Took ${take} dmg.`);
          } else {
            game.log("Enemy defends.");
            this.enemy.pos = Math.min(this.enemy.maxPos, this.enemy.pos + 10);
          }
        },

        endTurn() {
          if (this.enemy.hp <= 0) {
            this.winBattle();
            return;
          }
          if (game.player.hp <= 0) {
            game.returnToBase(false);
            return;
          }

          // „Çø„Éº„É≥ÁµåÈÅéÂá¶ÁêÜ
          if (this.enemy.isBroken) {
            this.enemy.brokenTurns--;
            if (this.enemy.brokenTurns <= 0) this.enemy.isBroken = false;
          }

          // FluxËá™ÁÑ∂Ê∏õË°∞
          this.flux = Math.max(0, this.flux - 20);

          // EPÂõûÂæ©
          game.player.ep = Math.min(game.player.maxEp, game.player.ep + 2);

          this.startAISPhase();
        },

        winBattle() {
          game.showResult(true, 0); // „Çø„Éº„É≥Êï∞„ÅØÁ∞°ÊòìÁöÑ„Å´0
          // Â†±ÈÖ¨Âá¶ÁêÜ„Å™„Å©„ÅØ„Åì„Åì„Åß
        },

        updateUI() {
          if (!this.enemy) return;

          // Player Status
          document.getElementById("p-hp-text").innerText = game.player.hp;
          document.getElementById("p-hp-bar").style.width =
            (game.player.hp / game.player.maxHp) * 100 + "%";
          document.getElementById(
            "p-en-text"
          ).innerText = `EP: ${game.player.ep}/${game.player.maxEp}`;
          document.getElementById("p-blk-text").innerText =
            game.player.playerBlock;

          // Enemy Status
          document.getElementById("e-hp-bar").style.width =
            (this.enemy.hp / this.enemy.maxHp) * 100 + "%";
          document.getElementById("e-pos-bar").style.width =
            (this.enemy.pos / this.enemy.maxPos) * 100 + "%";

          // Flux Gauge
          const fluxContainer = document.querySelector(".flux-container");
          const fluxBar = document.querySelector(".flux-fill");
          fluxContainer.classList.add("active");
          fluxBar.style.width = this.flux + "%";
          if (this.flux > 80) fluxBar.classList.add("flux-danger");
          else fluxBar.classList.remove("flux-danger");

          // AIS Panel
          const aisPanel = document.getElementById("ais-panel");
          if (aisPanel) {
            if (this.state === "AIS_PHASE") {
              aisPanel.style.display = "block";
              document.getElementById("ais-atk-val").style.width =
                this.intentProb.ATTACK + "%";
              document.getElementById("ais-def-val").style.width =
                this.intentProb.DEFEND + "%";
              document.getElementById("ais-skl-val").style.width =
                this.intentProb.SKILL + "%";
            } else {
              aisPanel.style.display = "none";
            }
          }

          // Command Slots rendering
          const container = document.getElementById("command-container");
          container.innerHTML = "";

          this.slots.forEach((slot, idx) => {
            const cmd = slot.data;
            const el = document.createElement("div");
            el.className = "cmd-btn";

            // ËÄê‰πÖÂàá„Çå„ÉÅ„Çß„ÉÉ„ÇØ
            const currentDur = game.player.durability[slot.source];
            if (currentDur <= 0) el.classList.add("disabled");

            // AIS„Éï„Çß„Éº„Ç∫„Å®Chain„Éï„Çß„Éº„Ç∫„Åß„ÅÆÊúâÂäπÂåñÂà∂Âæ°
            // Á∞°ÊòìÁöÑ„Å´Â∏∏„Å´Êäº„Åõ„Çã„Çà„ÅÜ„Å´„Åó„ÄÅ„É≠„Ç∏„ÉÉ„ÇØÂÅ¥„ÅßÂºæ„Åè

            el.onclick = () => this.clickCommand(idx);

            el.innerHTML = `
               <div class="cmd-tag">[${cmd.tags[0]}]</div>
               <div style="font-weight:bold">${cmd.name}</div>
               <div class="cmd-type-${cmd.type.toLowerCase()}" style="width:100%; margin:2px 0;"></div>
               <div class="cmd-flux">${
                 cmd.tags.includes("VENT") ? "-50" : "+" + cmd.flux
               }</div>
               <div class="cmd-durability">Dur:${currentDur}</div>
             `;
            container.appendChild(el);
          });

          // „Çø„Éº„É≥ÁµÇ‰∫Ü„Éú„Çø„É≥„ÅÆÂà∂Âæ°
          const endBtn = document.getElementById("btn-end-chain");
          if (this.state === "CHAIN_PHASE") {
            endBtn.style.display = "block";
          } else {
            endBtn.style.display = "none";
          }
        },
      };
      window.onload = () => game.init();
    </script>
  </body>
</html>
