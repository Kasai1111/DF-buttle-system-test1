<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DUSTFALL Prototype - SP Fix</title>
    <style>
      :root {
        --bg-color: #121212;
        --panel-bg: #1e1e1e;
        --text-color: #e0e0e0;
        --accent-color: #ff9800;
        --atk-color: #e57373;
        --grd-color: #64b5f6;
        --brk-color: #fff176;
        --sp-color: #ba68c8;
        --secret-color: #90a4ae;
      }
      body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 10px;
      }
      h1 {
        margin: 10px 0;
        font-size: 1.2rem;
        border-bottom: 2px solid var(--accent-color);
      }

      .game-container {
        width: 100%;
        max-width: 600px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .panel {
        background: var(--panel-bg);
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #333;
        position: relative;
        transition: border-color 0.3s;
      }

      /* 先攻表示用のスタイル */
      .panel.initiative {
        border-color: var(--accent-color);
        box-shadow: 0 0 10px rgba(255, 152, 0, 0.2);
      }
      .initiative-badge {
        position: absolute;
        top: -10px;
        right: 10px;
        background: var(--accent-color);
        color: #000;
        font-size: 0.75rem;
        padding: 2px 8px;
        border-radius: 4px;
        font-weight: bold;
        display: none;
      }
      .panel.initiative .initiative-badge {
        display: block;
      }

      /* 敵の予告情報 (INTEL) */
      .intel-box {
        background: rgba(0, 0, 0, 0.3);
        border: 1px dashed #555;
        padding: 5px;
        margin-top: 5px;
        font-size: 0.85rem;
        color: #aaa;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .intel-val {
        color: #fff;
        font-weight: bold;
        font-size: 1rem;
      }

      /* Status Bars */
      .status-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        font-size: 0.9rem;
      }
      .bar-wrap {
        width: 100%;
        background: #444;
        height: 8px;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 5px;
      }
      .hp-bar {
        background: #d32f2f;
        height: 100%;
        width: 100%;
        transition: width 0.3s;
      }
      .pos-bar {
        background: #fbc02d;
        height: 100%;
        width: 100%;
        transition: width 0.3s;
      }

      .resource-box {
        display: flex;
        gap: 10px;
        font-weight: bold;
        font-size: 0.9rem;
      }
      .ep-val {
        color: var(--grd-color);
      }
      .sp-val {
        color: var(--sp-color);
      }
      .burnout-tag {
        color: red;
        font-weight: bold;
        animation: blink 1s infinite;
        display: none;
      }
      @keyframes blink {
        50% {
          opacity: 0.5;
        }
      }

      /* Card UI */
      .card-area {
        display: flex;
        gap: 5px;
        justify-content: center;
        min-height: 90px;
        flex-wrap: wrap;
      }
      .card {
        width: 70px;
        height: 100px;
        border-radius: 6px;
        border: 2px solid #555;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        cursor: pointer;
        position: relative;
        background: #333;
        user-select: none;
        transition: transform 0.2s;
      }
      .card:hover {
        transform: translateY(-3px);
        border-color: #888;
      }
      .card.selected {
        border-color: var(--accent-color);
        box-shadow: 0 0 8px var(--accent-color);
        transform: translateY(-10px);
      }
      .card.disabled {
        opacity: 0.5;
        filter: grayscale(1);
      }

      /* Types */
      .type-Attack {
        border-top: 4px solid var(--atk-color);
      }
      .type-Guard {
        border-top: 4px solid var(--grd-color);
      }
      .type-Break {
        border-top: 4px solid var(--brk-color);
        color: #ffffaa;
      }
      .type-SP {
        border-top: 4px solid var(--sp-color);
        background: #301b30;
      }
      .type-Secret {
        border-top: 4px solid var(--secret-color);
        background: #263238;
      }

      .card-cost {
        font-size: 1.2rem;
        font-weight: bold;
        margin: 2px 0;
      }
      .card-type {
        font-weight: bold;
      }

      /* Slots */
      .slots-wrapper {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 5px 0;
      }
      .slot {
        width: 80px;
        height: 110px;
        border: 2px dashed #666;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        color: #888;
        position: relative;
        transition: all 0.3s ease;
        cursor: pointer;
      }
      .slot:hover {
        border-color: #999;
      }

      .active-battle-slot {
        border: 2px solid #fff !important;
        box-shadow: 0 0 15px var(--accent-color);
        transform: scale(1.1);
        background-color: #2a2a2a;
        z-index: 10;
        color: #fff;
      }

      .slot-result-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.4rem;
        font-weight: bold;
        border-radius: 4px;
        animation: popIn 0.3s forwards;
        z-index: 20;
      }
      .res-win {
        color: #66bb6a;
        text-shadow: 0 0 5px #66bb6a;
      }
      .res-lose {
        color: #ef5350;
        text-shadow: 0 0 5px #ef5350;
      }
      .res-draw {
        color: #bdbdbd;
      }

      @keyframes popIn {
        0% {
          transform: scale(0);
          opacity: 0;
        }
        80% {
          transform: scale(1.2);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Controls */
      .controls {
        display: flex;
        gap: 10px;
      }
      button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 4px;
        font-weight: bold;
        cursor: pointer;
        font-size: 1rem;
      }
      #btn-commit {
        background: var(--accent-color);
        color: #000;
      }
      #btn-commit:disabled {
        background: #555;
        cursor: not-allowed;
      }
      #btn-counter {
        background: #7b1fa2;
        color: #fff;
      }
      #btn-counter.active {
        background: #e1bee7;
        color: #4a148c;
        border: 2px solid #fff;
      }

      /* Log */
      #log {
        height: 120px;
        overflow-y: auto;
        background: #000;
        color: #0f0;
        padding: 8px;
        font-family: monospace;
        font-size: 0.85rem;
        border-radius: 4px;
      }

      /* Type Chart */
      .type-chart-container {
        position: fixed;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(30, 30, 30, 0.95);
        border: 1px solid #444;
        border-radius: 12px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        z-index: 100;
        width: 100px;
      }
      .tc-title {
        font-size: 0.75rem;
        color: #888;
        margin-bottom: 5px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .tc-node {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 0.8rem;
        color: #222;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
        position: relative;
        z-index: 2;
      }
      .tc-atk {
        background: var(--atk-color);
        border: 2px solid #ef9a9a;
      }
      .tc-brk {
        background: var(--brk-color);
        border: 2px solid #fff59d;
      }
      .tc-grd {
        background: var(--grd-color);
        border: 2px solid #90caf9;
      }
      .tc-arrow {
        font-size: 1.5rem;
        color: #666;
        line-height: 0.8;
      }
      .tc-loop-arrow {
        font-size: 0.7rem;
        color: #666;
        margin-top: -5px;
      }

      @media (max-width: 900px) {
        .type-chart-container {
          position: static;
          transform: none;
          flex-direction: row;
          width: 100%;
          max-width: 600px;
          margin-top: 20px;
          justify-content: center;
          background: transparent;
          border: none;
          box-shadow: none;
        }
        .tc-arrow {
          transform: rotate(-90deg);
          margin: 0 5px;
        }
        .tc-loop-arrow {
          display: none;
        }
        .tc-node {
          width: 60px;
          height: 60px;
          font-size: 0.7rem;
        }
      }
    </style>
  </head>
  <body>
    <h1>DUSTFALL - Battle Prototype</h1>

    <div class="game-container">
      <div class="panel" id="e-panel">
        <div class="initiative-badge">先攻</div>
        <div class="status-row">
          <strong>ENEMY</strong>
          <span class="burnout-tag" id="e-burnout">BURNOUT</span>
        </div>
        <div class="bar-wrap"><div class="hp-bar" id="e-hp-bar"></div></div>
        <div class="bar-wrap"><div class="pos-bar" id="e-pos-bar"></div></div>
        <div class="resource-box">
          <span>HP: <span id="e-hp"></span></span>
          <span class="ep-val">EP: <span id="e-ep"></span></span>
          <span class="sp-val">SP: <span id="e-sp"></span></span>
        </div>

        <div class="intel-box" id="e-intel-box" style="display: none">
          <span>⚠ 合計消費コスト:</span>
          <span class="intel-val" id="e-pending-cost">0</span>
        </div>

        <hr style="border: 0; border-top: 1px solid #444; margin: 5px 0" />
        <div style="font-size: 0.8rem; text-align: center; color: #888">
          ENEMY HAND
        </div>
        <div class="card-area" id="enemy-hand-view"></div>
      </div>

      <div style="text-align: center">
        <div class="slots-wrapper">
          <div class="slot" id="e-slot1">Enemy<br />Slot 1</div>
          <div class="slot" id="e-slot2">Enemy<br />Slot 2</div>
        </div>
        <div style="font-weight: bold; color: #888; margin: 5px 0">VS</div>
        <div class="slots-wrapper">
          <div class="slot" id="p-slot1" onclick="clearSlot(1)">
            Tap Card<br />to Set
          </div>
          <div class="slot" id="p-slot2" onclick="clearSlot(2)">
            Tap Card<br />to Set
          </div>
        </div>
      </div>

      <div class="panel" id="p-panel">
        <div class="initiative-badge">先攻</div>
        <div class="status-row">
          <strong>PLAYER</strong>
          <span class="burnout-tag" id="p-burnout">BURNOUT</span>
        </div>
        <div class="bar-wrap"><div class="hp-bar" id="p-hp-bar"></div></div>
        <div class="bar-wrap"><div class="pos-bar" id="p-pos-bar"></div></div>
        <div class="resource-box">
          <span>HP: <span id="p-hp"></span></span>
          <span class="ep-val">EP: <span id="p-ep"></span></span>
          <span class="sp-val">SP: <span id="p-sp"></span></span>
        </div>
        <hr style="border: 0; border-top: 1px solid #444; margin: 5px 0" />
        <div class="card-area" id="player-hand-view"></div>
      </div>

      <div class="controls">
        <button id="btn-counter" onclick="toggleCounter()">
          SP カウンター攻撃
        </button>
        <button id="btn-commit" onclick="commitTurn()">コマンド決定</button>
      </div>

      <div id="log">Game Initialized...</div>
    </div>

    <div class="type-chart-container">
      <div class="tc-title">RULE</div>
      <div class="tc-node tc-atk"><span>Attack</span></div>
      <div class="tc-arrow">↓</div>
      <div class="tc-node tc-brk"><span>Break</span></div>
      <div class="tc-arrow">↓</div>
      <div class="tc-node tc-grd"><span>Guard</span></div>
      <div class="tc-arrow">↓</div>
      <div class="tc-loop-arrow">(to Attack)</div>
      <div
        style="
          margin-top: 10px;
          border-top: 1px dashed #666;
          padding-top: 5px;
          font-size: 0.7rem;
          color: var(--sp-color);
          text-align: center;
        "
      >
        SPは全てに勝利
      </div>
    </div>

    <script>
      /**
       * DUSTFALL Logic Implementation
       */

      /**
       * DUSTFALL Logic Implementation
       */

      const MAX_HP = 50;
      const MAX_POSTURE = 20;
      const MAX_EP = 9;
      const MAX_SP = 5;

      const TYPE = {
        ATTACK: "Attack",
        GUARD: "Guard",
        BREAK: "Break",
        SP: "SP",
      };

      const WIN_MAP = {
        [TYPE.ATTACK]: TYPE.BREAK,
        [TYPE.BREAK]: TYPE.GUARD,
        [TYPE.GUARD]: TYPE.ATTACK,
      };

      const BASE_DECK = [
        { type: TYPE.ATTACK, cost: 2, dmg: 8, pos: 2 },
        { type: TYPE.ATTACK, cost: 3, dmg: 10, pos: 3 },
        { type: TYPE.BREAK, cost: 2, dmg: 4, pos: 6 },
        { type: TYPE.BREAK, cost: 3, dmg: 6, pos: 8 },
        { type: TYPE.GUARD, cost: 1, arm: 4 },
        { type: TYPE.GUARD, cost: 2, arm: 7 },
        { type: TYPE.GUARD, cost: 3, arm: 10 },
        { type: TYPE.ATTACK, cost: 1, dmg: 5, pos: 1 },
        { type: TYPE.BREAK, cost: 1, dmg: 3, pos: 5 },
      ];

      const SP_CARD = { type: TYPE.SP, cost: 5, dmg: 35, pos: 15, isSP: true };

      // --- AI Strategy Definitions (戦略定義) ---
      /**
       * AI_STRATEGIES には、AIの具体的な行動ロジックを関数として格納します。
       * 各関数は (entity) を引数に取り、[Slot1Card, Slot2Card] の配列を返します。
       */
      // --- AI Helper Functions ---
      const analyzeOpponent = (playerEntity, currentCost) => {
        const hand = playerEntity.hand;
        return {
          hasSP: hand.some((c) => c.isSP),
          atkCount: hand.filter((c) => c.type === TYPE.ATTACK).length,
          grdCount: hand.filter((c) => c.type === TYPE.GUARD).length,
          brkCount: hand.filter((c) => c.type === TYPE.BREAK).length,
          isHighCost: currentCost >= 5, // プレイヤーが5コスト以上積んでいる（SPの可能性大）
          isLowCost: currentCost <= 2, // 様子見か？
          pendingCost: currentCost,
        };
      };

      // --- AI Strategy Definitions ---
      const AI_STRATEGIES = {
        // ISTJ: 管理者型 (The Realist)
        // 特徴: 「データに基づく最適解」。相手の手札構成を見て、統計的に最も勝率の高い手を打つ。
        // 後攻有利を最大限活かし、相手が大技(Cost 5)できたら、確実に相殺か防御を選択する。
        ISTJ: (entity, opponent, isSecond, pCost) => {
          let eSlots = [null, null];
          let action = "COMMIT"; // or "COUNTER"
          let hand = [...entity.hand];
          let budget = entity.ep;

          const oppInfo = analyzeOpponent(opponent, pCost);

          // 1. 後攻時の確実な対処 (Reaction)
          if (isSecond) {
            // 相手がコスト5以上積んでいる場合（SP濃厚）
            if (oppInfo.isHighCost) {
              // A. こちらもSPがあればぶつけて相殺する (Risk 0)
              const spCard = hand.find((c) => c.isSP);
              if (spCard && entity.sp >= MAX_SP && budget >= 5) {
                return { slots: [spCard, null], action: "COMMIT" };
              }
              // B. SPがない、またはコスト不足なら「カウンター」を発動して無効化を狙う
              if (!entity.hasUsedCounter) {
                return { slots: [null, null], action: "COUNTER" };
              }
              // C. カウンターもないなら、最大の防御(Guard)を置く
              const bestGuard = hand
                .filter((c) => c.type === TYPE.GUARD)
                .sort((a, b) => b.arm - a.arm)[0];
              if (bestGuard && bestGuard.cost <= budget) {
                return { slots: [bestGuard, null], action: "COMMIT" };
              }
            }
          }

          // 2. 手札読み (Hand Reading)
          // 相手の手札にAttackが多い -> Guard優先
          // 相手の手札にGuardが多い -> Break優先
          let bias = TYPE.ATTACK;
          if (oppInfo.atkCount > oppInfo.grdCount) bias = TYPE.GUARD;
          if (oppInfo.grdCount > oppInfo.atkCount) bias = TYPE.BREAK;

          // 3. 標準行動 (Standard Protocol)
          // 優先度: リーサル > バイアスに合わせた行動 > 高効率カード

          // リーサル計算 (簡易)
          const totalDmg = hand.reduce((acc, c) => acc + (c.dmg || 0), 0);
          if (totalDmg >= opponent.hp && budget >= 3) {
            // 全力攻撃
            const atks = hand
              .filter((c) => c.dmg > 0)
              .sort((a, b) => b.dmg - a.dmg);
            if (atks[0] && atks[0].cost <= budget) {
              eSlots[0] = atks[0];
              budget -= atks[0].cost;
              const nextAtk = atks.filter((c) => c !== eSlots[0])[0];
              if (nextAtk && nextAtk.cost <= budget) eSlots[1] = nextAtk;
            }
            return { slots: eSlots, action: "COMMIT" };
          }

          // バイアスに従ってカードを選ぶ
          const preferred = hand
            .filter((c) => c.type === bias && c.cost <= budget && !c.isSP)
            .sort((a, b) => b.cost - a.cost)[0];

          if (preferred) {
            eSlots[0] = preferred;
            budget -= preferred.cost;
            hand = hand.filter((c) => c !== preferred);
          } else {
            // なければ最強のカード
            const backup = hand
              .filter((c) => c.cost <= budget && !c.isSP)
              .sort((a, b) => b.cost - a.cost)[0];
            if (backup) {
              eSlots[0] = backup;
              budget -= backup.cost;
              hand = hand.filter((c) => c !== backup);
            }
          }

          // Slot 2: 余り予算で埋める
          if (budget > 0) {
            const filler = hand
              .filter((c) => c.cost <= budget && !c.isSP)
              .sort((a, b) => b.cost - a.cost)[0];
            if (filler) eSlots[1] = filler;
          }

          return { slots: eSlots, action: "COMMIT" };
        },

        // INFJ: 提唱者型 (The Mastermind)
        // 特徴: 「心理戦と偽装」。
        // 自分が先攻なら、あえてコスト5になるようにカードを組み合わせて「SP」に見せかける(ブラフ)。
        // 相手がSPを持っていたら、自分が後攻になるまでSPを温存したり、カウンターの罠を張る。
        INFJ: (entity, opponent, isSecond, pCost) => {
          let eSlots = [null, null];
          let hand = [...entity.hand];
          let budget = entity.ep;
          const oppInfo = analyzeOpponent(opponent, pCost);

          // 1. SPカウンターの罠 (Trap)
          // 相手がSPを持っていて、かつこちらが後攻なら、相手のSP発動(Cost 5)を読んでカウンター
          if (
            isSecond &&
            oppInfo.isHighCost &&
            oppInfo.hasSP &&
            !entity.hasUsedCounter
          ) {
            // 90%の確率でカウンター発動（たまに読み違える人間味）
            if (Math.random() < 0.9)
              return { slots: [null, null], action: "COUNTER" };
          }

          // 2. 先攻時のブラフ (The Bluff)
          // SPが溜まっていない、あるいは使いたくないが、相手に「SPかも？」と思わせてカウンター(無駄打ち)させたい
          // 手札から合計コストが「5」になる組み合わせ（例: 2+3）を探してセットする
          if (!isSecond && budget >= 5 && entity.sp < MAX_SP) {
            // 手札のペアを探す
            for (let i = 0; i < hand.length; i++) {
              for (let j = i + 1; j < hand.length; j++) {
                if (
                  hand[i].cost + hand[j].cost === 5 &&
                  !hand[i].isSP &&
                  !hand[j].isSP
                ) {
                  // ブラフ成立
                  return { slots: [hand[i], hand[j]], action: "COMMIT" };
                }
              }
            }
          }

          // 3. 本物のSP発動 (The Finisher)
          // 相手がBreak中、または相手のPendingCostが低く(カウンターされにくい)、かつこちらがSPMAX
          const spCard = hand.find((c) => c.isSP);
          if (spCard && entity.sp >= MAX_SP && budget >= 5) {
            if (opponent.breakState || (isSecond && oppInfo.pendingCost < 5)) {
              return { slots: [spCard, null], action: "COMMIT" };
            }
          }

          // 4. コンボ攻撃 (Break -> Attack)
          // 相手の防御が薄そうなら畳み掛ける
          const breakC = hand.find(
            (c) => c.type === TYPE.BREAK && c.cost <= budget
          );
          if (breakC && opponent.pos < 10) {
            eSlots[0] = breakC;
            budget -= breakC.cost;
            // 追撃
            const atkC = hand.find(
              (c) => c.type === TYPE.ATTACK && c.cost <= budget
            );
            if (atkC) eSlots[1] = atkC;
            return { slots: eSlots, action: "COMMIT" };
          }

          // 5. デフォルト: 手札で最も強い動き
          const bestCards = hand
            .filter((c) => !c.isSP && c.cost <= budget)
            .sort((a, b) => b.cost - a.cost);
          if (bestCards[0]) {
            eSlots[0] = bestCards[0];
            budget -= bestCards[0].cost;
            const next = hand.filter(
              (c) => c !== eSlots[0] && !c.isSP && c.cost <= budget
            )[0];
            if (next) eSlots[1] = next;
          }

          return { slots: eSlots, action: "COMMIT" };
        },
      };
      // AI戦略名のリスト
      const AI_STRATEGY_NAMES = Object.keys(AI_STRATEGIES);

      // --- Global State ---
      let turn = 1;
      let player, enemy;
      let pSlots = [null, null];
      let isCounterMode = false;
      let hasUsedCounter = false;
      let isAnimating = false;

      // Initiative State
      let isEnemyFirst = false;
      let pendingEnemySlots = [null, null];

      // Helper for sleep
      const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

      function getDeck(includeSP) {
        const deck = JSON.parse(JSON.stringify(BASE_DECK));
        if (includeSP) deck.push(JSON.parse(JSON.stringify(SP_CARD)));
        shuffle(deck);
        return deck;
      }

      // --- createEntity 関数の修正 ---
      function createEntity(name) {
        const deck = getDeck(false);
        const secret = deck.pop();

        const entity = {
          name,
          hp: MAX_HP,
          maxHp: MAX_HP,
          pos: MAX_POSTURE,
          maxPos: MAX_POSTURE,
          ep: 5,
          sp: 0,
          deck,
          hand: [],
          secret,
          burnout: false,
          breakState: false,
          justBroken: false,
        };

        // Enemyの場合のみ、ランダムなAI戦略を割り当てる
        if (name === "Enemy") {
          const randomStrategyName =
            AI_STRATEGY_NAMES[
              Math.floor(Math.random() * AI_STRATEGY_NAMES.length)
            ];
          entity.strategy = randomStrategyName;
          log(`[System] Enemy Strategy: ${randomStrategyName} assigned.`);
        }

        return entity;
      }

      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }

      function init() {
        player = createEntity("Player");
        enemy = createEntity("Enemy"); // EnemyにはここでランダムなAIが設定される
        isEnemyFirst = Math.random() < 0.5;
        startTurn();
      }

      function startTurn() {
        pSlots = [null, null];
        isCounterMode = false;
        isAnimating = false;
        isEnemyFirst = !isEnemyFirst;

        // HP/EP回復とカード配布処理
        [player, enemy].forEach((e) => {
          if (e.breakState) {
            e.burnout = true;
          }

          if (!e.burnout && !e.breakState) {
            e.pos = Math.min(e.maxPos, e.pos + 2.7);
          }

          e.ep = Math.min(MAX_EP, e.ep + 4);
          e.sp = Math.min(MAX_SP, e.sp + 1);

          while (e.hand.length < 3) {
            if (e.deck.length === 0) {
              const freshDeck = getDeck(false);
              e.deck = freshDeck;
              log(`[System] ${e.name}'s Deck Recycled`);
            }
            e.hand.push(e.deck.pop());
            if (e.hand.length >= 3) break;
          }
        });

        // SPカード配布イベント (ターン4)
        if (turn === 4) {
          [player, enemy].forEach((e) => {
            const spCard = JSON.parse(JSON.stringify(SP_CARD));
            if (e.hp <= e.maxHp * 0.3) {
              e.deck.push(spCard);
              log(`[System] ${e.name}: CRISIS! SP Card set to TOP.`);
            } else {
              const idx = Math.floor(Math.random() * (e.deck.length + 1));
              e.deck.splice(idx, 0, spCard);
              log(`[System] ${e.name}: SP Card added to deck.`);
            }
          });
        }

        updateSlotUI("e", [null, null]);
        document.getElementById("e-slot1").innerHTML = "Enemy<br>Slot 1";
        document.getElementById("e-slot2").innerHTML = "Enemy<br>Slot 2";

        // --- 修正箇所: AIのBURNOUT判定を追加 ---
        if (enemy.burnout) {
          // 敵がBURNOUT中なら行動不能
          pendingEnemySlots = [null, null];
          enemy.isCounterMode = false;
          log("[System] Enemy is BURNOUT. Skipping turn.");
        } else {
          // 通常通りAIを呼び出す
          const aiRes = AI_STRATEGIES[enemy.strategy](
            enemy,
            player,
            !isEnemyFirst,
            0
          );

          pendingEnemySlots = aiRes.slots;
          if (aiRes.action === "COUNTER") enemy.isCounterMode = true;
          else enemy.isCounterMode = false;
        }
        // ----------------------------------------

        log(`--- TURN ${turn} START ---`);
        if (isEnemyFirst) log("Enemy has Initiative (First).");
        else log("Player has Initiative (First).");

        render();
      }
      function finishTurnProcessing() {
        [player, enemy].forEach((e) => {
          if (e.breakState) {
            if (e.justBroken) {
              e.justBroken = false;
              e.burnout = true;
            } else {
              e.pos = e.maxPos;
              e.breakState = false;
              if (e.ep > 0) e.burnout = false;
              log(`${e.name} RECOVERED from Break!`);
            }
          } else {
            if (e.ep <= 0) {
              e.burnout = true;
              log(`${e.name} enters EP BURNOUT!`);
            } else {
              e.burnout = false;
            }
          }
        });

        turn++;
        render();

        if (player.hp <= 0 || enemy.hp <= 0) {
          setTimeout(() => {
            alert(player.hp <= 0 ? "YOU LOSE..." : "YOU WIN!");
            location.reload();
          }, 500);
          return;
        }

        setTimeout(startTurn, 1000);
      }
      function selectCard(card, isSecret, handIndex) {
        if (isAnimating) return;
        if (player.burnout) {
          alert("BURNOUT（行動不能）のため、カードを選択できません。");
          return;
        }
        // ----------------------------------

        if (isCounterMode) {
          alert("カウンターモード中はカードを選択できません。");
          return;
        }

        const srcId = isSecret ? "secret" : handIndex;

        if (pSlots[0] && pSlots[0]._src === srcId) {
          pSlots[0] = null;
          render();
          return;
        }
        if (pSlots[1] && pSlots[1]._src === srcId) {
          pSlots[1] = null;
          render();
          return;
        }

        if (card.isSP) {
          if (player.sp < MAX_SP) {
            alert(`SP技を使用するにはSPゲージが最大(${MAX_SP})必要です。`);
            return;
          }
          if (player.ep < 5) {
            alert(`SP技の発動にはEPが5必要です。`);
            return;
          }
        }

        if (player.burnout && card.type === TYPE.GUARD) {
          alert("BURNOUT中はガードカードを使用できません！");
          return;
        }

        let currentCost = (pSlots[0]?.cost || 0) + (pSlots[1]?.cost || 0);
        if (currentCost + card.cost > player.ep) {
          alert(`EPが足りません！`);
          return;
        }

        if (!pSlots[0]) {
          pSlots[0] = { ...card, _src: srcId };
        } else if (!pSlots[1]) {
          pSlots[1] = { ...card, _src: srcId };
        } else {
          alert(
            "スロットがいっぱいです。選択済みのカードをタップして解除するか、スロットをタップして空けてください。"
          );
          return;
        }
        render();
      }

      function clearSlot(num) {
        if (isAnimating) return;
        pSlots[num - 1] = null;
        render();
      }

      function toggleCounter() {
        if (isAnimating) return;

        // --- 追加箇所: BURNOUTチェック ---
        if (player.burnout) {
          alert("BURNOUT（行動不能）のため、カウンターは使用できません。");
          return;
        }
        // -----------------------------

        if (hasUsedCounter) {
          alert("カウンターは1試合に1回しか使用できません。");
          return;
        }
        isCounterMode = !isCounterMode;
        if (isCounterMode) pSlots = [null, null];
        render();
      }

      // --- calculateEnemyMove 関数の修正 ---
      function calculateEnemyMove(entity) {
        if (entity.burnout) {
          return [null, null];
        }
        // 割り当てられた戦略に基づいて、その戦略の関数を実行する
        const strategyFunction = AI_STRATEGIES[entity.strategy];
        if (strategyFunction) {
          return strategyFunction(entity);
        }
        // 見つからない場合は安全のため何もしない
        return [null, null];
      }

      async function commitTurn() {
        if (isAnimating) return;

        const pCost = (pSlots[0]?.cost || 0) + (pSlots[1]?.cost || 0);

        // プレイヤーのバリデーション
        if (!player.burnout && !isCounterMode && !pSlots[0] && !pSlots[1]) {
          alert("カードを選択するか、カウンターを選択してください。");
          return;
        }

        isAnimating = true;

        // --- 敵の再思考ロジック (Re-Calculation) ---
        if (!isEnemyFirst && !enemy.burnout) {
          const aiRes = AI_STRATEGIES[enemy.strategy](
            enemy,
            player,
            true,
            pCost
          );
          pendingEnemySlots = aiRes.slots;

          if (aiRes.action === "COUNTER") {
            enemy.isCounterMode = true;
            pendingEnemySlots = [null, null];
            log(`⚠ Enemy enters COUNTER Stance!`);
          } else {
            enemy.isCounterMode = false;
          }
        } else if (isEnemyFirst && !enemy.burnout) {
          enemy.isCounterMode = false;
        }

        render();

        const eSlots = pendingEnemySlots;
        const eCost = enemy.isCounterMode
          ? 0
          : (eSlots[0]?.cost || 0) + (eSlots[1]?.cost || 0);

        // --- EP消費 ---
        player.ep -= pCost;
        enemy.ep -= eCost;

        // --- 追加箇所: SPカード使用時のSP消費 ---
        // プレイヤーがSPカードを使っていたらSP-5
        if (pSlots.some((c) => c?.isSP)) {
          player.sp = Math.max(0, player.sp - 5);
        }

        // 敵がSPカードを使っていたらSP-5
        if (!enemy.isCounterMode && eSlots.some((c) => c?.isSP)) {
          enemy.sp = Math.max(0, enemy.sp - 5);
        }
        // ------------------------------------

        processHandUsage(player, pSlots);
        if (!enemy.isCounterMode) {
          processHandUsage(enemy, eSlots);
        }

        render();

        // ログ出力
        if (player.burnout) log("Player is Stunned (Burnout)...");
        if (enemy.burnout) log("Enemy is Stunned (Burnout)...");

        const pAction = isCounterMode ? "COUNTER" : `Cost ${pCost}`;
        const eAction = enemy.isCounterMode ? "COUNTER" : `Cost ${eCost}`;
        log(`Battle! P:[${pAction}] vs E:[${eAction}]`);

        await sleep(600);

        let pCards = [...pSlots];
        let eCards = [...eSlots];

        const pSP = pCards.some((c) => c?.isSP);
        const eSP = eCards.some((c) => c?.isSP);

        // --- SP相殺・カウンター判定ロジック ---
        let pCounterSuccess = false;
        let eCounterSuccess = false;

        // 1. SP同士の衝突
        if (pSP && eSP) {
          log("!!! SP CLASH !!! 双方がSPを使用 -> 相殺！");
          pCards = [null, null];
          eCards = [null, null];
          await sleep(1000);
        }
        // 2. プレイヤーのカウンター成功
        else if (eSP && isCounterMode) {
          log("!!! PLAYER COUNTER SUCCESS !!!");
          hasUsedCounter = true;
          eCards = [null, null]; // 敵のカード無効化
          pCounterSuccess = true;
          await sleep(1000);
        }
        // 3. 敵のカウンター成功
        else if (pSP && enemy.isCounterMode) {
          log("!!! ENEMY COUNTER SUCCESS !!!");
          enemy.hasUsedCounter = true;
          pCards = [null, null]; // プレイヤーのカード無効化
          eCounterSuccess = true;
          await sleep(1000);
        }
        // 4. カウンター空振り
        else {
          if (isCounterMode) {
            log("Player Counter Missed...");
            hasUsedCounter = true;
          }
          if (enemy.isCounterMode) {
            log("Enemy Counter Missed...");
            enemy.hasUsedCounter = true;
          }
        }

        // ダメージ倍率
        let pMul = 1.0;
        let eMul = 1.0;

        log("--- SLOT 1 ---");
        const res1 = await resolveStep(1, pCards[0], eCards[0], pMul, eMul);

        // コンボ補正
        if (res1 === "WIN") {
          pMul = 1.7;
          eMul = 0.25;
          log(">> WIN Bonus: Next x1.7");
        } else if (res1 === "LOSE") {
          pMul = 0.25;
          eMul = 1.7;
          log(">> LOSE Penalty: Next x0.25");
        }

        log("--- SLOT 2 ---");
        await resolveStep(2, pCards[1], eCards[1], pMul, eMul);

        // --- ターン終了処理 ---
        finishTurnProcessing();
      }

      async function resolveStep(slotNum, pCard, eCard, pMul, eMul) {
        const pSlotEl = document.getElementById(`p-slot${slotNum}`);
        const eSlotEl = document.getElementById(`e-slot${slotNum}`);

        pSlotEl.classList.add("active-battle-slot");
        eSlotEl.classList.add("active-battle-slot");

        if (eCard) {
          eSlotEl.className = `slot type-${eCard.type} active-battle-slot`;
          eSlotEl.innerHTML = renderCardContent(eCard);
        } else {
          eSlotEl.className = `slot active-battle-slot`;
          eSlotEl.innerHTML = "Empty";
        }

        if (pCard) {
          pSlotEl.className = `slot type-${pCard.type} active-battle-slot`;
          pSlotEl.innerHTML = renderCardContent(pCard);
        } else {
          pSlotEl.className = `slot active-battle-slot`;
          pSlotEl.innerHTML = "Empty";
        }

        await sleep(1500);

        let result = "DRAW";
        if (!pCard && !eCard) result = "DRAW";
        else if (!pCard) {
          applyDmg(player, eCard, eMul);
          result = "LOSE";
        } else if (!eCard) {
          applyDmg(enemy, pCard, pMul);
          result = "WIN";
        } else {
          // --- 勝敗判定ロジック ---
          if (pCard.type === eCard.type) {
            // 同じタイプ同士ならコスト勝負
            if (pCard.cost > eCard.cost) result = "WIN";
            else if (eCard.cost > pCard.cost) result = "LOSE";
          } else if (pCard.type === TYPE.SP) {
            result = "WIN";
          } else if (eCard.type === TYPE.SP) {
            result = "LOSE";
          } else {
            // 通常の3すくみ判定
            if (WIN_MAP[pCard.type] === eCard.type) result = "WIN";
            else result = "LOSE";
          }

          if (result === "WIN") applyDmg(enemy, pCard, pMul);
          else if (result === "LOSE") applyDmg(player, eCard, eMul);
          else {
            player.hp -= 2;
            enemy.hp -= 2;
            log("Draw! Both take 2 dmg.");
          }
        }

        render();
        showResultOverlay(pSlotEl, result);
        showResultOverlay(
          eSlotEl,
          result === "WIN" ? "LOSE" : result === "LOSE" ? "WIN" : "DRAW"
        );

        await sleep(1200);

        pSlotEl.classList.remove("active-battle-slot");
        eSlotEl.classList.remove("active-battle-slot");
        clearOverlays(pSlotEl);
        clearOverlays(eSlotEl);

        return result;
      }

      function showResultOverlay(el, text) {
        const div = document.createElement("div");
        div.className = "slot-result-overlay";
        if (text === "WIN") div.classList.add("res-win");
        if (text === "LOSE") div.classList.add("res-lose");
        if (text === "DRAW") div.classList.add("res-draw");
        div.innerText = text;
        el.appendChild(div);
      }

      function clearOverlays(el) {
        const overs = el.querySelectorAll(".slot-result-overlay");
        overs.forEach((o) => o.remove());
      }

      function processHandUsage(entity, slots) {
        slots.forEach((s) => {
          if (!s) return;
          if (s._src === "secret") {
            if (entity.deck.length > 0) entity.secret = entity.deck.pop();
            else entity.secret = null;
          } else {
            const idx = entity.hand.findIndex(
              (c) => c.type === s.type && c.cost === s.cost
            );
            if (idx !== -1) entity.hand.splice(idx, 1);
          }
        });
      }

      function applyDmg(target, card, mul) {
        if (!card) return;
        let finalMul = mul;
        if (target.breakState) finalMul *= 2.0;
        if (target.burnout && !target.breakState) finalMul *= 1.5;

        let dmg = Math.floor((card.dmg || 0) * finalMul);
        let pos = Math.floor((card.pos || 0) * finalMul);

        target.hp -= dmg;
        target.pos -= pos;
        log(`${target.name} takes ${dmg} Dmg`);

        if (target.pos <= 0 && !target.breakState) {
          target.breakState = true;
          target.justBroken = true;
          target.pos = 0;
          log(`!!! ${target.name} POSTURE BREAK !!!`);
          log(`>> Next Turn: BURNOUT & x2 Dmg`);
        } else if (target.pos < 0) {
          target.pos = 0;
        }
      }

      // UI
      function render() {
        ["p", "e"].forEach((prefix) => {
          const e = prefix === "p" ? player : enemy;
          document.getElementById(`${prefix}-hp`).innerText = e.hp;
          document.getElementById(`${prefix}-ep`).innerText = e.ep;
          document.getElementById(`${prefix}-sp`).innerText = e.sp;
          document.getElementById(`${prefix}-hp-bar`).style.width = `${Math.max(
            0,
            (e.hp / MAX_HP) * 100
          )}%`;
          document.getElementById(
            `${prefix}-pos-bar`
          ).style.width = `${Math.max(0, (e.pos / MAX_POSTURE) * 100)}%`;
          document.getElementById(`${prefix}-burnout`).style.display = e.burnout
            ? "inline"
            : "none";

          const epEl = document.getElementById(`${prefix}-ep`);
          epEl.style.color = e.ep < 3 ? "red" : "var(--grd-color)";
        });

        const ePanel = document.getElementById("e-panel");
        const pPanel = document.getElementById("p-panel");
        if (isEnemyFirst) {
          ePanel.classList.add("initiative");
          pPanel.classList.remove("initiative");

          const intelBox = document.getElementById("e-intel-box");
          intelBox.style.display = "flex";
          const cost =
            (pendingEnemySlots[0]?.cost || 0) +
            (pendingEnemySlots[1]?.cost || 0);
          document.getElementById("e-pending-cost").innerText = cost + " EP";
        } else {
          pPanel.classList.add("initiative");
          ePanel.classList.remove("initiative");
          document.getElementById("e-intel-box").style.display = "none";
        }

        const eZone = document.getElementById("enemy-hand-view");
        eZone.innerHTML = "";
        eZone.innerHTML += `<div class="card type-Secret"><div class="card-type">SECRET</div><div class="card-cost">?</div></div>`;
        enemy.hand.forEach((c) => {
          eZone.innerHTML += `<div class="card type-${c.type}"><div class="card-type">${c.type}</div><div class="card-cost">${c.cost}</div></div>`;
        });

        const pZone = document.getElementById("player-hand-view");
        pZone.innerHTML = "";

        if (player.secret) {
          pZone.appendChild(createCardDiv(player.secret, true, -1));
        }
        player.hand.forEach((c, i) => {
          pZone.appendChild(createCardDiv(c, false, i));
        });

        if (!isAnimating) {
          updateSlotUI("p", pSlots);
        }

        const btnC = document.getElementById("btn-counter");
        btnC.innerText = hasUsedCounter
          ? "使用不可"
          : isCounterMode
          ? "カウンター準備中"
          : "SP カウンター攻撃";
        btnC.className = isCounterMode ? "active" : "";
        btnC.disabled = hasUsedCounter || isAnimating || player.burnout;

        const currentCost = (pSlots[0]?.cost || 0) + (pSlots[1]?.cost || 0);
        const btnCommit = document.getElementById("btn-commit");
        if (isAnimating) {
          btnCommit.innerText = "BATTLE IN PROGRESS...";
          btnCommit.disabled = true;
        } else if (player.burnout) {
          btnCommit.innerText = "ターンをスキップ (BURNOUT)";
          btnCommit.disabled = false;
          btnCommit.style.background = "#555";
        } else {
          btnCommit.innerText = `コマンド決定 (Cost: ${currentCost})`;
          btnCommit.disabled = currentCost > player.ep;
          btnCommit.style.background = "var(--accent-color)";
        }
      }

      function createCardDiv(card, isSecret, idx) {
        const div = document.createElement("div");
        div.className = `card type-${card.type}`;

        let disabled = false;
        if (player.burnout && card.type === TYPE.GUARD) disabled = true;
        if (card.isSP && (player.sp < MAX_SP || player.ep < 5)) disabled = true;

        if (disabled) div.classList.add("disabled");

        const isSel =
          pSlots[0]?._src === (isSecret ? "secret" : idx) ||
          pSlots[1]?._src === (isSecret ? "secret" : idx);
        if (isSel) {
          div.classList.add("selected");
          div.classList.remove("disabled");
        }

        div.innerHTML = `<div class="card-type">${
          isSecret ? "SECRET" : card.type
        }</div>
                   <div class="card-cost">${card.cost}</div>
                   <div style="font-size:0.7rem">${card.type}</div>`;

        div.onclick = () => selectCard(card, isSecret, idx);
        return div;
      }

      function updateSlotUI(prefix, slots) {
        for (let i = 1; i <= 2; i++) {
          const el = document.getElementById(`${prefix}-slot${i}`);
          const c = slots[i - 1];
          if (c) {
            el.className = `slot type-${c.type}`;
            el.innerHTML = renderCardContent(c);
          } else {
            el.className = "slot";
            if (prefix === "p") {
              el.innerHTML = `Tap Card<br>to Set`;
            } else {
              el.innerHTML = `Slot ${i}`;
            }
          }
        }
      }

      function renderCardContent(c) {
        if (!c) return "Empty";
        return `<div style="font-weight:bold">${c.type}</div><div style="font-size:1.2rem">${c.cost}</div>`;
      }

      function log(msg) {
        const l = document.getElementById("log");
        l.innerHTML += `<div>${msg}</div>`;
        l.scrollTop = l.scrollHeight;
      }

      window.onload = init;
    </script>
  </body>
</html>
