<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DUST FALL Ver.38.2 - Craft & Equip Fix</title>
    <style>
      /* --- CSS Reset & Base Styles --- */
      :root {
        --bg-color: #0a0a0a;
        --text-color: #e0e0e0;
        --accent-color: #c3073f;
        --ui-bg: #1f1f1f;
        --ui-border: #444;
      }
      body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: "Segoe UI", monospace;
        user-select: none;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
      }
      #game-container {
        width: 1024px;
        height: 768px;
        position: relative;
        background: #000;
        border: 2px solid #333;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
      }

      /* --- Screen Management --- */
      .screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        flex-direction: column;
        background: var(--bg-color);
        z-index: 10;
      }
      .screen.active {
        display: flex;
        z-index: 20;
      }

      /* --- UI Components --- */
      .title-text {
        font-size: 100px;
      }
      h1,
      h2,
      h3 {
        margin: 0;
        padding: 5px;
        color: #ffd700;
        text-shadow: 1px 1px 0 #000;
      }
      button {
        background: #333;
        color: #fff;
        border: 1px solid #666;
        padding: 8px 16px;
        cursor: pointer;
        font-family: inherit;
        transition: 0.2s;
      }
      button:hover {
        background: #555;
        border-color: #fff;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* --- Title Screen --- */
      #title-screen {
        justify-content: center;
        align-items: center;
        background: linear-gradient(45deg, #232324, rgb(0, 0, 0));
      }

      /* --- Base Screen --- */
      #base-screen {
        padding: 20px;
      }
      .base-layout {
        display: flex;
        height: 80%;
        gap: 10px;
        margin-top: 10px;
      }
      .panel {
        flex: 1;
        border: 1px solid var(--ui-border);
        background: var(--ui-bg);
        padding: 10px;
        overflow-y: auto;
      }
      .item-row {
        display: flex;
        justify-content: space-between;
        padding: 8px;
        border-bottom: 1px dashed #444;
        cursor: pointer;
        font-size: 14px;
        align-items: center;
      }
      .item-row:hover {
        background: #333;
      }
      /* è£…å‚™ã‚¢ã‚¤ãƒ†ãƒ å¼·èª¿ */
      .item-row.equipped {
        background: #152;
        color: #0f0;
        font-weight: bold;
        border-left: 5px solid #0f0;
        box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
      }
      .item-row.locked {
        color: #666;
        opacity: 0.5;
        cursor: default;
      }
      .item-buyable {
        background: #242;
        border-left: 5px solid #0f0;
      }
      .item-buyable:hover {
        background: #353;
      }
      .item-cost {
        font-size: 10px;
        color: #aaa;
      }

      /* --- Explore Screen --- */
      #explore-screen {
        position: relative;
      }
      canvas {
        display: block;
        background: #000;
      }
      #explore-ui {
        position: absolute;
        top: 10px;
        left: 10px;
        pointer-events: none;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border: 1px solid #555;
      }
      #stealth-indicator {
        font-weight: bold;
        color: #444;
      }
      #stealth-indicator.active {
        color: #0ff;
        text-shadow: 0 0 5px #0ff;
      }
      #explore-log {
        position: absolute;
        bottom: 10px;
        left: 10px;
        width: 400px;
        height: 120px;
        background: rgba(0, 0, 0, 0.6);
        font-size: 12px;
        overflow: hidden;
        display: flex;
        flex-direction: column-reverse;
        pointer-events: none;
      }
      .log-msg {
        padding: 2px;
        border-bottom: 1px solid #333;
      }

      /* --- Explore Equipment Panel --- */
      #explore-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 350px;
        max-height: 600px;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #555;
        padding: 10px;
        overflow-y: auto;
        display: none;
        z-index: 100;
        pointer-events: auto;
      }
      #explore-panel.visible {
        display: block;
      }
      #explore-panel-toggle {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 101;
        pointer-events: auto;
        padding: 8px 12px;
        font-size: 12px;
      }
      .deck-list {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-top: 10px;
        max-height: 200px;
        overflow-y: auto;
      }
      .deck-card {
        background: #2a2a2a;
        border: 1px solid #555;
        padding: 4px 8px;
        border-radius: 3px;
        font-size: 11px;
        color: #fff;
      }
      .deck-card-name {
        font-weight: bold;
      }
      .deck-card-type {
        font-size: 9px;
        color: #aaa;
        text-transform: uppercase;
      }

      /* --- Battle Screen --- */
      #battle-screen {
        padding: 10px;
        background: #221;
      }
      #battle-area {
        flex: 1;
        display: flex;
        justify-content: space-between;
        padding: 40px;
        align-items: center;
      }

      .unit-display {
        text-align: center;
        width: 200px;
        position: relative;
      }
      .sprite {
        width: 100px;
        height: 100px;
        background: #444;
        margin: 0 auto 10px;
        border: 2px solid #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 40px;
        position: relative;
      }
      .sprite.enemy {
        border-color: #f55;
        background: #311;
      }

      .intent-icon {
        position: absolute;
        top: -30px;
        right: -10px;
        background: #222;
        border: 1px solid #fff;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 14px;
        color: #fff;
        min-width: 50px;
      }
      .intent-icon.atk {
        background: #a33;
        border-color: #f00;
      }
      .intent-icon.def {
        background: #33a;
        border-color: #00f;
      }
      .intent-icon.debuff {
        background: #333;
        border-color: #888;
      }

      .bar-bg {
        width: 100%;
        height: 10px;
        background: #333;
        margin: 2px 0;
      }
      .hp-fill {
        height: 100%;
        background: #d44;
        width: 100%;
        transition: width 0.3s;
      }
      .pos-fill {
        height: 100%;
        background: #eb2;
        width: 100%;
        transition: width 0.3s;
      }

      #p-blk-text {
        position: absolute;
        top: 15px;
        left: 15px;
        background: #007bff;
        color: #fff;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        border: 2px solid #fff;
        font-size: 16px;
      }

      #enemy-status {
        margin-top: 5px;
        min-height: 20px;
      }
      .status-badge {
        display: inline-block;
        padding: 2px 6px;
        margin-right: 5px;
        border-radius: 3px;
        font-size: 10px;
        color: #fff;
        font-weight: bold;
      }

      #hand-container {
        height: 180px;
        display: flex;
        justify-content: center;
        align-items: flex-end;
        gap: 10px;
        padding-bottom: 10px;
      }
      .card {
        width: 100px;
        height: 140px;
        background: #eee;
        color: #000;
        border-radius: 5px;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 5px;
        cursor: pointer;
        transition: 0.2s;
        position: relative;
        box-shadow: 0 5px 15px #000;
      }
      .card:hover {
        transform: translateY(-20px);
        z-index: 100;
      }
      .card-cost {
        position: absolute;
        top: -10px;
        left: -10px;
        width: 25px;
        height: 25px;
        background: #007bff;
        color: #fff;
        border-radius: 50%;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid #fff;
      }
      .card-type {
        font-size: 10px;
        color: #555;
        text-transform: uppercase;
        margin-bottom: 5px;
      }
      .card-name {
        font-weight: bold;
        font-size: 12px;
        text-align: center;
        margin-bottom: auto;
      }
      .card-desc {
        font-size: 10px;
        text-align: center;
      }
      .unplayable {
        filter: grayscale(1);
        opacity: 0.6;
        cursor: not-allowed;
      }
      /* ãƒªã‚¶ãƒ«ãƒˆç”»é¢ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
      #result-screen h1 {
        font-size: 60px;
        margin-bottom: 20px;
      }
      .result-stat {
        font-size: 24px;
        margin: 10px 0;
        color: #ddd;
      }
      .score-text {
        font-size: 40px;
        color: #ffd700; /* é‡‘è‰² */
        margin-top: 20px;
        font-weight: bold;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      }
      .game-over-text {
        font-size: 80px;
        color: #f00;
        font-family: "Courier New", monospace;
        text-shadow: 0 0 20px #f00;
      }
      /* --- è¿½åŠ ãƒ»ä¿®æ­£ CSS --- */

      /* Flux Gauge (ç†±é‡) */
      .flux-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 300px;
        text-align: center;
        z-index: 50;
        pointer-events: none; /* ã‚¯ãƒªãƒƒã‚¯ã‚’é‚ªé­”ã—ãªã„ */
        display: none; /* æˆ¦é—˜ä¸­ã®ã¿è¡¨ç¤º */
      }
      .flux-container.active {
        display: block;
      }

      .flux-bar-bg {
        width: 100%;
        height: 20px;
        background: #222;
        border: 2px solid #555;
        margin-top: 5px;
        position: relative;
      }
      .flux-fill {
        height: 100%;
        background: linear-gradient(90deg, #0af, #fa0, #f00);
        width: 0%;
        transition: width 0.1s linear;
      }
      .flux-danger {
        animation: pulse-red 0.5s infinite;
      }
      @keyframes pulse-red {
        0% {
          box-shadow: 0 0 5px #f00;
        }
        50% {
          box-shadow: 0 0 20px #f00;
        }
        100% {
          box-shadow: 0 0 5px #f00;
        }
      }

      /* AIS Probability Display (èª­ã¿åˆã„UI) */
      .ais-panel {
        position: absolute;
        top: 60px;
        right: 20px;
        width: 180px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #777;
        padding: 10px;
        font-size: 12px;
        color: #fff;
      }
      .ais-bar-row {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
      }
      .ais-label {
        width: 40px;
      }
      .ais-bar-track {
        flex: 1;
        height: 8px;
        background: #333;
        margin-left: 5px;
      }
      .ais-bar-val {
        height: 100%;
        background: #fff;
      }

      /* Command Slots (æ—§ãƒãƒ³ãƒ‰ã‚¨ãƒªã‚¢ã®åˆ·æ–°) */
      #command-container {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        width: 90%;
        justify-content: center;
        flex-wrap: wrap;
      }
      .cmd-btn {
        width: 80px;
        height: 100px;
        background: #333;
        border: 2px solid #555;
        color: #fff;
        font-size: 11px;
        position: relative;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 4px;
        transition: 0.1s;
      }
      .cmd-btn:hover {
        border-color: #fff;
        background: #444;
      }
      .cmd-btn.disabled {
        opacity: 0.4;
        pointer-events: none;
        filter: grayscale(1);
      }
      .cmd-btn.active-chain {
        border-color: #0ff;
        box-shadow: 0 0 10px #0ff;
      }

      .cmd-tag {
        font-size: 9px;
        color: #aaa;
        margin-bottom: 2px;
      }
      .cmd-flux {
        color: #f55;
        font-weight: bold;
      }
      .cmd-durability {
        position: absolute;
        bottom: 2px;
        right: 2px;
        font-size: 10px;
        color: #0f0;
      }
      .cmd-type-atk {
        border-top: 3px solid #d44;
      }
      .cmd-type-def {
        border-top: 3px solid #44d;
      }
      .cmd-type-skill {
        border-top: 3px solid #ea0;
      }

      /* Chain Mode Overlay */
      .chain-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
        pointer-events: none;
        z-index: 40;
        display: none;
        box-shadow: inset 0 0 50px #0ff;
      }
      .chain-overlay.active {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <!-- 1. TITLE SCREEN -->
      <div id="title-screen" class="screen">
        <h1 class="title-text">THREE DAYSâš”</h1>
        <p>Ver.38.2 - Craft Fix</p>
        <p>3æ—¥å¾Œã«å¯¾å³™ã™ã‚‹å·¨å¤§ãªæ•µã‚’å€’ã›ã€‚</p>
        <p>ãã‚Œã¾ã§ã«æ¢ç´¢ã€ã‚¯ãƒ©ãƒ•ãƒˆã‚’ç¹°ã‚Šè¿”ã—ã¦æº–å‚™ã›ã‚ˆã€‚</p>
        <button
          onclick="game.startNewGame()"
          style="font-size: 20px; padding: 15px 40px; margin-top: 20px"
        >
          START GAME
        </button>
      </div>

      <!-- 2. BASE SCREEN -->
      <div id="base-screen" class="screen">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
          "
        >
          <h2>æ‹ ç‚¹ (DAY <span id="base-day">1</span>)</h2>
          <div id="base-nav">
            <button onclick="game.startExplore()">æ¢ç´¢ã«å‡ºã‚‹</button>
            <button onclick="game.rest()">ä¼‘æ†© (æ¬¡ã®æ—¥ã«é€²ã‚€)</button>
          </div>
        </div>
        <div class="base-layout">
          <div class="panel">
            <h3>è£…å‚™</h3>
            <div id="loadout-list">
              <!-- Loadout items will be rendered here -->
            </div>
          </div>
          <div class="panel">
            <h3>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ & æ‰‹è·ç‰©</h3>
            <div style="padding: 10px">
              <p>
                HP: <span id="base-hp"></span>/<span id="base-maxhp"></span>
              </p>
              <p>ç´ æ: <span id="base-mats"></span></p>
              <p>ãƒ‡ãƒƒã‚­ã‚µã‚¤ã‚º: <span id="base-decksize"></span> æš</p>
              <p style="margin-top: 10px; color: #ffd700">
                æ‰‹è·ç‰©: <span id="inventory-count">0</span>/25
              </p>
            </div>
            <div
              style="
                margin-top: 20px;
                border-top: 1px solid #555;
                padding: 10px;
              "
            >
              <h4 style="margin: 0 0 10px 0; color: #ffd700">ãƒ‡ãƒƒã‚­</h4>
              <div id="base-deck-list" class="deck-list"></div>
            </div>
            <div
              style="
                margin-top: 20px;
                border-top: 1px solid #555;
                padding: 10px;
              "
            >
              <h4 style="margin: 0 0 10px 0; color: #ffd700">æ‰‹è·ç‰©</h4>
              <div
                id="inventory-list"
                style="max-height: 150px; overflow-y: auto"
              ></div>
            </div>
          </div>
          <div class="panel">
            <h3>å€‰åº«</h3>
            <div
              style="
                padding: 10px;
                font-size: 12px;
                color: #aaa;
                margin-bottom: 10px;
              "
            >
              ã“ã“ã«ä¿ç®¡ã—ãŸã‚‚ã®ã¯ã€æ¬¡å›èµ·å‹•æ™‚ã«ã‚‚ä¿æŒã•ã‚Œã¾ã™
            </div>
            <div
              id="storage-list"
              style="max-height: 400px; overflow-y: auto"
            ></div>
          </div>
        </div>
      </div>

      <!-- 3. EXPLORE SCREEN -->
      <div
        id="explore-screen"
        class="screen"
        style="justify-content: center; align-items: center"
      >
        <canvas id="dungeonCanvas" width="984" height="728"></canvas>
        <button id="explore-panel-toggle" onclick="game.toggleExplorePanel()">
          è£…å‚™ (E)
        </button>
        <div id="explore-ui">
          <div>å¼·åˆ¶å¸°é‚„ã¾ã§: <span id="exp-time">180</span>s</div>
          <div>
            HP: <span id="exp-hp"></span> | ã‚¹ã‚¿ãƒŸãƒŠ: <span id="exp-st"></span>
          </div>
          <div id="stealth-indicator">ã‚¹ãƒ†ãƒ«ã‚¹ãƒ¢ãƒ¼ãƒ‰ (Shift)</div>
        </div>
        <div id="explore-log"></div>
        <div id="explore-panel">
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 10px;
            "
          >
            <h3 style="margin: 0">è£…å‚™ & ãƒ‡ãƒƒã‚­</h3>
            <button
              onclick="game.toggleExplorePanel()"
              style="padding: 4px 8px; font-size: 11px"
            >
              Ã— Close
            </button>
          </div>
          <div
            style="
              margin-bottom: 10px;
              padding: 8px;
              background: rgba(255, 255, 255, 0.05);
              border-radius: 4px;
              font-size: 11px;
            "
          >
            <div><strong>ç´ æ:</strong> <span id="explore-mats"></span></div>
          </div>
          <div id="explore-loadout-list"></div>
          <div
            style="
              margin-top: 20px;
              border-top: 1px solid #555;
              padding-top: 10px;
            "
          >
            <h4 style="margin: 0 0 10px 0; color: #ffd700">ãƒ‡ãƒƒã‚­</h4>
            <div id="explore-deck-list" class="deck-list"></div>
          </div>
        </div>
      </div>

      <!-- 4. BATTLE SCREEN -->
      <div id="battle-screen" class="screen">
        <div style="text-align: right">
          <button onclick="battle.endTurn()" style="background: #c33">
            è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã™ã‚‹
          </button>
        </div>
        <div id="battle-area">
          <!-- PLAYER -->
          <div class="unit-display">
            <div class="sprite" style="border-color: #4f4; color: #4f4">
              ğŸ¤–
              <span id="p-blk-text">0</span>
            </div>
            <div>PLAYER</div>
            <div class="bar-bg"><div class="hp-fill" id="p-hp-bar"></div></div>
            <div>HP: <span id="p-hp-text"></span></div>
            <div style="color: #0ff; font-weight: bold; font-size: 20px">
              âš¡ <span id="p-en-text">3/3</span>
            </div>
            <div
              id="player-equipped"
              style="font-size: 11px; margin-top: 5px; color: #aaa"
            >
              W: <span id="p-eq-w" style="color: #fff"></span> | A:
              <span id="p-eq-a" style="color: #fff"></span>
            </div>
          </div>
          <!-- ENEMY -->
          <div class="unit-display">
            <div class="sprite enemy">
              ğŸ‘¾
              <div class="intent-icon" id="e-intent">?</div>
            </div>
            <div id="e-name">Enemy</div>
            <div class="bar-bg"><div class="hp-fill" id="e-hp-bar"></div></div>
            <div class="bar-bg">
              <div class="pos-fill" id="e-pos-bar"></div>
            </div>
            <div style="font-size: 15px; color: #ea0">ä½“å¹¹</div>
            <div id="enemy-status"></div>
          </div>
        </div>
        <div id="hand-container"></div>
        <div
          style="
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 12px;
            color: #888;
          "
        >
          å±±æœ­: <span id="deck-num">20</span> | æ‰‹æœ­:
          <span id="disc-num">0</span>
        </div>
      </div>
      <div
        id="result-screen"
        class="screen"
        style="justify-content: center; align-items: center; text-align: center"
      >
        <div id="result-content"></div>
        <button
          onclick="location.reload()"
          style="margin-top: 30px; padding: 10px 20px"
        >
          ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹
        </button>
      </div>
    </div>

    <script>
      /* --- 1. DATA DEFINITIONS --- */
      const CARDS = {
        punch: {
          name: "ãƒ‘ãƒ³ãƒ",
          cost: 1,
          type: "atk",
          val: 6,
          pos: 5,
          desc: "6 Dmg / 5 Posture",
        },
        guard: {
          name: "ã‚¬ãƒ¼ãƒ‰",
          cost: 1,
          type: "def",
          val: 5,
          desc: "Gain 5 Block",
        },
        focus: {
          name: "é›†ä¸­",
          cost: 1,
          type: "skill",
          val: 0,
          desc: "Draw 1 Card",
        },
        slash: {
          name: "æ–¬æ’ƒ",
          cost: 2,
          type: "atk",
          val: 14,
          pos: 8,
          desc: "14 Dmg / 8 Posture",
        },
        parry: {
          name: "ãƒ‘ãƒªã‚£",
          cost: 1,
          type: "def",
          val: 8,
          desc: "Gain 8 Block",
        },
        smash: {
          name: "ã‚¹ãƒãƒƒã‚·ãƒ¥",
          cost: 2,
          type: "atk",
          val: 20,
          pos: 25,
          desc: "20 Dmg, High Break",
        },
        bash: {
          name: "ãƒãƒƒã‚·ãƒ¥",
          cost: 1,
          type: "atk",
          val: 8,
          pos: 15,
          desc: "8 Dmg, Medium Break",
        },
        snipe: {
          name: "ç‹™æ’ƒ",
          cost: 2,
          type: "atk",
          val: 18,
          pos: 2,
          desc: "18 Dmg / Low Posture",
        },
        mark: {
          name: "ç…§æº–",
          cost: 1,
          type: "skill",
          status: "mark",
          val: 3,
          desc: "MARK (1.5x Dmg)",
        },
        dodge: {
          name: "ãƒ€ãƒƒã‚·ãƒ¥",
          cost: 1,
          type: "def",
          val: 6,
          desc: "6 Block + Draw 1",
        },
        brace: {
          name: "ãƒ–ãƒ¬ãƒ¼ã‚¹",
          cost: 2,
          type: "def",
          val: 15,
          desc: "15 Block",
        },
        clunk: {
          name: "ã‚¯ãƒ©ãƒ³ã‚¯",
          cost: 1,
          type: "curse",
          val: 0,
          desc: "Useless",
        },
        stim: {
          name: "ã‚¹ã‚¿ãƒŸãƒŠãƒ‘ãƒƒã‚¯",
          cost: 0,
          type: "skill",
          status: "energy",
          val: 1,
          desc: "Gain 1 Energy",
          exhaust: true,
        },
        decoy: {
          name: "èª˜å°å™¨",
          cost: 1,
          type: "skill",
          status: "stun",
          val: 1,
          desc: "Stun 1 turn",
          exhaust: true,
        },
      };

      const WEAPONS = {
        sword: {
          name: "å‰£",
          cards: [
            "slash",
            "slash",
            "slash",
            "slash",
            "parry",
            "parry",
            "parry",
            "punch",
            "punch",
            "focus",
          ],
          type: "w",
          noise: 0,
          craft_cost: { scrap: 2 },
        },
        hammer: {
          name: "ãƒãƒ³ãƒãƒ¼",
          cards: [
            "smash",
            "smash",
            "bash",
            "bash",
            "bash",
            "bash",
            "guard",
            "guard",
            "clunk",
            "clunk",
          ],
          type: "w",
          noise: 2,
          craft_cost: { scrap: 3 },
        },
        sniper: {
          name: "ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼",
          cards: [
            "snipe",
            "snipe",
            "snipe",
            "mark",
            "mark",
            "mark",
            "mark",
            "punch",
            "guard",
            "focus",
          ],
          type: "w",
          noise: 1,
          craft_cost: { chip: 2 },
        },
      };
      const ARMORS = {
        light: {
          name: "è»½è£…ç”²",
          cards: [
            "dodge",
            "dodge",
            "dodge",
            "dodge",
            "guard",
            "guard",
            "guard",
            "focus",
          ],
          type: "a",
          noise: 0,
          craft_cost: { chip: 1 },
        },
        heavy: {
          name: "é‡è£…ç”²",
          cards: [
            "brace",
            "brace",
            "brace",
            "guard",
            "guard",
            "guard",
            "clunk",
            "clunk",
          ],
          type: "a",
          noise: 2,
          craft_cost: { scrap: 2 },
        },
      };
      const GADGETS = {
        none: {
          name: "ãªã—",
          cards: ["focus", "focus"],
          type: "g",
          noise: 0,
          craft_cost: {},
        },
        stim: {
          name: "ã‚¹ã‚¿ãƒŸãƒŠãƒ‘ãƒƒã‚¯",
          cards: ["stim", "stim"],
          type: "g",
          noise: -1,
          craft_cost: { herb: 1 },
        },
        decoy: {
          name: "èª˜å°å™¨",
          cards: ["decoy", "decoy"],
          type: "g",
          noise: 0,
          craft_cost: { chip: 1 },
        },
      };

      const ENEMY_INTENTS = {
        ATTACK: {
          name: "æ”»æ’ƒ",
          icon: "âš”ï¸",
          css: "atk",
          dmg: 10,
          posRegen: 10,
        },
        DEFEND: {
          name: "é˜²å¾¡",
          icon: "ğŸ›¡ï¸",
          css: "def",
          block: 8,
          posRegen: 5,
        },
        DEBUFF: {
          name: "ãƒ‡ãƒãƒ•",
          icon: "ğŸ’€",
          css: "debuff",
          effect: "WEAK",
          posRegen: 0,
        },
      };

      /* --- 2. GAME ENGINE --- */
      const game = {
        state: "INIT",
        day: 1,
        player: {
          hp: 100,
          maxHp: 100,
          stamina: 100,
          maxStamina: 100,
          playerBlock: 0,
          loadout: { weapon: "sword", armor: "light", gadget: "none" },
          mats: { scrap: 5, chip: 2, herb: 1, data: 0 },
          unlocked: { weapon: ["sword"], armor: ["light"], gadget: ["none"] },
          inventory: [], // æ¢ç´¢ä¸­ã®æ‰€æŒå“ï¼ˆæœ€å¤§25å€‹ï¼‰
        },
        storage: {
          materials: { scrap: 0, chip: 0, herb: 0, data: 0 },
          equipment: [], // ä¿ç®¡åº«ã®è£…å‚™ãƒªã‚¹ãƒˆ
        },
        MAX_INVENTORY_SIZE: 25,

        init() {
          this.loadStorage(); // ä¿ç®¡åº«ã‚’èª­ã¿è¾¼ã¿
          this.showScreen("title-screen");
        },
        // ä¿ç®¡åº«ã‚’localStorageã‹ã‚‰èª­ã¿è¾¼ã¿
        loadStorage() {
          const saved = localStorage.getItem("dustfall_storage");
          if (saved) {
            try {
              this.storage = JSON.parse(saved);
            } catch (e) {
              console.error("Failed to load storage:", e);
            }
          }
        },
        // ä¿ç®¡åº«ã‚’localStorageã«ä¿å­˜
        saveStorage() {
          try {
            localStorage.setItem(
              "dustfall_storage",
              JSON.stringify(this.storage)
            );
          } catch (e) {
            console.error("Failed to save storage:", e);
          }
        },
        // æ‰€æŒå“æ•°ã®è¨ˆç®—
        getInventoryCount() {
          let count = 0;
          // ç´ æã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
          for (const [mat, amount] of Object.entries(this.player.mats)) {
            count += amount;
          }
          // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªå†…ã®è£…å‚™æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
          count += this.player.inventory.length;
          return count;
        },
        showScreen(id) {
          document
            .querySelectorAll(".screen")
            .forEach((el) => el.classList.remove("active"));
          const target = document.getElementById(id);
          if (target) target.classList.add("active");
        },
        startNewGame() {
          this.day = 1;
          this.player.hp = 100;
          this.updateBaseUI();
          this.showScreen("base-screen");
          this.state = "BASE";
        },
        startExplore() {
          try {
            dungeon.init(this.day);
            this.showScreen("explore-screen");
            this.state = "EXPLORE";
            dungeon.start();
          } catch (error) {
            console.error("Error in startExplore:", error);
            alert("ãƒãƒƒãƒ—ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: " + error.message);
          }
        },
        rest() {
          this.day++;
          this.player.hp = this.player.maxHp;
          this.updateBaseUI();
          alert(`ä¼‘æ†©ã‚’çµ‚ãˆã¾ã—ãŸã€‚DAY ${this.day} ãŒå§‹ã¾ã‚Šã¾ã™ã€‚`);
        },
        // rest() ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸‹ã‚ãŸã‚Šã«è¿½åŠ ã˜ã‚ƒ
        startBossBattle() {
          if (!confirm("æº–å‚™ã¯ã„ã„ã‹ï¼Ÿ ã“ã‚ŒãŒæœ€å¾Œã®æˆ¦ã„ã ã€‚")) return;

          // ãƒœã‚¹ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å®šç¾©ï¼ˆã‹ãªã‚Šå¼·ãè¨­å®šã™ã‚‹ãï¼‰
          const boss = {
            hp: 300, // é€šå¸¸æ•µã®3å€
            maxHp: 300,
            pos: 200, // ä½“å¹¹ã‚‚å¼·ã„
            maxPos: 200,
            isBroken: false,
            brokenTurns: 0,
            enemyBlock: 0,
            status: { mark: 0 },
            nextIntent: null,
            // ãƒœã‚¹å°‚ç”¨ã®ç‰¹åˆ¥ãªãƒ•ãƒ©ã‚°ã‚„åå‰ã‚’æŒãŸã›ã¦ã‚‚ã‚ˆã„ãŒã€ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«
            // åå‰è¡¨ç¤ºãªã©ã¯ battle.updateUI ã§ "Enemy" ã¨ãªã‚‹ãŒã€å¾Œã§å¤‰ãˆã‚‹ã“ã¨ã‚‚å¯èƒ½
          };

          // çŠ¶æ…‹ã‚’BATTLEã«å¤‰æ›´
          this.state = "BATTLE";
          dungeon.stop(); // å¿µã®ãŸã‚ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚¿ã‚¤ãƒãƒ¼åœæ­¢
          battle.isBossBattle = true;
          // æˆ¦é—˜é–‹å§‹ï¼
          // ç¬¬1å¼•æ•°ã¯ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ä¸Šã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã ãŒã€ãƒœã‚¹ã¯ãƒãƒƒãƒ—ã«ã„ãªã„ã®ã§ null ã‚’æ¸¡ã™
          // ç¬¬2å¼•æ•°ã¯å¥‡è¥²ãƒ•ãƒ©ã‚°ã€‚ãƒœã‚¹æˆ¦ã§å¥‡è¥²ã¯ã§ããªã„ã®ã§ false
          battle.start(null, false);

          // battle.startã®ä¸­ã§ä½œã‚‰ã‚Œã‚‹ this.enemy ã‚’ãƒœã‚¹ãƒ‡ãƒ¼ã‚¿ã§ä¸Šæ›¸ãã™ã‚‹
          // (battle.start ã¯é€šå¸¸ã®æ•µHP100ã§ä½œã£ã¦ã—ã¾ã†ãŸã‚)
          battle.enemy = boss;
          battle.selectIntent(); // ãƒœã‚¹ã®æœ€åˆã®è¡Œå‹•ã‚’æ±ºå®š

          // ç”»é¢åˆ‡ã‚Šæ›¿ãˆ
          this.showScreen("battle-screen");

          // ãƒœã‚¹æˆ¦ã§ã‚ã‚‹ã“ã¨ã‚’ãƒ­ã‚°ã«å‡ºã™
          this.log("âš ï¸ BOSS BATTLE START âš ï¸");
        },
        returnToDungeon(enemyKilled) {
          this.log(enemyKilled ? "æ•µã‚’å€’ã—ã¾ã—ãŸï¼" : "æˆ¦é—˜ã‹ã‚‰é€ƒã‚Œã¾ã—ãŸã€‚");
          this.player.playerBlock = 0;
          this.showScreen("explore-screen");
          this.state = "EXPLORE";
          dungeon.start();
        },
        returnToBase(success) {
          dungeon.stop();
          this.day++;
          if (!success) {
            this.player.hp = Math.max(1, this.player.hp * 0.1);
            alert(
              `å¼·åˆ¶å¸°é‚„ã€‚ç¾åœ¨ã®æ‰‹è·ç‰©ã¯å…¨ã¦å–ªå¤±ã—ã¾ã™ã€‚\n(DAY ${this.day} ã«ãªã‚Šã¾ã—ãŸ)`
            );
          } else {
            alert(`å®‰å…¨ã«å¸°é‚„ã—ã¾ã—ãŸã€‚\n(DAY ${this.day} ã«ãªã‚Šã¾ã—ãŸ)`);
          }
          this.player.playerBlock = 0;
          this.updateBaseUI();
          this.showScreen("base-screen");
          this.state = "BASE";
        },
        log(message) {
          const logEl = document.getElementById("explore-log");
          if (logEl) {
            const msgEl = document.createElement("div");
            msgEl.className = "log-msg";
            msgEl.innerText = message;
            logEl.prepend(msgEl);
            while (logEl.children.length > 20)
              logEl.removeChild(logEl.lastChild);
          }
        },
        buyAndEquip(itemKey, type, itemCost) {
          // ä¿®æ­£ç‚¹: itemCost (craft_cost) ã‚’æ­£ã—ããƒã‚§ãƒƒã‚¯
          // æ¢ç´¢ä¸­ã®ç´ æã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆä¿ç®¡åº«ã®ç´ æã¯ä½¿ç”¨ä¸å¯ï¼‰
          for (const [mat, amount] of Object.entries(itemCost)) {
            if (this.player.mats[mat] < amount) {
              alert("è³‡æãŒè¶³ã‚Šãªã„ã€‚\n(ä¿ç®¡åº«ã®ç´ æã¯æ¢ç´¢ä¸­ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“)");
              return false;
            }
          }
          for (const [mat, amount] of Object.entries(itemCost)) {
            this.player.mats[mat] -= amount;
          }

          // æ—¢ã«ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¸ˆã¿ã§ãªã„å ´åˆã®ã¿è¿½åŠ 
          if (!this.player.unlocked[type].includes(itemKey)) {
            this.player.unlocked[type].push(itemKey);
          }
          this.player.loadout[type] = itemKey; // è£…å‚™æ›´æ–°
          this.updateBaseUI();
          // æ¢ç´¢ä¸­ã®å ´åˆã€ãƒ‘ãƒãƒ«ã‚‚æ›´æ–°
          if (this.state === "EXPLORE") {
            this.updateExplorePanel();
          }
          this.log(`ã€${itemKey}ã€‘ã‚’ä½œæˆã—ã€è£…å‚™ã—ãŸã€‚`);
          return true;
        },
        buildDeck() {
          const l = this.player.loadout;
          const deck = [];
          deck.push(...WEAPONS[l.weapon].cards);
          deck.push(...ARMORS[l.armor].cards);
          deck.push(...GADGETS[l.gadget].cards);
          return deck;
        },
        renderDeckList(containerId) {
          const container = document.getElementById(containerId);
          if (!container) return;
          container.innerHTML = "";
          const deck = this.buildDeck();
          const cardCounts = {};
          deck.forEach((cardId) => {
            cardCounts[cardId] = (cardCounts[cardId] || 0) + 1;
          });
          Object.keys(cardCounts).forEach((cardId) => {
            const card = CARDS[cardId];
            const count = cardCounts[cardId];
            const el = document.createElement("div");
            el.className = "deck-card";
            el.innerHTML = `<div class="deck-card-name">${card.name}${
              count > 1 ? ` x${count}` : ""
            }</div><div class="deck-card-type">${card.type}</div>`;
            container.appendChild(el);
          });
        },
        renderLoadoutList(listElement, onUpdate) {
          listElement.innerHTML = "";

          // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šè¦‹å‡ºã—ã‚’è¿½åŠ 
          const addHeader = (text) => {
            const h3 = document.createElement("h3");
            h3.textContent = text;
            h3.style.fontSize = "14px";
            h3.style.marginTop = "10px";
            listElement.appendChild(h3);
          };

          const renderCat = (db, currentKey, type) => {
            Object.keys(db).forEach((key) => {
              const item = db[key];
              const isEq = currentKey === key;
              const isUnlocked = this.player.unlocked[type].includes(key);
              let canAfford = true;
              if (item.craft_cost && !isUnlocked) {
                for (const [mat, amount] of Object.entries(item.craft_cost)) {
                  if (this.player.mats[mat] < amount) {
                    canAfford = false;
                    break;
                  }
                }
              }
              let statusText = isEq
                ? "âœ“ è£…å‚™ä¸­"
                : isUnlocked
                ? "è£…å‚™ã™ã‚‹"
                : canAfford
                ? "ä½œæˆã™ã‚‹"
                : "ä½œæˆä¸å¯èƒ½";
              let statusClass = isEq
                ? "equipped"
                : isUnlocked
                ? ""
                : canAfford
                ? "item-buyable"
                : "locked";
              const costDisplay =
                !isUnlocked && item.craft_cost
                  ? ` (${Object.entries(item.craft_cost)
                      .map(([k, v]) => `${v} ${k}`)
                      .join(", ")})`
                  : "";

              const el = document.createElement("div");
              el.className = `item-row ${statusClass}`;
              el.style.fontSize = "12px";
              el.innerHTML = `<span>${item.name}</span><span class="item-cost">${costDisplay}</span><span>${statusText}</span>`;
              el.onclick = () => {
                if (isEq) return;
                if (isUnlocked) {
                  this.player.loadout[type] = key;
                  if (onUpdate) onUpdate();
                  this.log(`Equipped ${item.name}`);
                } else if (canAfford) {
                  this.buyAndEquip(key, type, item.craft_cost);
                  if (onUpdate) onUpdate();
                }
              };
              listElement.appendChild(el);
            });
          };

          addHeader("- æ­¦å™¨ -");
          renderCat(WEAPONS, this.player.loadout.weapon, "weapon");
          addHeader("- é˜²å…· -");
          renderCat(ARMORS, this.player.loadout.armor, "armor");
          addHeader("- ã‚¢ãƒ“ãƒªãƒ†ã‚£ -");
          renderCat(GADGETS, this.player.loadout.gadget, "gadget");
        },
        toggleExplorePanel() {
          const panel = document.getElementById("explore-panel");
          if (panel) {
            panel.classList.toggle("visible");
            if (panel.classList.contains("visible")) {
              this.updateExplorePanel();
            }
          }
        },
        updateExplorePanel() {
          const list = document.getElementById("explore-loadout-list");
          if (list) {
            this.renderLoadoutList(list, () => {
              this.updateExplorePanel();
            });
          }
          this.renderDeckList("explore-deck-list");

          // ç´ ææƒ…å ±ã‚’æ›´æ–°
          const matsEl = document.getElementById("explore-mats");
          if (matsEl) {
            const m = this.player.mats;
            matsEl.innerText = `Scrap:${m.scrap} Chip:${m.chip} Herb:${m.herb} Data:${m.data}`;
          }
        },
        updateBaseUI() {
          document.getElementById("base-day").innerText = this.day;
          document.getElementById("base-hp").innerText = this.player.hp;
          document.getElementById("base-maxhp").innerText = this.player.maxHp;
          const m = this.player.mats;
          document.getElementById(
            "base-mats"
          ).innerText = `Scrap:${m.scrap} Chip:${m.chip} Herb:${m.herb} Data:${m.data}`;
          document.getElementById("base-decksize").innerText =
            this.buildDeck().length;

          const nav = document.getElementById("base-nav");
          if (nav) {
            // DAYãŒ4ä»¥ä¸Šï¼ˆ3æ—¥ç›®ã®æ¢ç´¢çµ‚äº†å¾Œï¼‰ãªã‚‰ã€ãƒœã‚¹æˆ¦ãƒ¢ãƒ¼ãƒ‰ã¸
            if (this.day > 3) {
              nav.innerHTML = `
                <button 
                  onclick="game.startBossBattle()" 
                  style="background: #c3073f; border-color: #f00; width: 100%; font-size: 18px; font-weight: bold;">
                  âš ï¸ æ±ºæˆ¦ã«æŒ‘ã‚€ (FINAL BATTLE) âš ï¸
                </button>
              `;
            } else {
              // é€šå¸¸æ™‚ã¯ã„ã¤ã‚‚ã®ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
              nav.innerHTML = `
                <button onclick="game.startExplore()">æ¢ç´¢ã«å‡ºã‚‹</button>
                <button onclick="game.rest()">ä¼‘æ†© (æ¬¡ã®æ—¥ã«é€²ã‚€)</button>
              `;
            }
          }

          // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªæ•°ã®è¡¨ç¤º
          const invCount = this.getInventoryCount();
          const invCountEl = document.getElementById("inventory-count");
          if (invCountEl) invCountEl.innerText = invCount;

          const list = document.getElementById("loadout-list");
          if (list) {
            this.renderLoadoutList(list, () => {
              this.updateBaseUI();
            });
          }
          this.renderDeckList("base-deck-list");

          // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã¨ä¿ç®¡åº«ã®è¡¨ç¤º
          this.renderInventory();
          this.renderStorage();
        },
        // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã®è¡¨ç¤º
        renderInventory() {
          const container = document.getElementById("inventory-list");
          if (!container) return;
          container.innerHTML = "";

          // ç´ æã‚’è¡¨ç¤º
          const matTypes = ["scrap", "chip", "herb", "data"];
          matTypes.forEach((mat) => {
            const amount = this.player.mats[mat] || 0;
            if (amount > 0) {
              const el = document.createElement("div");
              el.className = "item-row";
              el.style.fontSize = "12px";
              el.innerHTML = `<span>${mat.toUpperCase()}: ${amount}</span><button onclick="game.moveToStorage('${mat}', ${amount})" style="padding: 2px 6px; font-size: 10px;">â†’ Storage</button>`;
              container.appendChild(el);
            }
          });

          // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªå†…ã®è£…å‚™ã‚’è¡¨ç¤ºï¼ˆç¾åœ¨ã¯è£…å‚™ã‚’ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«ä¿å­˜ã™ã‚‹æ©Ÿèƒ½ãŒãªã„ãŸã‚ã€å°†æ¥ã®æ‹¡å¼µç”¨ï¼‰
          if (this.player.inventory.length > 0) {
            this.player.inventory.forEach((item, idx) => {
              const el = document.createElement("div");
              el.className = "item-row";
              el.style.fontSize = "12px";
              el.innerHTML = `<span>${
                item.name || item
              }</span><button onclick="game.moveToStorage('equip', ${idx})" style="padding: 2px 6px; font-size: 10px;">â†’ Storage</button>`;
              container.appendChild(el);
            });
          }

          if (container.children.length === 0) {
            container.innerHTML =
              '<div style="color: #666; font-size: 11px; padding: 5px;">Empty</div>';
          }
        },
        // ä¿ç®¡åº«ã®è¡¨ç¤º
        renderStorage() {
          const container = document.getElementById("storage-list");
          if (!container) return;
          container.innerHTML = "";

          // ä¿ç®¡åº«ã®ç´ æã‚’è¡¨ç¤º
          const matTypes = ["scrap", "chip", "herb", "data"];
          matTypes.forEach((mat) => {
            const amount = this.storage.materials[mat] || 0;
            if (amount > 0) {
              const el = document.createElement("div");
              el.className = "item-row";
              el.style.fontSize = "12px";
              el.innerHTML = `<span>${mat.toUpperCase()}: ${amount}</span><div><button onclick="game.moveFromStorage('${mat}', 1)" style="padding: 2px 6px; font-size: 10px; margin-right: 2px;">â† 1</button><button onclick="game.takeFromStorage('${mat}')" style="padding: 2px 6px; font-size: 10px;">â† All</button></div>`;
              container.appendChild(el);
            }
          });

          // ä¿ç®¡åº«ã®è£…å‚™ã‚’è¡¨ç¤º
          if (this.storage.equipment && this.storage.equipment.length > 0) {
            this.storage.equipment.forEach((item, idx) => {
              const el = document.createElement("div");
              el.className = "item-row";
              el.style.fontSize = "12px";
              el.innerHTML = `<span>${
                item.name || item
              }</span><button onclick="game.moveFromStorage('equip', ${idx})" style="padding: 2px 6px; font-size: 10px;">â† Take</button>`;
              container.appendChild(el);
            });
          }

          if (container.children.length === 0) {
            container.innerHTML =
              '<div style="color: #666; font-size: 11px; padding: 5px;">Empty</div>';
          }
        },
        // ç´ æã‚’ä¿ç®¡åº«ã«ç§»å‹•
        moveToStorage(type, amountOrIndex) {
          if (type === "equip") {
            // è£…å‚™ã‚’ä¿ç®¡åº«ã«ç§»å‹•ï¼ˆå°†æ¥ã®æ‹¡å¼µç”¨ï¼‰
            if (this.player.inventory[amountOrIndex]) {
              this.storage.equipment.push(this.player.inventory[amountOrIndex]);
              this.player.inventory.splice(amountOrIndex, 1);
              this.saveStorage();
              this.updateBaseUI();
            }
          } else {
            // ç´ æã‚’ä¿ç®¡åº«ã«ç§»å‹•
            const amount = Math.min(amountOrIndex, this.player.mats[type] || 0);
            if (amount > 0) {
              this.player.mats[type] -= amount;
              this.storage.materials[type] =
                (this.storage.materials[type] || 0) + amount;
              this.saveStorage();
              this.updateBaseUI();
            }
          }
        },
        // ä¿ç®¡åº«ã‹ã‚‰ç´ æã‚’å–ã‚Šå‡ºã™
        moveFromStorage(type, amountOrIndex) {
          if (type === "equip") {
            // è£…å‚™ã‚’å–ã‚Šå‡ºã™ï¼ˆæ‰€æŒå“æ•°ã®ãƒã‚§ãƒƒã‚¯ï¼‰
            if (this.getInventoryCount() >= this.MAX_INVENTORY_SIZE) {
              alert("æ‰‹è·ç‰©ãŒä¸€æ¯ã§ã™ã€‚(æœ€å¤§25å€‹)");
              return;
            }
            if (this.storage.equipment[amountOrIndex]) {
              this.player.inventory.push(this.storage.equipment[amountOrIndex]);
              this.storage.equipment.splice(amountOrIndex, 1);
              this.saveStorage();
              this.updateBaseUI();
            }
          } else {
            // ç´ æã‚’å–ã‚Šå‡ºã™ï¼ˆæ‰€æŒå“æ•°ã®ãƒã‚§ãƒƒã‚¯ï¼‰
            const available = this.storage.materials[type] || 0;
            if (available === 0) return;

            const currentInvCount = this.getInventoryCount();
            const spaceAvailable = this.MAX_INVENTORY_SIZE - currentInvCount;
            if (spaceAvailable <= 0) {
              alert("æ‰‹è·ç‰©ãŒä¸€æ¯ã§ã™ã€‚(æœ€å¤§25å€‹)");
              return;
            }

            // å…¨éƒ¨å–ã‚Šå‡ºã™ã‹ã€ä¸€éƒ¨ã ã‘å–ã‚Šå‡ºã™ã‹ã‚’é¸æŠ
            const takeAmount = Math.min(
              amountOrIndex,
              available,
              spaceAvailable
            );
            if (takeAmount > 0) {
              this.storage.materials[type] -= takeAmount;
              this.player.mats[type] =
                (this.player.mats[type] || 0) + takeAmount;
              this.saveStorage();
              this.updateBaseUI();
            }
          }
        },
        // ä¿ç®¡åº«ã‹ã‚‰ç´ æã‚’ä¸€éƒ¨å–ã‚Šå‡ºã™ï¼ˆãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§æ•°é‡å…¥åŠ›ï¼‰
        takeFromStorage(type) {
          const available = this.storage.materials[type] || 0;
          if (available === 0) return;

          const currentInvCount = this.getInventoryCount();
          const spaceAvailable = this.MAX_INVENTORY_SIZE - currentInvCount;
          if (spaceAvailable <= 0) {
            alert("æ‰‹è·ç‰©ãŒä¸€æ¯ã§ã™ã€‚(æœ€å¤§25å€‹)");
            return;
          }

          const maxTake = Math.min(available, spaceAvailable);
          const input = prompt(
            `How many ${type.toUpperCase()} to take? (Available: ${available}, Space: ${spaceAvailable})`,
            maxTake
          );
          if (input === null) return;

          const takeAmount = parseInt(input);
          if (isNaN(takeAmount) || takeAmount <= 0 || takeAmount > maxTake) {
            alert("Invalid amount!");
            return;
          }

          this.storage.materials[type] -= takeAmount;
          this.player.mats[type] = (this.player.mats[type] || 0) + takeAmount;
          this.saveStorage();
          this.updateBaseUI();
        },
        enterBattle(enemy, isAmbush) {
          dungeon.stop();
          this.state = "BATTLE";
          battle.start(enemy, isAmbush);
          this.showScreen("battle-screen");
        },
        // ... gameã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸­ã«è¿½åŠ  ...

        // ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯
        calculateScore(turns) {
          const hpBonus = this.player.hp * 20;
          // 50ã‚¿ãƒ¼ãƒ³ã‚’åŸºæº–ã«ã€æ—©ã‘ã‚Œã°æ—©ã„ã»ã©é«˜å¾—ç‚¹ï¼ˆãƒã‚¤ãƒŠã‚¹ã«ã¯ã—ãªã„ï¼‰
          const speedBonus = Math.max(0, (50 - turns) * 30);
          // æ‰€æŒã—ã¦ã„ã‚‹ç´ æã®ç·
          return hpBonus + speedBonus;
        },

        // ãƒªã‚¶ãƒ«ãƒˆç”»é¢ã‚’è¡¨ç¤ºã™ã‚‹å‡¦ç†
        showResult(isWin, turns) {
          const container = document.getElementById("result-content");

          if (isWin) {
            // å‹åˆ©æ™‚ï¼šè©³ç´°ã‚’è¡¨ç¤º
            const score = this.calculateScore(turns);
            container.innerHTML = `
              <h1 style="color: #4f4;">GAME CLEAR</h1>
              <div class="result-stat">æ’ƒç ´ã‚¿ãƒ¼ãƒ³æ•°: <strong>${turns}</strong></div>
              <div class="result-stat">æ®‹ã‚ŠHP: <strong>${this.player.hp}</strong></div>
              <div class="score-text">ç·åˆãƒã‚¤ãƒ³ãƒˆ: ${score}ç‚¹</div>
            `;
          } else {
            // æ•—åŒ—æ™‚ï¼šã‚·ãƒ³ãƒ—ãƒ«ã«GAME OVER
            container.innerHTML = `
              <div class="game-over-text">GAME OVER</div>
            `;
          }

          this.showScreen("result-screen");
        },
      };

      /* --- 3. DUNGEON LOGIC --- */
      const MAP_WIDTH = 50;
      const MAP_HEIGHT = 50;
      const TILE_SIZE = 15;
      const dungeon = {
        canvas: null,
        ctx: null,
        gridX: MAP_WIDTH,
        gridY: MAP_HEIGHT,
        tile: TILE_SIZE,
        map: [],
        entities: [],
        p: { x: 1, y: 1 },
        timer: null,
        timeLeft: 180,
        lastTime: 0,
        enemyMoveTimer: 0,
        init(difficulty) {
          this.canvas = document.getElementById("dungeonCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.map = [];
          for (let y = 0; y < this.gridY; y++) {
            let row = [];
            for (let x = 0; x < this.gridX; x++) row.push(1);
            this.map.push(row);
          }

          // Room-and-Corridor æ–¹å¼ã®ãƒãƒƒãƒ—ç”Ÿæˆ
          const rooms = [];
          const minRoomSize = 4;
          const maxRoomSize = 8;
          const roomAttempts = 50;

          // 1. éƒ¨å±‹ã‚’ç”Ÿæˆ
          for (let i = 0; i < roomAttempts; i++) {
            const width =
              minRoomSize +
              Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1));
            const height =
              minRoomSize +
              Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1));

            // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
            const maxX = Math.max(2, this.gridX - width - 4);
            const maxY = Math.max(2, this.gridY - height - 4);
            if (maxX <= 2 || maxY <= 2) continue; // ãƒãƒƒãƒ—ãŒå°ã•ã™ãã‚‹å ´åˆã‚¹ã‚­ãƒƒãƒ—

            const x = 2 + Math.floor(Math.random() * (maxX - 2));
            const y = 2 + Math.floor(Math.random() * (maxY - 2));

            // ä»–ã®éƒ¨å±‹ã¨é‡ãªã£ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
            let overlaps = false;
            for (const room of rooms) {
              if (
                x < room.x + room.width + 2 &&
                x + width + 2 > room.x &&
                y < room.y + room.height + 2 &&
                y + height + 2 > room.y
              ) {
                overlaps = true;
                break;
              }
            }

            if (!overlaps) {
              rooms.push({ x, y, width, height });
              // éƒ¨å±‹ã‚’æç”»ï¼ˆå£ã‚’å«ã‚ã¦ï¼‰
              for (let ry = y; ry < y + height; ry++) {
                for (let rx = x; rx < x + width; rx++) {
                  if (
                    ry >= 1 &&
                    ry < this.gridY - 1 &&
                    rx >= 1 &&
                    rx < this.gridX - 1
                  ) {
                    this.map[ry][rx] = 0;
                  }
                }
              }
            }
          }

          // 2. éƒ¨å±‹åŒå£«ã‚’é€šè·¯ã§ç¹‹ãï¼ˆMinimum Spanning Treeé¢¨ï¼‰
          if (rooms.length > 1) {
            // å„éƒ¨å±‹ã®ä¸­å¿ƒç‚¹ã‚’è¨ˆç®—
            const centers = rooms.map((room) => ({
              x: Math.floor(room.x + room.width / 2),
              y: Math.floor(room.y + room.height / 2),
            }));

            // è¿‘ã„éƒ¨å±‹åŒå£«ã‚’ç¹‹ãï¼ˆå…¨ãƒšã‚¢ã§ã¯ãªãã€è¿‘ã„ã‚‚ã®ã ã‘ï¼‰
            for (let i = 0; i < centers.length - 1; i++) {
              // æœ€ã‚‚è¿‘ã„éƒ¨å±‹ã‚’æ¢ã™
              let closestIdx = i + 1;
              let closestDist = Infinity;
              for (let j = i + 1; j < centers.length; j++) {
                const dist =
                  Math.abs(centers[i].x - centers[j].x) +
                  Math.abs(centers[i].y - centers[j].y);
                if (dist < closestDist) {
                  closestDist = dist;
                  closestIdx = j;
                }
              }

              // é€šè·¯ã‚’ä½œã‚‹ï¼ˆå¹…1ãƒã‚¹ã€Lå­—å‹ï¼‰
              this.createLShapedCorridor(
                centers[i].x,
                centers[i].y,
                centers[closestIdx].x,
                centers[closestIdx].y
              );
            }

            // è¿½åŠ ã®é€šè·¯ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«è¿½åŠ ï¼ˆåˆ†å²ç‚¹ã‚’å¢—ã‚„ã™ã€ä¸€éƒ¨ã¯å¹…2ãƒã‚¹ï¼‰
            for (let i = 0; i < Math.floor(rooms.length / 3); i++) {
              const r1 = Math.floor(Math.random() * centers.length);
              const r2 = Math.floor(Math.random() * centers.length);
              if (r1 !== r2) {
                // 30%ã®ç¢ºç‡ã§å¹…2ãƒã‚¹ã€ãã‚Œä»¥å¤–ã¯1ãƒã‚¹
                if (Math.random() < 0.3) {
                  this.createCorridor(
                    centers[r1].x,
                    centers[r1].y,
                    centers[r2].x,
                    centers[r2].y,
                    1.5
                  );
                } else {
                  this.createLShapedCorridor(
                    centers[r1].x,
                    centers[r1].y,
                    centers[r2].x,
                    centers[r2].y
                  );
                }
              }
            }
          }

          // 3. ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã¨ã‚´ãƒ¼ãƒ«åœ°ç‚¹ã‚’è¨­å®š
          this.startRoom = null; // ã‚¹ã‚¿ãƒ¼ãƒˆéƒ¨å±‹ã‚’ä¿å­˜ï¼ˆæ•µã®ã‚¹ãƒãƒ¼ãƒ³ã‚’é¿ã‘ã‚‹ãŸã‚ï¼‰
          if (rooms.length > 0) {
            // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ï¼ˆæœ€åˆã®éƒ¨å±‹ï¼‰
            const startRoom = rooms[0];
            this.startRoom = startRoom; // ã‚¹ã‚¿ãƒ¼ãƒˆéƒ¨å±‹ã‚’ä¿å­˜
            this.p = {
              x: Math.floor(startRoom.x + startRoom.width / 2),
              y: Math.floor(startRoom.y + startRoom.height / 2),
            };

            // ã‚´ãƒ¼ãƒ«åœ°ç‚¹ï¼ˆæœ€å¾Œã®éƒ¨å±‹ï¼‰
            const endRoom = rooms[rooms.length - 1];
            const endX = Math.floor(endRoom.x + endRoom.width / 2);
            const endY = Math.floor(endRoom.y + endRoom.height / 2);
            this.map[endY][endX] = 2;
          } else {
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šéƒ¨å±‹ãŒç”Ÿæˆã§ããªã‹ã£ãŸå ´åˆ
            this.p = { x: 2, y: 2 };
            this.map[2][2] = 0;
            this.map[this.gridY - 3][this.gridX - 3] = 2;
            this.startRoom = { x: 1, y: 1, width: 3, height: 3 }; // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨
          }

          // 4. é€šè·¯ã®æ‹¡å¼µã¯ç„¡åŠ¹åŒ–ï¼ˆè¿·è·¯æ§‹é€ ã‚’ä¿ã¤ãŸã‚ï¼‰
          // this.expandCorridors();

          // 5. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã®ç¢ºèªï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
          if (!this.p || this.map[this.p.y][this.p.x] !== 0) {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ãŒç„¡åŠ¹ãªå ´åˆã€æœ€åˆã®ç©ºããƒã‚¹ã‚’æ¢ã™
            let found = false;
            for (let y = 1; y < this.gridY - 1 && !found; y++) {
              for (let x = 1; x < this.gridX - 1 && !found; x++) {
                if (this.map[y][x] === 0) {
                  this.p = { x, y };
                  found = true;
                }
              }
            }
            if (!found) {
              this.p = { x: 1, y: 1 };
              this.map[1][1] = 0;
            }
          }

          // 6. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®åˆæœŸåŒ–
          game.player.stamina = 100;
          this.timeLeft = 180;
          this.entities = [];
          // æ•µã®æ•°ã‚’æ¸›ã‚‰ã™ï¼ˆ8 + difficultyï¼‰
          for (let i = 0; i < 8 + difficulty; i++) this.spawnEntity("enemy");
          // ãƒ«ãƒ¼ãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®æ•°ã‚‚å°‘ã—æ¸›ã‚‰ã™
          for (let i = 0; i < 12; i++) this.spawnEntity("loot");
          window.onkeydown = (e) => {
            if (game.state !== "EXPLORE") return;
            const k = e.key.toLowerCase();

            // Eã‚­ãƒ¼ã§è£…å‚™ãƒ‘ãƒãƒ«ã‚’é–‹é–‰
            if (k === "e") {
              game.toggleExplorePanel();
              return;
            }

            // ãƒ‘ãƒãƒ«ãŒé–‹ã„ã¦ã„ã‚‹ã¨ãã¯ç§»å‹•ã‚’ç„¡åŠ¹åŒ–
            const panel = document.getElementById("explore-panel");
            if (panel && panel.classList.contains("visible")) return;

            if (e.shiftKey) game.player.isStealth = true;
            let dx = 0,
              dy = 0;
            if (k === "w" || k === "arrowup") dy = -1;
            if (k === "s" || k === "arrowdown") dy = 1;
            if (k === "a" || k === "arrowleft") dx = -1;
            if (k === "d" || k === "arrowright") dx = 1;
            if (dx !== 0 || dy !== 0) this.movePlayer(dx, dy);
          };
          window.onkeyup = (e) => {
            if (e.key === "Shift") game.player.isStealth = false;
          };
        },
        // Lå­—å‹ã®é€šè·¯ã‚’ä½œã‚‹é–¢æ•°ï¼ˆã‚ˆã‚Šè¿·è·¯ã‚‰ã—ãï¼‰
        createLShapedCorridor(x1, y1, x2, y2) {
          // ãƒ©ãƒ³ãƒ€ãƒ ã«æ¨ªâ†’ç¸¦ã¾ãŸã¯ç¸¦â†’æ¨ªã‚’é¸æŠ
          if (Math.random() < 0.5) {
            // æ¨ªâ†’ç¸¦: (x1,y1) â†’ (x2,y1) â†’ (x2,y2)
            const startX = Math.min(x1, x2);
            const endX = Math.max(x1, x2);
            for (let x = startX; x <= endX; x++) {
              if (
                x >= 1 &&
                x < this.gridX - 1 &&
                y1 >= 1 &&
                y1 < this.gridY - 1
              ) {
                this.map[y1][x] = 0;
              }
            }
            const startY = Math.min(y1, y2);
            const endY = Math.max(y1, y2);
            for (let y = startY; y <= endY; y++) {
              if (
                x2 >= 1 &&
                x2 < this.gridX - 1 &&
                y >= 1 &&
                y < this.gridY - 1
              ) {
                this.map[y][x2] = 0;
              }
            }
          } else {
            // ç¸¦â†’æ¨ª: (x1,y1) â†’ (x1,y2) â†’ (x2,y2)
            const startY = Math.min(y1, y2);
            const endY = Math.max(y1, y2);
            for (let y = startY; y <= endY; y++) {
              if (
                x1 >= 1 &&
                x1 < this.gridX - 1 &&
                y >= 1 &&
                y < this.gridY - 1
              ) {
                this.map[y][x1] = 0;
              }
            }
            const startX = Math.min(x1, x2);
            const endX = Math.max(x1, x2);
            for (let x = startX; x <= endX; x++) {
              if (
                x >= 1 &&
                x < this.gridX - 1 &&
                y2 >= 1 &&
                y2 < this.gridY - 1
              ) {
                this.map[y2][x] = 0;
              }
            }
          }
        },
        // é€šè·¯ã‚’ä½œã‚‹é–¢æ•°ï¼ˆå¹…æŒ‡å®šå¯èƒ½ã€ä¸»ã«åˆ†å²ç‚¹ç”¨ï¼‰
        createCorridor(x1, y1, x2, y2, width = 1) {
          const dx = x2 - x1;
          const dy = y2 - y1;
          const steps = Math.max(Math.abs(dx), Math.abs(dy));

          for (let i = 0; i <= steps; i++) {
            const t = steps === 0 ? 0 : i / steps;
            const cx = Math.floor(x1 + dx * t);
            const cy = Math.floor(y1 + dy * t);

            // é€šè·¯ã®å¹…åˆ†ã€å‘¨è¾ºã‚‚é–‹ã‘ã‚‹ï¼ˆ1.5ã®å ´åˆã¯2ãƒã‚¹å¹…ï¼‰
            const halfWidth = width >= 1.5 ? 1 : 0;
            for (let wy = -halfWidth; wy <= halfWidth; wy++) {
              for (let wx = -halfWidth; wx <= halfWidth; wx++) {
                const nx = cx + wx;
                const ny = cy + wy;
                if (
                  nx >= 1 &&
                  nx < this.gridX - 1 &&
                  ny >= 1 &&
                  ny < this.gridY - 1
                ) {
                  this.map[ny][nx] = 0;
                }
              }
            }
          }
        },
        // é€šè·¯ã‚’å°‘ã—æ‹¡å¼µã™ã‚‹ï¼ˆã‚ˆã‚Šåºƒã„å°è±¡ã«ã™ã‚‹ï¼‰
        expandCorridors() {
          // ãƒãƒƒãƒ—ã®ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆ
          const expanded = [];
          for (let y = 0; y < this.gridY; y++) {
            expanded.push([]);
            for (let x = 0; x < this.gridX; x++) {
              expanded[y].push(this.map[y][x]);
            }
          }

          for (let y = 1; y < this.gridY - 1; y++) {
            for (let x = 1; x < this.gridX - 1; x++) {
              if (this.map[y][x] === 0) {
                // é€šè·¯ã®å‘¨è¾ºã‚’å°‘ã—é–‹ã‘ã‚‹ï¼ˆç¢ºç‡çš„ã«ï¼‰
                if (Math.random() < 0.3) {
                  const dirs = [
                    [0, 1],
                    [0, -1],
                    [1, 0],
                    [-1, 0],
                  ];
                  for (const [dx, dy] of dirs) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (
                      nx >= 1 &&
                      nx < this.gridX - 1 &&
                      ny >= 1 &&
                      ny < this.gridY - 1
                    ) {
                      if (this.map[ny][nx] === 1 && Math.random() < 0.4) {
                        expanded[ny][nx] = 0;
                      }
                    }
                  }
                }
              }
            }
          }

          // æ‹¡å¼µã—ãŸãƒãƒƒãƒ—ã‚’é©ç”¨
          for (let y = 1; y < this.gridY - 1; y++) {
            for (let x = 1; x < this.gridX - 1; x++) {
              this.map[y][x] = expanded[y][x];
            }
          }
        },
        spawnEntity(type) {
          let x, y;
          let attempts = 0;
          let isValid = false;
          do {
            x = Math.floor(Math.random() * (this.gridX - 2)) + 1;
            y = Math.floor(Math.random() * (this.gridY - 2)) + 1;
            attempts++;
            if (attempts > 1000) {
              // 1000å›è©¦è¡Œã—ã¦ã‚‚è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
              console.warn(`Could not spawn ${type} after 1000 attempts`);
              return;
            }

            // ãƒã‚§ãƒƒã‚¯æ¡ä»¶
            const isWalkable = this.map[y][x] === 0;
            const isPlayerPos = x === this.p.x && y === this.p.y;

            // ã‚¹ã‚¿ãƒ¼ãƒˆéƒ¨å±‹å†…ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆãƒãƒ¼ã‚¸ãƒ³ä»˜ãï¼‰
            let isInStartRoom = false;
            if (this.startRoom) {
              const margin = 2; // å‘¨è¾º2ãƒã‚¹ã‚‚å®‰å…¨åœ°å¸¯
              isInStartRoom =
                x >= this.startRoom.x - margin &&
                x < this.startRoom.x + this.startRoom.width + margin &&
                y >= this.startRoom.y - margin &&
                y < this.startRoom.y + this.startRoom.height + margin;
            }

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ä¸€å®šè·é›¢ä»¥å†…ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæ•µã®ã¿ï¼‰
            const distFromPlayer =
              Math.abs(x - this.p.x) + Math.abs(y - this.p.y);
            const tooCloseToPlayer = type === "enemy" && distFromPlayer < 8; // 8ãƒã‚¹ä»¥å†…ã¯æ•µã‚’é…ç½®ã—ãªã„

            isValid =
              isWalkable && !isPlayerPos && !isInStartRoom && !tooCloseToPlayer;
          } while (!isValid);
          let visionRange = 4;
          let armorNoise = ARMORS[game.player.loadout.armor].noise;
          if (type === "enemy") visionRange = 4 + armorNoise;
          this.entities.push({
            x,
            y,
            type,
            active: true,
            facing: Math.floor(Math.random() * 4),
            aggro: false,
            vision: visionRange,
            lastSeenPlayer: null,
            aggroTimer: 0,
          });
        },
        start() {
          this.lastTime = Date.now();
          if (this.timer) clearInterval(this.timer);
          this.timer = setInterval(() => this.loop(), 50);
        },
        stop() {
          if (this.timer) clearInterval(this.timer);
        },
        loop() {
          if (game.state !== "EXPLORE") return;
          const now = Date.now();
          const dt = (now - this.lastTime) / 1000;
          this.lastTime = now;
          this.timeLeft -= dt;
          if (this.timeLeft <= 0) {
            this.timeLeft = 0;
            game.returnToBase(false);
            return;
          }
          this.enemyMoveTimer += dt;
          if (this.enemyMoveTimer >= 0.65) {
            this.updateEnemies();
            this.enemyMoveTimer = 0;
          }
          if (!game.player.isStealth && game.player.stamina < 100)
            game.player.stamina += 0.5;
          this.draw();
          this.updateUI();
        },
        movePlayer(dx, dy) {
          let cost = 0;
          if (game.player.isStealth) {
            const currentArmor = ARMORS[game.player.loadout.armor];
            const currentWeapon = WEAPONS[game.player.loadout.weapon];
            cost = 1 + currentArmor.noise + currentWeapon.noise;
            if (game.player.stamina < cost) {
              game.player.isStealth = false;
              cost = 0;
            } else {
              game.player.stamina -= cost;
            }
          }
          const nx = this.p.x + dx;
          const ny = this.p.y + dy;
          if (this.map[ny][nx] === 1) return;
          if (this.map[ny][nx] === 2) {
            game.returnToBase(true);
            return;
          }
          const hit = this.entities.find(
            (e) => e.x === nx && e.y === ny && e.active
          );
          if (hit) {
            if (hit.type === "enemy") {
              let pDir = -1;
              if (dy === -1) pDir = 0;
              if (dx === 1) pDir = 1;
              if (dy === 1) pDir = 2;
              if (dx === -1) pDir = 3;
              const isFrontal = Math.abs(pDir - hit.facing) === 2;
              let isAmbush = game.player.isStealth && !isFrontal;
              game.enterBattle(hit, isAmbush);
              return;
            } else if (hit.type === "loot") {
              hit.active = false;
              // æ‰€æŒå“æ•°ã®ãƒã‚§ãƒƒã‚¯
              if (game.getInventoryCount() >= game.MAX_INVENTORY_SIZE) {
                game.log("Inventory full! Cannot pick up Scrap.");
                return;
              }
              game.player.mats.scrap++;
              game.log("Found Scrap!");
            }
          }
          this.p.x = nx;
          this.p.y = ny;
          if (!game.player.isStealth) {
            this.entities.forEach((e) => {
              if (e.type === "enemy" && e.active && !e.aggro) {
                const dist = Math.abs(e.x - nx) + Math.abs(e.y - ny);
                if (dist <= 4) {
                  e.aggro = true;
                  if (Math.abs(e.x - nx) > Math.abs(e.y - ny))
                    e.facing = e.x > nx ? 3 : 1;
                  else e.facing = e.y > ny ? 0 : 2;
                }
              }
            });
          }
        },
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¾ã§ã®è·é›¢ã‚’è¨ˆç®—ï¼ˆãƒãƒ³ãƒãƒƒã‚¿ãƒ³è·é›¢ï¼‰
        getDistance(x1, y1, x2, y2) {
          return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        },
        // å¹…å„ªå…ˆæ¢ç´¢ï¼ˆBFSï¼‰ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¾ã§ã®ãƒ‘ã‚¹ã‚’è¨ˆç®—ï¼ˆæœ€å¤§æ·±åº¦åˆ¶é™ä»˜ãï¼‰
        findPath(startX, startY, targetX, targetY, maxDepth = 25) {
          const queue = [[startX, startY, []]];
          const visited = new Set();
          visited.add(`${startX},${startY}`);
          const directions = [
            [0, -1],
            [1, 0],
            [0, 1],
            [-1, 0],
          ];

          while (queue.length > 0) {
            const [x, y, path] = queue.shift();

            // æœ€å¤§æ·±åº¦ãƒã‚§ãƒƒã‚¯
            if (path.length >= maxDepth) continue;

            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«åˆ°é”
            if (x === targetX && y === targetY) {
              return path;
            }

            // 4æ–¹å‘ã‚’æ¢ç´¢
            for (const [dx, dy] of directions) {
              const nx = x + dx;
              const ny = y + dy;
              const key = `${nx},${ny}`;

              if (!visited.has(key) && this.isWalkable(nx, ny)) {
                visited.add(key);
                queue.push([nx, ny, [...path, [dx, dy]]]);
              }
            }
          }

          // ãƒ‘ã‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€nullã‚’è¿”ã™
          return null;
        },
        // æœ€è‰¯ã®ç§»å‹•æ–¹å‘ã‚’é¸æŠï¼ˆãƒ‘ã‚¹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ç”¨ï¼‰
        findBestMove(e, targetX, targetY) {
          const directions = [
            [0, -1, 0], // ä¸Š
            [1, 0, 1], // å³
            [0, 1, 2], // ä¸‹
            [-1, 0, 3], // å·¦
          ];

          // ãƒ‘ã‚¹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã§æœ€çŸ­çµŒè·¯ã‚’æ¢ã™
          const path = this.findPath(e.x, e.y, targetX, targetY);

          if (path && path.length > 0) {
            // ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’å®Ÿè¡Œ
            const [dx, dy] = path[0];
            const facing = directions.findIndex(
              (d) => d[0] === dx && d[1] === dy
            );
            const nx = e.x + dx;
            const ny = e.y + dy;

            if (this.isWalkable(nx, ny)) {
              return {
                x: nx,
                y: ny,
                facing: facing >= 0 ? facing : e.facing,
                dx: dx,
                dy: dy,
              };
            }
          }

          // ãƒ‘ã‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ç›´æ¥è·é›¢ã§æœ€è‰¯ã®æ–¹å‘ã‚’é¸ã¶ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
          let bestMove = null;
          let bestDistance = Infinity;
          const currentDist = this.getDistance(e.x, e.y, targetX, targetY);

          // å„æ–¹å‘ã‚’è©•ä¾¡ï¼ˆ2ã‚¹ãƒ†ãƒƒãƒ—å…ˆã‚‚è€ƒæ…®ï¼‰
          for (const [dx, dy, facing] of directions) {
            const nx = e.x + dx;
            const ny = e.y + dy;

            if (this.isWalkable(nx, ny)) {
              const newDist = this.getDistance(nx, ny, targetX, targetY);

              // ã•ã‚‰ã«2ã‚¹ãƒ†ãƒƒãƒ—å…ˆã‚’è¦‹ã¦ã€ç§»å‹•å¯èƒ½ãªçµŒè·¯ãŒã‚ã‚‹ã‹ç¢ºèª
              let hasPathAhead = false;
              for (const [dx2, dy2] of directions) {
                const nx2 = nx + dx2;
                const ny2 = ny + dy2;
                if (this.isWalkable(nx2, ny2)) {
                  hasPathAhead = true;
                  break;
                }
              }

              // ã‚ˆã‚Šè¿‘ã¥ã‘ã‚‹æ–¹å‘ã€ã¾ãŸã¯è¡Œãè©°ã¾ã‚Šã§ãªã„æ–¹å‘ã‚’å„ªå…ˆ
              const score = newDist - (hasPathAhead ? 0.5 : -10);
              if (score < bestDistance) {
                bestDistance = score;
                bestMove = { x: nx, y: ny, facing: facing, dx: dx, dy: dy };
              }
            }
          }

          // ã©ã®æ–¹å‘ã‚‚ç§»å‹•ã§ããªã„å ´åˆã€ç¾åœ¨ä½ç½®ã‚’ç¶­æŒ
          if (!bestMove) {
            return { x: e.x, y: e.y, facing: e.facing, dx: 0, dy: 0 };
          }

          return bestMove;
        },
        updateEnemies() {
          this.entities.forEach((e) => {
            if (e.type !== "enemy" || !e.active) return;
            const dx = this.p.x - e.x;
            const dy = this.p.y - e.y;
            const dist = Math.abs(dx) + Math.abs(dy);

            // è¦–ç•Œåˆ¤å®šï¼ˆã‚ˆã‚Šåºƒã„è¦–é‡è§’ï¼‰
            let inSight = false;
            if (dist <= e.vision) {
              // è¦–é‡è§’ã‚’åºƒã’ã‚‹ï¼ˆå·¦å³90åº¦ï¼‰
              if (e.facing === 0 && dy < 0 && Math.abs(dx) <= Math.abs(dy) * 2)
                inSight = true;
              if (e.facing === 1 && dx > 0 && Math.abs(dy) <= Math.abs(dx) * 2)
                inSight = true;
              if (e.facing === 2 && dy > 0 && Math.abs(dx) <= Math.abs(dy) * 2)
                inSight = true;
              if (e.facing === 3 && dx < 0 && Math.abs(dy) <= Math.abs(dx) * 2)
                inSight = true;
            }

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¦–ç•Œå†…ã§ã‚¹ãƒ†ãƒ«ã‚¹çŠ¶æ…‹ã§ãªã„å ´åˆã€aggroçŠ¶æ…‹ã«ã™ã‚‹
            if (inSight && !game.player.isStealth) {
              e.aggro = true;
              e.lastSeenPlayer = { x: this.p.x, y: this.p.y };
              e.aggroTimer = 30; // 30ã‚¿ãƒ¼ãƒ³è¿½è·¡ã‚’ç¶™ç¶š
            }

            // ä¸€å®šè·é›¢ä»¥å†…ãªã‚‰è¿½è·¡ã‚’ç¶™ç¶šï¼ˆè¦–ç•Œå¤–ã§ã‚‚ï¼‰
            if (e.aggro && dist <= e.vision * 4 && !game.player.isStealth) {
              e.lastSeenPlayer = { x: this.p.x, y: this.p.y };
              e.aggroTimer = Math.max(e.aggroTimer, 15);
            }

            // aggroçŠ¶æ…‹ã®å‡¦ç†
            if (e.aggro) {
              // ã‚¿ã‚¤ãƒãƒ¼ã‚’æ¸›ã‚‰ã™ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¦‹å¤±ã£ãŸå ´åˆã®è¿½è·¡æ™‚é–“ï¼‰
              if (e.aggroTimer) e.aggroTimer--;

              // ç¾åœ¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¦‹ãˆã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¹ãƒ†ãƒ«ã‚¹ã§ãªãã€è¦–ç•Œå†…ï¼‰
              const currentlyVisible =
                !game.player.isStealth && dist <= e.vision && inSight;

              // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‚’æ±ºå®š
              let targetX = this.p.x;
              let targetY = this.p.y;

              if (currentlyVisible) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¦‹ãˆã¦ã„ã‚‹å ´åˆã¯ç›´æ¥è¿½è·¡
                e.lastSeenPlayer = { x: this.p.x, y: this.p.y };
                e.aggroTimer = Math.max(e.aggroTimer, 30);
                targetX = this.p.x;
                targetY = this.p.y;
              } else if (e.lastSeenPlayer) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¦‹ãˆãªã„å ´åˆ
                const distToLastSeen = this.getDistance(
                  e.x,
                  e.y,
                  e.lastSeenPlayer.x,
                  e.lastSeenPlayer.y
                );

                // æœ€å¾Œã«è¦‹ãŸä½ç½®ã«åˆ°é”ã—ã¦ã„ã‚‹ã€ã¾ãŸã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¿‘ã„å ´åˆã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç›´æ¥è¿½è·¡
                if (distToLastSeen <= 2 || dist <= e.vision * 3) {
                  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®ãƒ‘ã‚¹ãŒã‚ã‚‹ã‹è©¦ã™
                  const pathToPlayer = this.findPath(
                    e.x,
                    e.y,
                    this.p.x,
                    this.p.y,
                    20
                  );
                  if (pathToPlayer && pathToPlayer.length > 0) {
                    targetX = this.p.x;
                    targetY = this.p.y;
                    e.lastSeenPlayer = { x: this.p.x, y: this.p.y };
                  } else {
                    // ãƒ‘ã‚¹ãŒãªã„å ´åˆã¯æœ€å¾Œã«è¦‹ãŸä½ç½®ã¸
                    targetX = e.lastSeenPlayer.x;
                    targetY = e.lastSeenPlayer.y;
                  }
                } else {
                  // ã¾ã æœ€å¾Œã«è¦‹ãŸä½ç½®ã«åˆ°é”ã—ã¦ã„ãªã„
                  targetX = e.lastSeenPlayer.x;
                  targetY = e.lastSeenPlayer.y;
                }
              }

              // æœ€è‰¯ã®ç§»å‹•æ–¹å‘ã‚’é¸æŠï¼ˆãƒ‘ã‚¹ãƒ•ã‚¡ã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ä½¿ç”¨ï¼‰
              const bestMove = this.findBestMove(e, targetX, targetY);

              // ç§»å‹•ãŒæˆåŠŸã—ãŸå ´åˆã®ã¿ä½ç½®ã‚’æ›´æ–°
              if (bestMove.x !== e.x || bestMove.y !== e.y) {
                e.x = bestMove.x;
                e.y = bestMove.y;
                e.facing = bestMove.facing;
              }

              // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨åŒã˜ä½ç½®ã«ãªã£ãŸã‚‰æˆ¦é—˜é–‹å§‹
              if (e.x === this.p.x && e.y === this.p.y) {
                game.enterBattle(e, false);
              }

              // ã‚¿ã‚¤ãƒãƒ¼åˆ‡ã‚Œã§è¿½è·¡ã‚’ã‚„ã‚ã‚‹ï¼ˆè·é›¢ãŒé ã™ãã‚‹å ´åˆã®ã¿ï¼‰
              if (e.aggroTimer <= 0 && dist > e.vision * 5) {
                e.aggro = false;
                e.lastSeenPlayer = null;
              }
            } else {
              // aggroã§ãªã„å ´åˆã®é€šå¸¸è¡Œå‹•
              if (Math.random() < 0.3) {
                const dirs = [
                  [0, -1, 0],
                  [1, 0, 1],
                  [0, 1, 2],
                  [-1, 0, 3],
                ];
                const dIdx = Math.floor(Math.random() * 4);
                const d = dirs[dIdx];
                const nx = e.x + d[0];
                const ny = e.y + d[1];
                e.facing = d[2];
                if (this.isWalkable(nx, ny)) {
                  e.x = nx;
                  e.y = ny;
                }
              }
            }
          });
        },
        isWalkable(x, y) {
          if (y < 0 || y >= this.gridY || x < 0 || x >= this.gridX)
            return false;
          if (this.map[y][x] === 1) return false;
          if (
            this.entities.some(
              (e) => e.active && e.x === x && e.y === y && e.type !== "loot"
            )
          )
            return false;
          return true;
        },
        draw() {
          const ctx = this.ctx;
          const ts = this.tile;
          const cw = this.canvas.width;
          const ch = this.canvas.height;
          ctx.fillStyle = "#000";
          ctx.fillRect(0, 0, cw, ch);
          const offsetX = Math.floor(cw / 2 / ts) - this.p.x;
          const offsetY = Math.floor(ch / 2 / ts) - this.p.y;
          for (let y = 0; y < this.gridY; y++) {
            for (let x = 0; x < this.gridX; x++) {
              const drawX = (x + offsetX) * ts;
              const drawY = (y + offsetY) * ts;
              if (drawX < -ts || drawX > cw || drawY < -ts || drawY > ch)
                continue;
              const dist = Math.sqrt((x - this.p.x) ** 2 + (y - this.p.y) ** 2);
              if (dist < 10) {
                if (this.map[y][x] === 1) {
                  ctx.fillStyle = "#444";
                  ctx.fillRect(drawX, drawY, ts, ts);
                } else if (this.map[y][x] === 2) {
                  ctx.fillStyle = "#0f0";
                  ctx.fillRect(drawX, drawY, ts, ts);
                } else {
                  ctx.fillStyle = "#222";
                  ctx.fillRect(drawX, drawY, ts - 1, ts - 1);
                }
              }
            }
          }
          this.entities.forEach((e) => {
            if (!e.active) return;
            const dist = Math.sqrt(
              (e.x - this.p.x) ** 2 + (e.y - this.p.y) ** 2
            );
            if (dist < 10) {
              const drawX = (e.x + offsetX) * ts;
              const drawY = (e.y + offsetY) * ts;
              if (e.type === "enemy") {
                ctx.fillStyle = e.aggro ? "#f00" : "#d44";
                ctx.fillRect(drawX + 2, drawY + 2, ts - 4, ts - 4);
                ctx.fillStyle = "rgba(255, 0, 0, 0.2)";
                ctx.beginPath();
                ctx.moveTo(drawX + ts / 2, drawY + ts / 2);
                let startAng = 0;
                if (e.facing === 0) startAng = 1.5 * Math.PI;
                if (e.facing === 1) startAng = 0;
                if (e.facing === 2) startAng = 0.5 * Math.PI;
                if (e.facing === 3) startAng = Math.PI;
                ctx.arc(
                  drawX + ts / 2,
                  drawY + ts / 2,
                  6 * ts,
                  startAng - 0.5,
                  startAng + 0.5
                );
                ctx.lineTo(drawX + ts / 2, drawY + ts / 2);
                ctx.fill();
              } else {
                ctx.fillStyle = "#ff0";
                ctx.beginPath();
                ctx.arc(drawX + ts / 2, drawY + ts / 2, 3, 0, 6.28);
                ctx.fill();
              }
            }
          });
          const pDrawX = Math.floor(cw / 2 - ts / 2);
          const pDrawY = Math.floor(ch / 2 - ts / 2);
          ctx.fillStyle = game.player.isStealth ? "#00f" : "#0ff";
          ctx.beginPath();
          ctx.arc(pDrawX + ts / 2, pDrawY + ts / 2, 5, 0, 6.28);
          ctx.fill();
        },
        updateUI() {
          document.getElementById("exp-hp").innerText = game.player.hp;
          document.getElementById("exp-st").innerText = Math.floor(
            game.player.stamina
          );
          document.getElementById("exp-time").innerText = Math.floor(
            this.timeLeft
          );
          const stInd = document.getElementById("stealth-indicator");
          if (game.player.isStealth) stInd.className = "active";
          else stInd.className = "";
        },
      };

      /* --- 4. BATTLE LOGIC --- */
      const battle = {
        enemy: null,
        deck: [],
        hand: [],
        discard: [],
        energy: 3,
        maxEnergy: 3,
        turn: 0,
        drawCount: 4,
        dungeonEnemyReference: null,
        shuffle(arr) {
          arr.sort(() => Math.random() - 0.5);
        },
        selectIntent() {
          if (this.enemy.isBroken) {
            this.enemy.nextIntent = null;
            return;
          }
          const availableIntents = [
            ENEMY_INTENTS.ATTACK,
            ENEMY_INTENTS.DEFEND,
            ENEMY_INTENTS.DEBUFF,
          ];
          this.enemy.nextIntent =
            availableIntents[
              Math.floor(Math.random() * availableIntents.length)
            ];
        },
        start(dungeonEnemy, isAmbush) {
          if (dungeonEnemy) this.isBossBattle = false;
          this.dungeonEnemyReference = dungeonEnemy;
          this.enemy = {
            hp: 100,
            maxHp: 100,
            pos: 50,
            maxPos: 50,
            isBroken: false,
            brokenTurns: 0,
            enemyBlock: 0,
            status: { mark: 0 },
            nextIntent: null,
            damageValue: 10,
          };
          this.turn = 0;
          game.player.playerBlock = 0;
          if (isAmbush) {
            this.enemy.hp -= 20;
            game.log("Ambush! Enemy took 20 dmg.");
          }
          this.deck = game.buildDeck();
          this.discard = [];
          this.hand = [];
          // â˜…ä¿®æ­£ç‚¹1: åˆæœŸãƒ‡ãƒƒã‚­ã¯ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ãªã„ï¼ˆå›ºå®šé †ï¼‰ã‹ã€ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹ã‹ã€‚ã“ã“ã§ã¯åˆæœŸã‚·ãƒ£ãƒƒãƒ•ãƒ«ã®ã¿ã€‚
          this.shuffle(this.deck);
          this.selectIntent();
          this.startTurn();
        },
        startTurn() {
          this.energy = this.maxEnergy;
          this.turn++;
          game.player.playerBlock = 0;
          // â˜…ä¿®æ­£ç‚¹1: æ‰‹æœ­ã®æ®‹ã‚Šã¯æ¨ã¦ãšã€ä¸è¶³åˆ†ã ã‘è£œå……ã™ã‚‹ã‚­ãƒ¥ãƒ¼æ–¹å¼
          // this.discard.push(...this.hand); this.hand = []; // å‰Šé™¤
          const need = this.drawCount - this.hand.length;
          for (let i = 0; i < need; i++) {
            if (this.deck.length === 0) break; // ãƒ‡ãƒƒã‚­åˆ‡ã‚Œã§æ­¢ã¾ã‚‹ï¼ˆè£œå……ã¯ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ãªã©ã«æ¤œè¨ã ãŒã€ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«åˆ‡ã‚Œã£ã±ãªã—ï¼‰
            this.hand.push(this.deck.shift()); // å…ˆé ­ã‹ã‚‰å¼•ã
          }
          this.updateUI();
        },
        endBattle(playerWon) {
          if (this.isBossBattle) {
            if (playerWon) {
              // ãƒœã‚¹ã«å‹ã£ãŸï¼ -> å‹åˆ©ãƒªã‚¶ãƒ«ãƒˆã¸ (ã‚¿ãƒ¼ãƒ³æ•°ã‚’æ¸¡ã™)
              game.showResult(true, this.turn);
            } else {
              // ãƒœã‚¹ã«è² ã‘ãŸâ€¦ -> æ•—åŒ—ãƒªã‚¶ãƒ«ãƒˆã¸
              game.showResult(false, this.turn);
            }
            return; // ã“ã“ã§å‡¦ç†çµ‚äº†ï¼ˆãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã«ã¯æˆ»ã‚‰ãªã„ï¼‰
          }
          this.enemy = null;
          game.player.playerBlock = 0;
          if (playerWon && this.dungeonEnemyReference) {
            this.dungeonEnemyReference.active = false;
            game.log("Enemy was eliminated.");
          }
          this.dungeonEnemyReference = null;
          this.deck = [];
          this.hand = [];
          this.discard = [];
          game.returnToDungeon(playerWon);
        },
        playCard(idx) {
          if (!this.enemy) return;
          const cardId = this.hand[idx];
          const card = CARDS[cardId];
          if (this.energy < card.cost) return;
          this.energy -= card.cost;
          this.hand.splice(idx, 1);
          // â˜…ä¿®æ­£ç‚¹1: ä½¿ã£ãŸã‚«ãƒ¼ãƒ‰ã¯ãƒ‡ãƒƒã‚­ã®æœ€å¾Œå°¾ã¸
          if (!card.exhaust) this.deck.push(cardId);
          // --- Effect Logic ---
          if (card.type === "atk") {
            let dmg = card.val;
            if (this.enemy.isBroken) dmg *= 2;
            if (this.enemy.status.mark > 0) {
              dmg *= 1.5;
              game.log(`Mark triggered! x1.5 Dmg.`);
            }
            let finalDmg = Math.max(0, Math.round(dmg) - this.enemy.enemyBlock);
            this.enemy.enemyBlock = Math.max(
              0,
              this.enemy.enemyBlock - Math.round(dmg)
            );
            this.enemy.hp -= finalDmg;
            if (!this.enemy.isBroken && card.pos) {
              this.enemy.pos -= card.pos;
              if (this.enemy.pos <= 0) {
                this.enemy.pos = 0;
                this.enemy.isBroken = true;
                this.enemy.brokenTurns = 2;
                game.log("ENEMY BREAK!");
              }
            }
          } else if (card.type === "def") {
            game.player.playerBlock += card.val;
            if (cardId === "dodge") {
              if (this.deck.length > 0) this.hand.push(this.deck.shift());
            }
          } else if (card.type === "skill") {
            if (card.status === "energy")
              this.energy = Math.min(this.maxEnergy, this.energy + card.val);
            if (card.status === "stun")
              this.enemy.brokenTurns = Math.max(
                this.enemy.brokenTurns,
                card.val
              );
            if (card.status === "mark") {
              this.enemy.status.mark += card.val;
              game.log(`Enemy applied MARK.`);
            }
            if (cardId === "focus" && this.deck.length > 0)
              this.hand.push(this.deck.shift());
          } else if (card.type === "curse") {
            if (cardId === "clunk") {
              if (this.deck.length > 0) this.hand.push(this.deck.shift());
              if (this.hand.length > 0) {
                this.deck.push(this.hand.pop());
              } // æœ«å°¾ã¸æˆ»ã™
            }
          }
          if (this.enemy.hp <= 0) {
            this.endBattle(true);
            return;
          }
          this.updateUI();
        },
        endTurn() {
          if (!this.enemy) return;
          let intent = this.enemy.nextIntent;
          if (this.enemy.isBroken) {
            this.enemy.brokenTurns--;
            if (this.enemy.brokenTurns <= 0) {
              this.enemy.isBroken = false;
              this.enemy.pos = this.enemy.maxPos;
              game.log("Enemy recovered.");
            }
          } else if (intent) {
            if (intent.name === ENEMY_INTENTS.ATTACK.name) {
              let incomingDmg = intent.dmg;
              let block = game.player.playerBlock;
              let finalDmg = Math.max(0, incomingDmg - block);
              game.player.playerBlock = Math.max(0, block - incomingDmg);
              game.player.hp -= finalDmg;
              game.log(
                `Enemy Atk ${incomingDmg}. Blocked ${block}. Took ${finalDmg}.`
              );
            } else if (intent.name === ENEMY_INTENTS.DEFEND.name) {
              this.enemy.enemyBlock += intent.block;
            }
            this.enemy.pos = Math.min(
              this.enemy.maxPos,
              this.enemy.pos + intent.posRegen
            );
          }
          if (this.enemy && this.enemy.status.mark > 0)
            this.enemy.status.mark--;
          if (game.player.hp <= 0) {
            game.returnToBase(false);
            return;
          }
          this.enemy.enemyBlock = 0;
          this.selectIntent();
          this.startTurn();
        },
        updateUI() {
          if (!this.enemy) return;
          document.getElementById("p-hp-text").innerText = game.player.hp;
          document.getElementById("p-hp-bar").style.width =
            (game.player.hp / game.player.maxHp) * 100 + "%";
          document.getElementById(
            "p-en-text"
          ).innerText = `${this.energy}/${this.maxEnergy}`;
          document.getElementById("p-blk-text").innerText =
            game.player.playerBlock;
          document.getElementById("p-blk-text").style.display =
            game.player.playerBlock > 0 ? "flex" : "none";
          document.getElementById("e-hp-bar").style.width =
            (this.enemy.hp / this.enemy.maxHp) * 100 + "%";
          document.getElementById("e-pos-bar").style.width =
            (this.enemy.pos / this.enemy.maxPos) * 100 + "%";
          const nameEl = document.getElementById("e-name");
          if (this.enemy.maxHp >= 300) {
            // HPãŒ300ä»¥ä¸Šãªã‚‰ãƒœã‚¹ã¨ã¿ãªã™ç°¡æ˜“åˆ¤å®š
            nameEl.innerText = this.enemy.isBroken
              ? "WEAKENED BOSS"
              : "â˜ ï¸ THE BOSS â˜ ï¸";
            nameEl.style.color = "#c3073f"; // èµ¤è‰²ã§å¼·èª¿
          } else {
            nameEl.innerText = this.enemy.isBroken ? "Broken Enemy" : "Enemy";
            nameEl.style.color = "#fff";
          }

          const intentEl = document.getElementById("e-intent");
          intentEl.className = "intent-icon";
          if (this.enemy.isBroken) {
            intentEl.innerText = "ğŸ˜µ";
          } else {
            const intent = this.enemy.nextIntent;
            if (intent) {
              let text = intent.icon;
              if (intent.dmg) text += ` ${intent.dmg}`;
              if (intent.block) text += ` ${intent.block}`;
              intentEl.innerText = text;
              intentEl.classList.add(intent.css);
            } else {
              intentEl.innerText = "âš ï¸";
            }
          }
          let enemyStatusHTML = "";
          if (this.enemy.isBroken)
            enemyStatusHTML += `<span class="status-badge" style="background: #007bff;">BREAK!</span>`;
          if (this.enemy.status.mark > 0)
            enemyStatusHTML += `<span class="status-badge" style="background: #ff00ff;">MARK (${this.enemy.status.mark})</span>`;
          if (this.enemy.enemyBlock > 0)
            enemyStatusHTML += `<span class="status-badge" style="background: #0f0;">BLK (${this.enemy.enemyBlock})</span>`;
          document.getElementById("enemy-status").innerHTML = enemyStatusHTML;

          // ä¿®æ­£ç‚¹2: è£…å‚™åè¡¨ç¤º
          document.getElementById("p-eq-w").innerText =
            WEAPONS[game.player.loadout.weapon].name;
          document.getElementById("p-eq-a").innerText =
            ARMORS[game.player.loadout.armor].name;

          const h = document.getElementById("hand-container");
          h.innerHTML = "";
          this.hand.forEach((cid, i) => {
            const c = CARDS[cid];
            const d = document.createElement("div");
            const canPlay = this.energy >= c.cost;
            d.className = `card ${canPlay ? "" : "unplayable"}`;
            d.innerHTML = `<div class="card-cost">${c.cost}</div><div class="card-type">${c.type}</div><div class="card-name">${c.name}</div><div class="card-desc">${c.desc}</div>`;
            if (canPlay) d.onclick = () => this.playCard(i);
            h.appendChild(d);
          });
          document.getElementById("deck-num").innerText = this.deck.length;
          document.getElementById("disc-num").innerText = "0"; // ã‚­ãƒ¥ãƒ¼å¼ãªã®ã§æ¨ã¦æœ­ã¯ãªã„
        },
      };
      window.onload = () => game.init();
    </script>
  </body>
</html>
