<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>DUSTFALL Battle Prototype Ver 2.7 (2-Turn CD)</title>
    <style>
      /* --- åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« --- */
      body {
        font-family: "Courier New", monospace;
        background: #1a1a1a;
        color: #eee;
        padding: 20px;
        line-height: 1.4;
      }
      .container {
        max-width: 1100px;
        margin: 0 auto;
      }

      /* --- ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ»ã‚¿ãƒ¼ãƒ³è¡¨ç¤º --- */
      .battle-header {
        text-align: center;
        margin-bottom: 20px;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }
      .turn-indicator {
        font-size: 1.4em;
        color: #3498db;
        font-weight: bold;
      }
      .phase-indicator {
        font-size: 1em;
        color: #f39c12;
      }

      /* --- ãƒ¡ã‚¤ãƒ³ãƒãƒˆãƒ«ã‚¨ãƒªã‚¢ --- */
      .battle-area {
        display: flex;
        justify-content: space-between;
        gap: 20px;
        margin-bottom: 20px;
      }
      .character-box {
        flex: 1;
        border: 2px solid #555;
        padding: 15px;
        border-radius: 8px;
        background: #2d2d2d;
        position: relative;
        transition: box-shadow 0.3s;
      }
      .character-box.active-turn {
        border-color: #f1c40f;
        box-shadow: 0 0 15px rgba(241, 196, 15, 0.3);
      }

      /* --- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ --- */
      .bar-container {
        margin-bottom: 12px;
      }
      .bar-label {
        font-size: 0.85em;
        display: flex;
        justify-content: space-between;
        margin-bottom: 2px;
      }
      .bar-bg {
        background: #444;
        height: 14px;
        width: 100%;
        border-radius: 7px;
        overflow: hidden;
        position: relative;
      }
      .bar-fill {
        height: 100%;
        transition: width 0.4s ease-out;
      }
      .hp-fill {
        background: linear-gradient(90deg, #c0392b, #e74c3c);
      }
      .pos-fill {
        background: linear-gradient(90deg, #d35400, #f1c40f);
      }
      .sp-fill {
        background: linear-gradient(90deg, #8e44ad, #9b59b6);
      }
      .sp-max-glow {
        box-shadow: 0 0 10px #9b59b6;
        animation: pulse-sp 1.5s infinite;
      }
      @keyframes pulse-sp {
        0% {
          opacity: 0.8;
        }
        50% {
          opacity: 1;
          filter: brightness(1.3);
        }
        100% {
          opacity: 0.8;
        }
      }

      /* --- æƒ…å ±é–‹ç¤ºã‚¨ãƒªã‚¢ (Intel) --- */
      .intel-box {
        background: #000;
        padding: 12px;
        border: 1px dashed #666;
        margin-top: 15px;
        font-size: 0.85em;
        color: #bbb;
        border-radius: 4px;
      }
      .intel-highlight {
        color: #f1c40f;
        font-weight: bold;
        font-size: 1.2em;
      }
      .stance-hint {
        color: #e67e22;
        font-weight: bold;
        border: 1px solid #e67e22;
        padding: 5px;
        margin-top: 5px;
        display: inline-block;
      }

      /* æ•µã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³è¡¨ç¤ºç”¨ã‚°ãƒªãƒƒãƒ‰ */
      .cooldown-grid {
        display: flex;
        flex-direction: column;
        gap: 4px;
        margin-top: 8px;
      }
      .cd-row {
        display: flex;
        justify-content: space-between;
        background: #222;
        padding: 4px 8px;
        border-radius: 4px;
        font-family: "Consolas", monospace;
        font-size: 0.9em;
      }
      .cd-row span:first-child {
        color: #aaa;
      }
      .cd-row span:last-child {
        font-weight: bold;
      }
      .cd-alert {
        color: #e74c3c !important; /* CDãŒå¤šã„ã¨ãã¯èµ¤ã */
      }

      /* --- ã‚³ãƒãƒ³ãƒ‰æ“ä½œã‚¨ãƒªã‚¢ --- */
      .controls {
        background: #2d2d2d;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid #444;
      }
      .control-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }

      .slot-group {
        margin-bottom: 20px;
      }
      .slot-title {
        font-size: 0.9em;
        color: #aaa;
        margin-bottom: 8px;
        border-left: 3px solid #777;
        padding-left: 8px;
      }

      .btn-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      button {
        padding: 12px 16px;
        cursor: pointer;
        background: #3e3e3e;
        color: white;
        border: 1px solid #555;
        border-radius: 6px;
        font-family: inherit;
        font-size: 0.9em;
        transition: all 0.2s;
        min-width: 80px;
        position: relative;
      }
      button:hover:not(:disabled) {
        transform: translateY(-2px);
        filter: brightness(1.1);
      }
      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        background: #222;
      }
      button.selected {
        background: #ecf0f1;
        color: #333;
        border-color: #fff;
        font-weight: bold;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
      }

      /* ã‚¿ã‚¤ãƒ—åˆ¥è‰²åˆ†ã‘ */
      .btn-atk {
        border-bottom: 4px solid #e74c3c;
      }
      .btn-grd {
        border-bottom: 4px solid #3498db;
      }
      .btn-brk {
        border-bottom: 4px solid #f1c40f;
      }
      .btn-sp {
        border-bottom: 4px solid #9b59b6;
        background: linear-gradient(45deg, #2c1a3d, #4b2c68);
      }
      .btn-wait {
        border-bottom: 4px solid #95a5a6;
      }

      .btn-counter {
        border: 2px solid #e74c3c;
        color: #e74c3c;
        background: rgba(231, 76, 60, 0.1);
        width: 100%;
        margin-top: 5px;
      }
      .btn-counter.selected {
        background: #e74c3c;
        color: white;
      }

      /* --- ãƒ­ã‚°ã‚¨ãƒªã‚¢ --- */
      #log-area {
        background: #000;
        padding: 15px;
        height: 300px;
        overflow-y: auto;
        font-size: 14px;
        border: 1px solid #555;
        margin-top: 20px;
        border-radius: 4px;
        font-family: "Consolas", monospace;
      }
      .log-entry {
        margin-bottom: 5px;
        border-bottom: 1px solid #222;
        padding-bottom: 2px;
      }
      .log-turn {
        color: #3498db;
        font-weight: bold;
        margin-top: 15px;
        border-top: 1px dashed #3498db;
        padding-top: 5px;
      }
      .log-danger {
        color: #e74c3c;
      }
      .log-pos {
        color: #f39c12;
      }
      .log-sp {
        color: #9b59b6;
        font-weight: bold;
      }
      .log-info {
        color: #2ecc71;
      }
      .log-ai {
        color: #9b59b6;
        font-style: italic;
      }

      .badge {
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.7em;
        font-weight: bold;
        margin-left: 5px;
        text-transform: uppercase;
      }
      .badge-stun {
        background: #e74c3c;
        color: white;
        animation: blink 1.5s infinite;
      }
      @keyframes blink {
        50% {
          opacity: 0.6;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="battle-header">
        <h1>DUSTFALL - Battle Sim Ver 2.7 (2-Turn CD)</h1>
        <div class="turn-indicator">TURN <span id="turn-count">1</span></div>
        <div class="phase-indicator" id="phase-display">æº–å‚™ãƒ•ã‚§ãƒ¼ã‚º</div>
      </div>

      <div class="battle-area">
        <div class="character-box" id="p-box">
          <h3>ğŸ® Player (ã²ã‚ã—ãƒ¼) <span id="p-badges"></span></h3>
          <div class="bar-container">
            <div class="bar-label">
              <span>HP</span> <span id="p-hp-text">100/100</span>
            </div>
            <div class="bar-bg">
              <div
                id="p-hp-bar"
                class="bar-fill hp-fill"
                style="width: 100%"
              ></div>
            </div>
          </div>
          <div class="bar-container">
            <div class="bar-label">
              <span>Posture</span> <span id="p-pos-text">50/50</span>
            </div>
            <div class="bar-bg">
              <div
                id="p-pos-bar"
                class="bar-fill pos-fill"
                style="width: 100%"
              ></div>
            </div>
          </div>
          <div class="bar-container">
            <div class="bar-label">
              <span>SP Gauge</span> <span id="p-sp-text">5/8</span>
            </div>
            <div class="bar-bg">
              <div
                id="p-sp-bar"
                class="bar-fill sp-fill"
                style="width: 0%"
              ></div>
            </div>
          </div>
          <div
            style="
              margin-top: 8px;
              display: flex;
              justify-content: space-between;
            "
          >
            <div>
              EP:
              <span
                id="p-ep"
                style="font-weight: bold; color: #3498db; font-size: 1.2em"
                >7</span
              >
              / 7
            </div>
            <div style="font-size: 0.8em; color: #aaa">
              Counter: <span id="p-counter-status">æœªä½¿ç”¨</span>
            </div>
          </div>
        </div>

        <div class="character-box" id="e-box">
          <h3>ğŸ‘¾ Enemy (AI) <span id="e-badges"></span></h3>
          <div class="bar-container">
            <div class="bar-label">
              <span>HP</span> <span id="e-hp-text">100/100</span>
            </div>
            <div class="bar-bg">
              <div
                id="e-hp-bar"
                class="bar-fill hp-fill"
                style="width: 100%"
              ></div>
            </div>
          </div>
          <div class="bar-container">
            <div class="bar-label">
              <span>Posture</span> <span id="e-pos-text">50/50</span>
            </div>
            <div class="bar-bg">
              <div
                id="e-pos-bar"
                class="bar-fill pos-fill"
                style="width: 100%"
              ></div>
            </div>
          </div>
          <div class="bar-container">
            <div class="bar-label">
              <span>SP Gauge</span> <span id="e-sp-text">5/8</span>
            </div>
            <div class="bar-bg">
              <div
                id="e-sp-bar"
                class="bar-fill sp-fill"
                style="width: 0%"
              ></div>
            </div>
          </div>

          <div class="intel-box" id="enemy-intel">
            <div>ğŸ§  æ€§æ ¼: <span id="ai-personality">åˆ†æä¸­...</span></div>

            <div
              id="intel-action-reveal"
              style="
                margin-top: 10px;
                border-top: 1px dashed #555;
                padding-top: 5px;
                display: none;
              "
            >
              âš ï¸ æ•µã®å…ˆè¡Œå…¥åŠ›æƒ…å ±:<br />
              <div style="margin: 5px 0">
                æ¶ˆè²»EPåˆè¨ˆ:
                <span class="intel-highlight" id="e-ep-cost-reveal">?</span>
              </div>
              <div id="e-stance-hint" class="stance-hint"></div>
            </div>

            <div
              style="
                margin-top: 10px;
                font-size: 0.8em;
                border-top: 1px solid #444;
                padding-top: 5px;
              "
            >
              ğŸ”’ æ•µãƒ‡ãƒƒã‚­ ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³çŠ¶æ³:
              <br /><span style="color: #666; font-size: 0.9em"
                >(Coståˆ¥ CDä¸­ã®æšæ•° / åˆè¨ˆæšæ•°)</span
              >
            </div>
            <div class="cooldown-grid" id="e-cd-grid"></div>
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="control-header">
          <h4 id="control-msg">ã‚³ãƒãƒ³ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„</h4>
          <div style="text-align: right">
            Cost:
            <span id="total-cost" style="font-weight: bold; font-size: 1.3em"
              >0</span
            >
            / <span id="max-cost">7</span>
          </div>
        </div>

        <div class="slot-group">
          <div class="slot-title">
            SLOT 1 (Main Action) - å‹ã¦ã°æ¬¡æ‰‹ã‚’å¼·åŒ–ã€è² ã‘ã‚Œã°å¼±ä½“åŒ–
          </div>
          <div class="btn-row" id="s1-btns">
            <button
              class="btn-atk"
              data-slot="1"
              data-sub-type="ATTACK"
              data-cost="3"
            >
              å¼·Attack (3)
            </button>
            <button
              class="btn-atk"
              data-slot="1"
              data-sub-type="ATTACK2"
              data-cost="2"
            >
              é€ŸAttack (2)
            </button>
            <button
              class="btn-grd"
              data-slot="1"
              data-sub-type="GUARD"
              data-cost="3"
            >
              å …Guard (3)
            </button>
            <button
              class="btn-grd"
              data-slot="1"
              data-sub-type="GUARD2"
              data-cost="2"
            >
              è»½Guard (2)
            </button>
            <button
              class="btn-brk"
              data-slot="1"
              data-sub-type="BREAK"
              data-cost="2"
            >
              Break (2)
            </button>
            <button
              class="btn-sp"
              data-slot="1"
              data-sub-type="SPECIAL"
              data-cost="5"
            >
              ğŸš€ SPå¿…æ®º (5)
            </button>
          </div>
        </div>

        <div class="slot-group">
          <div class="slot-title">
            SLOT 2 (Follow Action) - Slot1ã®çµæœãŒå¤§ããå½±éŸ¿(0.2å€ï½1.5å€)
          </div>
          <div class="btn-row" id="s2-btns">
            <button
              class="btn-atk"
              data-slot="2"
              data-sub-type="ATTACK"
              data-cost="3"
            >
              å¼·Attack (3)
            </button>
            <button
              class="btn-atk"
              data-slot="2"
              data-sub-type="ATTACK2"
              data-cost="2"
            >
              é€ŸAttack (2)
            </button>
            <button
              class="btn-grd"
              data-slot="2"
              data-sub-type="GUARD"
              data-cost="1"
            >
              Guard (1)
            </button>
            <button
              class="btn-brk"
              data-slot="2"
              data-sub-type="BREAK"
              data-cost="2"
            >
              Break (2)
            </button>
            <button
              class="btn-wait"
              data-slot="2"
              data-sub-type="NONE"
              data-cost="0"
            >
              Wait (0)
            </button>
          </div>
        </div>

        <div
          class="slot-group"
          id="reaction-area"
          style="border-top: 1px solid #444; padding-top: 10px"
        >
          <div style="font-size: 0.9em; color: #e74c3c; margin-bottom: 5px">
            âš¡ SP COUNTER (Reaction Phase)
          </div>
          <button class="btn-counter" id="btn-counter">
            SP Counter æ§‹ãˆ (Cost 0)
          </button>
        </div>

        <button
          id="commit-btn"
          style="
            width: 100%;
            padding: 15px;
            background: #d35400;
            border: none;
            font-weight: bold;
            font-size: 1.2em;
            margin-top: 15px;
          "
        >
          ã‚¿ãƒ¼ãƒ³å®Ÿè¡Œ
        </button>
      </div>

      <div id="log-area">
        <div class="log-entry">
          System: AIæ€è€ƒå¼·åŒ–ãƒ‘ãƒƒãƒ Ver 2.7 é©ç”¨å®Œäº†
          (3ã‚³ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰ã®CDã‚’2ã‚¿ãƒ¼ãƒ³ã«å»¶é•·)ã€‚
        </div>
      </div>
    </div>

    <script>
      /* * =================================================================
       * DUSTFALL BATTLE LOGIC - Ver 2.7
       * Updates:
       * - 3-Cost commands for both Player and Enemy now have a 2-turn skip (CD = 3)
       * =================================================================
       */

      // --- Constants ---
      const MAX_EP = 7;
      const MAX_SP = 8;
      const TYPES = {
        ATTACK: "ATTACK",
        GUARD: "GUARD",
        BREAK: "BREAK",
        SPECIAL: "SPECIAL",
        NONE: "NONE",
      };
      const DAMAGE_VALS = {
        ATK_STRONG: 15,
        ATK_FAST: 10,
        BRK_POS: 20,
        CHIP: 3,
        SP_DMG: 45,
      };

      // --- State Management ---
      const state = {
        turn: 1,
        phase: "PREP",
        isPlayerFirst: true,
        bonus: { playerEP: 0, playerSP: 0, enemyEP: 0, enemySP: 0 },

        player: {
          hp: 100,
          maxHp: 100,
          pos: 50,
          maxPos: 50,
          ep: 7,
          sp: 5,
          counterAvailable: true,
          usingCounter: false,
          isStunned: false,
          nextTurnStun: false,
          selection: { s1: null, s2: null },
          cooldowns: {
            ATTACK: 0, // Strong Atk (Cost 3)
            ATTACK2: 0, // Fast Atk (Cost 2)
            GUARD: 0, // Strong Grd (Cost 3 / Slot 2 Cost 1)
            GUARD2: 0, // Light Grd (Cost 2)
            BREAK: 0, // Break (Cost 2)
            SPECIAL: 0,
          },
        },

        enemy: {
          hp: 100,
          maxHp: 100,
          pos: 50,
          maxPos: 50,
          ep: 7,
          sp: 5,
          isStunned: false,
          nextTurnStun: false,
          selection: { s1: null, s2: null },
          personality: "åˆ†æä¸­",

          deck: [
            // â˜… 3ã‚³ã‚¹ãƒˆã®ã‚«ãƒ¼ãƒ‰ã® maxCd ã‚’ 2 ã«å¤‰æ›´ (CDã‚’3ã«è¨­å®š -> 2ã‚¿ãƒ¼ãƒ³ä½¿ç”¨ä¸å¯)
            { id: 1, type: "ATTACK", cost: 3, cd: 0, maxCd: 2 },
            { id: 2, type: "GUARD", cost: 3, cd: 0, maxCd: 2 },
            { id: 3, type: "BREAK", cost: 3, cd: 0, maxCd: 2 },
            // ãã®ä»–ã®ã‚«ãƒ¼ãƒ‰ã® maxCd ã¯ 1 ã®ã¾ã¾ (CDã‚’2ã«è¨­å®š -> 1ã‚¿ãƒ¼ãƒ³ä½¿ç”¨ä¸å¯)
            { id: 4, type: "ATTACK", cost: 2, cd: 0, maxCd: 1 },
            { id: 5, type: "ATTACK", cost: 2, cd: 0, maxCd: 1 },
            { id: 6, type: "GUARD", cost: 2, cd: 0, maxCd: 1 },
            { id: 7, type: "BREAK", cost: 2, cd: 0, maxCd: 1 },
            { id: 8, type: "GUARD", cost: 1, cd: 0, maxCd: 1 },
            { id: 9, type: "SPECIAL", cost: 5, cd: 0, maxCd: 99 },
          ],
        },
      };

      // --- Core Functions ---

      function selectCommand(slot, subType, cost) {
        const p = state.player;
        if (p.isStunned || state.phase !== "INPUT") return;

        let type = TYPES.NONE;
        if (subType.includes("ATTACK")) type = TYPES.ATTACK;
        else if (subType.includes("GUARD")) type = TYPES.GUARD;
        else if (subType.includes("BREAK")) type = TYPES.BREAK;
        else if (subType === "SPECIAL") type = TYPES.SPECIAL;

        if (type !== TYPES.NONE && p.cooldowns[subType] > 0) {
          log(
            `ãã®ã‚³ãƒãƒ³ãƒ‰ã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã˜ã‚ƒ (ã‚ã¨ ${p.cooldowns[subType]} Turn)`,
            "log-danger"
          );
          return;
        }

        const cmd = { type: type, subType: subType, cost: cost };
        if (slot === 1) {
          p.selection.s1 = cmd;
          if (type === TYPES.SPECIAL)
            p.selection.s2 = { type: TYPES.NONE, cost: 0, subType: "NONE" };
        } else {
          p.selection.s2 = cmd;
        }
        updateUI();
      }

      function toggleCounter() {
        if (!state.player.counterAvailable) {
          log("ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã¯æ—¢ã«æ¶ˆè²»æ¸ˆã¿ã˜ã‚ƒã€‚", "log-info");
          return;
        }
        state.player.usingCounter = !state.player.usingCounter;
        updateUI();
      }

      function commitTurn() {
        const p = state.player;
        if (state.phase !== "INPUT") return;

        if (p.isStunned) {
          p.selection = {
            s1: { type: TYPES.NONE, cost: 0, subType: "NONE" },
            s2: { type: TYPES.NONE, cost: 0, subType: "NONE" },
          };
          resolvePhase();
          return;
        }

        if (!p.selection.s1 || !p.selection.s2) {
          alert("ã‚³ãƒãƒ³ãƒ‰æœªé¸æŠã˜ã‚ƒ");
          return;
        }

        const totalCost = p.selection.s1.cost + p.selection.s2.cost;
        if (totalCost > p.ep) {
          alert("EPä¸è¶³ã˜ã‚ƒ");
          return;
        }

        if (p.selection.s1.type === TYPES.SPECIAL) {
          if (p.sp < MAX_SP) {
            alert("SPä¸è¶³ã˜ã‚ƒ (æº€ã‚¿ãƒ³å¿…è¦)");
            return;
          }
        }

        state.phase = "COMMITTING";
        resolvePhase();
      }

      function initGame() {
        // æ€§æ ¼ã¯AIæ±ºå®šãƒ­ã‚¸ãƒƒã‚¯ã§åˆ©ç”¨ã™ã‚‹
        const types = ["æˆ¦è¡“å®¶AI", "çŒ›æ”»å‹AI", "æ…é‡å‹AI"];
        state.enemy.personality =
          types[Math.floor(Math.random() * types.length)];
        updateUI();
        startTurn();
      }

      function startTurn() {
        state.phase = "INPUT";
        log(`--- TURN ${state.turn} ---`, "log-turn");

        applyBonuses(state.player, state.bonus.playerEP, state.bonus.playerSP);
        applyBonuses(state.enemy, state.bonus.enemyEP, state.bonus.enemySP);
        state.bonus = { playerEP: 0, playerSP: 0, enemyEP: 0, enemySP: 0 };

        recoverResources(state.player);
        recoverResources(state.enemy);

        // CDæ¸›å°‘å‡¦ç† (ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚)
        reduceCooldowns();

        state.isPlayerFirst = state.turn % 2 !== 0;
        state.player.selection = { s1: null, s2: null };
        state.player.usingCounter = false;

        // â˜… AIã®æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹å®Ÿè¡Œ
        decideEnemyAction();

        document.getElementById("phase-display").innerText = "å…¥åŠ›ãƒ•ã‚§ãƒ¼ã‚º";

        if (state.isPlayerFirst) {
          log("ã€å…ˆæ”»ã€‘ã‚ãªãŸã®ç•ªã˜ã‚ƒã€‚ç›¸æ‰‹ã®è¡Œå‹•ã¯è¦‹ãˆã¬ã€‚", "log-info");
          document.getElementById("intel-action-reveal").style.display = "none";
        } else {
          log("ã€å¾Œæ”»ã€‘ç›¸æ‰‹ãŒæ§‹ãˆãŸãã€‚éƒ¨åˆ†æƒ…å ±ãŒé–‹ç¤ºã•ã‚Œã‚‹ã€‚", "log-info");

          const cost =
            (state.enemy.selection.s1.cost || 0) +
            (state.enemy.selection.s2.cost || 0);
          document.getElementById("e-ep-cost-reveal").innerText = cost;

          const s1t = state.enemy.selection.s1.type;
          const s2t = state.enemy.selection.s2.type;
          const stanceEl = document.getElementById("e-stance-hint");

          if (s1t === TYPES.SPECIAL || s2t === TYPES.SPECIAL) {
            stanceEl.innerText = "âš ï¸ å¼·å¤§ãªã‚¨ãƒãƒ«ã‚®ãƒ¼åå¿œï¼(SPæŠ€?)";
          } else if (
            [TYPES.ATTACK, TYPES.BREAK].includes(s1t) ||
            [TYPES.ATTACK, TYPES.BREAK].includes(s2t)
          ) {
            stanceEl.innerText = "âš”ï¸ æ•µã¯ã€Œæ”»æ’ƒã®å§¿å‹¢ã€ã«å…¥ã£ã¦ã„ã‚‹ (Atk/Brk)";
          } else if (
            [TYPES.GUARD].includes(s1t) ||
            [TYPES.GUARD].includes(s2t)
          ) {
            stanceEl.innerText = "ğŸ›¡ï¸ æ•µã¯ã€Œå®ˆã‚Šã®å§¿å‹¢ã€ã‚’è¦‹ã›ã¦ã„ã‚‹ (Guard)";
          } else {
            stanceEl.innerText = "æ•µã®æ§˜å­ãŒèª­ã‚ãªã„ (Wait?)";
          }

          document.getElementById("intel-action-reveal").style.display =
            "block";
        }

        updateUI();
      }

      function recoverResources(char) {
        if (!char.isStunned) char.ep = Math.min(char.ep + 3, MAX_EP);
        char.sp = Math.min(char.sp + 1, MAX_SP);
        char.pos = Math.min(char.pos + 5, char.maxPos);
      }

      function reduceCooldowns() {
        // Player CDæ¸›å°‘
        for (let k in state.player.cooldowns) {
          if (state.player.cooldowns[k] > 0) state.player.cooldowns[k]--;
        }
        // Enemy CDæ¸›å°‘
        state.enemy.deck.forEach((card) => {
          if (card.cd > 0) card.cd--;
        });
      }

      function applyBonuses(char, addEp, addSp) {
        if (addEp > 0) char.ep = Math.min(char.ep + addEp, MAX_EP);
        if (addSp > 0) char.sp = Math.min(char.sp + addSp, MAX_SP);
      }

      // â˜…â˜…â˜… AIãƒ­ã‚¸ãƒƒã‚¯ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼CDã‚’è€ƒæ…®ã—ã¦è³¢ãé¸æŠ â˜…â˜…â˜…
      function decideEnemyAction() {
        const e = state.enemy;
        const p = state.player;

        if (e.isStunned) {
          e.selection = {
            s1: { type: TYPES.NONE, cost: 0 },
            s2: { type: TYPES.NONE, cost: 0 },
          };
          return;
        }

        // 1. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼±ç‚¹ï¼ˆCDçŠ¶æ³ï¼‰ã‚’åˆ†æ
        // CD>0 ãªã‚‰ãã®è¡Œå‹•ã¯å–ã‚Œãªã„ã€‚
        const pCannotGuardStrong = p.cooldowns["GUARD"] > 0; // Cost 3 Guard
        const pCannotAttackStrong = p.cooldowns["ATTACK"] > 0; // Cost 3 Attack
        const pCannotBreak = p.cooldowns["BREAK"] > 0; // Break

        // 2. SPæŠ€ã®ä½¿ç”¨åˆ¤å®š (å„ªå…ˆåº¦MAX)
        const availableCards = e.deck.filter((c) => c.cd === 0);
        const spCard = availableCards.find((c) => c.type === TYPES.SPECIAL);

        if (e.sp >= MAX_SP && spCard) {
          // ç¢ºç‡ã§ã¶ã£æ”¾ã™
          if (Math.random() < 0.8) {
            e.selection = {
              s1: { ...spCard },
              s2: { type: TYPES.NONE, cost: 0 },
            };
            return;
          }
        }

        // 3. é€šå¸¸ã‚«ãƒ¼ãƒ‰ã®è©•ä¾¡ï¼ˆé‡ã¿ä»˜ã‘ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ï¼‰
        // ã‚¹ã‚³ã‚¢ãŒé«˜ã„ã»ã©é¸ã°ã‚Œã‚„ã™ãã™ã‚‹
        const scoredCards = availableCards
          .filter((c) => c.type !== TYPES.SPECIAL)
          .map((card) => {
            let score = Math.random() * 20; // ãƒ™ãƒ¼ã‚¹ä¹±æ•°

            // æˆ¦æ³ã«å¿œã˜ãŸè£œæ­£
            if (card.type === TYPES.ATTACK) {
              // ç›¸æ‰‹ãŒå¼·ã‚¬ãƒ¼ãƒ‰ã§ããªã„ãªã‚‰ã€å¼·æ”»æ’ƒ(Cost3)ã®ä¾¡å€¤æ¿€å¢—
              if (card.cost >= 3 && pCannotGuardStrong) score += 60;
              // ç›¸æ‰‹ãŒå¼·æ”»æ’ƒã§ããªã„ãªã‚‰ã€å°‘ã—å¼·æ°—ã«æ”»ã‚ã‚‹
              if (pCannotAttackStrong) score += 20;
            } else if (card.type === TYPES.GUARD) {
              // ç›¸æ‰‹ãŒãƒ–ãƒ¬ã‚¤ã‚¯ã§ããªã„ãªã‚‰ã€ã‚¬ãƒ¼ãƒ‰ã¯å®‰å…¨
              if (pCannotBreak) score += 50;
              // HPãŒæ¸›ã£ã¦ãŸã‚‰ã‚¬ãƒ¼ãƒ‰å„ªå…ˆ
              if (e.hp < 40) score += 30;
            } else if (card.type === TYPES.BREAK) {
              // ç›¸æ‰‹ãŒå¼·ã‚¬ãƒ¼ãƒ‰ã§ããªã„ãªã‚‰ã€ãƒ–ãƒ¬ã‚¤ã‚¯ã®ä¾¡å€¤ã¯ä¸‹ãŒã‚‹(ã‚¬ãƒ¼ãƒ‰ã—ã¦ã“ãªã„ç¢ºç‡é«˜ã„)
              if (pCannotGuardStrong) score -= 20;
              else score += 30; // ç›¸æ‰‹ãŒã‚¬ãƒ¼ãƒ‰ã§ãã‚‹çŠ¶æ…‹ãªã‚‰ãƒ–ãƒ¬ã‚¤ã‚¯ç‹™ã„
            }

            return { card, score };
          });

        // ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
        scoredCards.sort((a, b) => b.score - a.score);

        // 4. ã‚¹ãƒ­ãƒƒãƒˆæ§‹ç¯‰ (EPã«åã¾ã‚‹ã‚ˆã†ã«é«˜ã„é †ã‹ã‚‰æ¡ç”¨)
        let s1 = null,
          s2 = null;

        // ãƒ™ã‚¹ãƒˆãªã‚«ãƒ¼ãƒ‰ã‚’S1ã«
        if (scoredCards.length > 0) {
          if (scoredCards[0].card.cost <= e.ep) {
            s1 = scoredCards[0].card;
          }
        }

        // æ®‹ã‚ŠEPã§S2ã‚’æ¢ã™
        if (s1) {
          const remEp = e.ep - s1.cost;
          // S1ã¨åŒã˜IDã®ã‚«ãƒ¼ãƒ‰ã¯ä½¿ãˆãªã„(Deckä»•æ§˜)
          const candidates = scoredCards.filter(
            (sc) => sc.card.id !== s1.id && sc.card.cost <= remEp
          );
          if (candidates.length > 0) {
            s2 = candidates[0].card;
          }
        } else {
          // S1ã™ã‚‰æ±ºã¾ã‚‰ãªã‹ã£ãŸå ´åˆ(ç¨€ã ãŒEPä¸è¶³ç­‰)ã€Wait
          s1 = { type: TYPES.NONE, cost: 0 };
        }

        e.selection.s1 = s1 ? { ...s1 } : { type: TYPES.NONE, cost: 0 };
        e.selection.s2 = s2 ? { ...s2 } : { type: TYPES.NONE, cost: 0 };

        // ãƒ­ã‚°ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼šAIãŒä½•ã‚’è€ƒãˆãŸã‹ï¼‰
        if (Math.random() < 0.5 && !state.isPlayerFirst) {
          if (pCannotGuardStrong && s1.type === TYPES.ATTACK)
            log("AI: (ã‚ã„ã¤Guardåˆ‡ã‚Œã â€¦å¥½æ©Ÿï¼)", "log-ai");
          else if (pCannotBreak && s1.type === TYPES.GUARD)
            log("AI: (Breakåˆ‡ã‚Œã‹ã€‚å®ˆã‚Šã¯é‰„å£ã )", "log-ai");
        }
      }

      function resolvePhase() {
        state.phase = "RESOLVE";
        document.getElementById("phase-display").innerText = "è§£æ±ºãƒ•ã‚§ãƒ¼ã‚º";
        const p = state.player;
        const e = state.enemy;

        log(
          `Player: [${p.selection.s1.subType || "Wait"}] -> [${
            p.selection.s2.subType || "Wait"
          }]`,
          "log-info"
        );
        log(
          `Enemy : [${e.selection.s1.type}] -> [${e.selection.s2.type}]`,
          "log-info"
        );

        if (p.usingCounter) {
          p.counterAvailable = false;
          if (e.selection.s1.type === TYPES.SPECIAL) {
            log(">>> ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼æˆåŠŸï¼æ•µSPã‚’ç„¡åŠ¹åŒ–ã—ã‚¹ã‚¿ãƒ³ï¼", "log-danger");
            e.selection.s1.type = TYPES.NONE;
            e.selection.s2.type = TYPES.NONE;
            e.isStunned = true;
            e.sp = 0;
          } else {
            log(">>> ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ä¸ç™ºâ€¦ (æ¨©åˆ©æ¶ˆå¤±)", "log-info");
          }
        }

        let skipSlot1 = false;
        const pUseSp = p.selection.s1.type === TYPES.SPECIAL;
        const eUseSp = e.selection.s1.type === TYPES.SPECIAL;

        if (pUseSp && eUseSp) {
          log("SPç›¸æ®ºï¼", "log-sp");
          p.sp = 0;
          e.sp = 0;
          skipSlot1 = true;
        } else if (pUseSp) {
          applyDamage(e, DAMAGE_VALS.SP_DMG, "HP");
          p.sp = 0;
          skipSlot1 = true;
        } else if (eUseSp) {
          applyDamage(p, DAMAGE_VALS.SP_DMG, "HP");
          e.sp = 0;
          skipSlot1 = true;
        }

        let pSlot2Mod = 1.0;
        let eSlot2Mod = 1.0;

        if (!skipSlot1) {
          const res1 = resolveCollision(
            p.selection.s1,
            e.selection.s1,
            1.0,
            1.0
          );

          if (res1 === "WIN") {
            log(
              ">> S1å‹åˆ©ï¼ Playeræ¬¡æ‰‹1.5å€ / Enemyæ¬¡æ‰‹0.2å€(å´©ã‚Œ)",
              "log-info"
            );
            pSlot2Mod = 1.5;
            eSlot2Mod = 0.2;
          } else if (res1 === "LOSE") {
            log(
              ">> S1æ•—åŒ—â€¦ Playeræ¬¡æ‰‹0.2å€(å´©ã‚Œ) / Enemyæ¬¡æ‰‹1.5å€",
              "log-danger"
            );
            pSlot2Mod = 0.2;
            eSlot2Mod = 1.5;
          } else {
            log(">> S1å¼•ãåˆ†ã‘ã€‚å½±éŸ¿ãªã—ã€‚", "log-info");
          }
        }

        if (!p.isStunned && !e.isStunned) {
          resolveCollision(
            p.selection.s2,
            e.selection.s2,
            pSlot2Mod,
            eSlot2Mod
          );
        }

        p.ep = Math.max(0, p.ep - (p.selection.s1.cost + p.selection.s2.cost));
        e.ep = Math.max(0, e.ep - (e.selection.s1.cost + e.selection.s2.cost));

        // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³è¨­å®š
        setCooldown(p, p.selection.s1);
        setCooldown(p, p.selection.s2);

        // æ•µãƒ‡ãƒƒã‚­CDè¨­å®š
        if (e.selection.s1.id) {
          const c = e.deck.find((x) => x.id === e.selection.s1.id);
          if (c) c.cd = c.maxCd + 1;
        }
        if (e.selection.s2.id) {
          const c = e.deck.find((x) => x.id === e.selection.s2.id);
          if (c) c.cd = c.maxCd + 1;
        }

        endTurnProcessing();
      }

      // â˜… ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼CDè¨­å®šé–¢æ•°ã®ä¿®æ­£
      function setCooldown(char, cmd) {
        if (!cmd || cmd.type === TYPES.NONE) return;
        if (char === state.player && cmd.subType) {
          let cooldownTurns = 2; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯1ã‚¿ãƒ¼ãƒ³ä½¿ç”¨ä¸å¯ (CD=2)

          if (cmd.cost === 3) {
            // 3ã‚³ã‚¹ãƒˆã®ã‚³ãƒãƒ³ãƒ‰ã¯ã€æ¬¡ã®2ã‚¿ãƒ¼ãƒ³ï¼ˆã‚¿ãƒ¼ãƒ³+1, ã‚¿ãƒ¼ãƒ³+2ï¼‰ä½¿ç”¨ä¸å¯ã«ã™ã‚‹ãŸã‚3ã‚’è¨­å®š
            cooldownTurns = 3;
          }
          // ã‚¿ãƒ¼ãƒ³å®Ÿè¡Œå¾Œã€æ¬¡ã®ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«-1ã•ã‚Œã€0ã«ãªã‚‹ã¾ã§æœ‰åŠ¹ã€‚
          char.cooldowns[cmd.subType] = cooldownTurns;
        }
      }

      function resolveCollision(pCmd, eCmd, pMod, eMod) {
        if (pCmd.type === TYPES.NONE && eCmd.type === TYPES.NONE) return "DRAW";
        const tri = getTriangleResult(pCmd.type, eCmd.type);

        if (pCmd.type !== TYPES.NONE && pCmd.type === eCmd.type) {
          if (pCmd.type === TYPES.ATTACK) {
            log("äº’ã„ã«æ”»æ’ƒï¼(å§¿å‹¢å¾®æ¸›)", "log-info");
            applyDamage(state.player, 5, "POS");
            applyDamage(state.enemy, 5, "POS");
          } else if (pCmd.type === TYPES.GUARD) {
            log("äº’ã„ã«ã‚¬ãƒ¼ãƒ‰ (EP+1)", "log-info");
            state.player.ep = Math.min(state.player.ep + 1, MAX_EP);
            state.enemy.ep = Math.min(state.enemy.ep + 1, MAX_EP);
          } else if (pCmd.type === TYPES.BREAK) {
            log("ãƒ–ãƒ¬ã‚¤ã‚¯ç›¸æ®º (åŠ¹æœåŠæ¸›)", "log-info");
            applyDamage(state.enemy, (DAMAGE_VALS.BRK_POS / 2) * pMod, "POS");
            applyDamage(state.player, (DAMAGE_VALS.BRK_POS / 2) * eMod, "POS");
          }
          return "DRAW";
        }

        if (tri === 1) {
          executeAction(state.player, state.enemy, pCmd, pMod, true);
          executeAction(state.enemy, state.player, eCmd, eMod, false);
          return "WIN";
        } else if (tri === -1) {
          executeAction(state.enemy, state.player, eCmd, eMod, true);
          executeAction(state.player, state.enemy, pCmd, pMod, false);
          return "LOSE";
        } else {
          if (pCmd.type !== TYPES.NONE)
            executeAction(state.player, state.enemy, pCmd, pMod, true);
          if (eCmd.type !== TYPES.NONE)
            executeAction(state.enemy, state.player, eCmd, eMod, true);
          return "DRAW";
        }
      }

      function getTriangleResult(t1, t2) {
        if (t1 === t2) return 0;
        if (t1 === TYPES.ATTACK && t2 === TYPES.BREAK) return 1;
        if (t1 === TYPES.BREAK && t2 === TYPES.GUARD) return 1;
        if (t1 === TYPES.GUARD && t2 === TYPES.ATTACK) return 1;
        if (t2 === TYPES.ATTACK && t1 === TYPES.BREAK) return -1;
        if (t2 === TYPES.BREAK && t1 === TYPES.GUARD) return -1;
        if (t2 === TYPES.GUARD && t1 === TYPES.ATTACK) return -1;
        return 0;
      }

      function executeAction(actor, target, cmd, mod, isWinningSide) {
        if (cmd.type === TYPES.NONE) return;
        let finalMod = mod;
        if (!isWinningSide) {
          if (cmd.type === TYPES.ATTACK) finalMod = 0;
          if (cmd.type === TYPES.BREAK) finalMod = 0;
        }

        if (cmd.type === TYPES.ATTACK) {
          let dmg =
            cmd.subType === "ATTACK2"
              ? DAMAGE_VALS.ATK_FAST
              : DAMAGE_VALS.ATK_STRONG;
          if (!isWinningSide && target.selection.s1.type === TYPES.GUARD) {
            applyDamage(target, DAMAGE_VALS.CHIP, "HP");
          } else if (isWinningSide) {
            applyDamage(target, dmg * finalMod, "HP");
          }
        } else if (cmd.type === TYPES.BREAK && isWinningSide) {
          applyDamage(target, DAMAGE_VALS.BRK_POS * finalMod, "POS");
        }
      }

      function applyDamage(target, val, type) {
        if (val <= 0) return;
        if (target.isStunned) val *= 2;
        val = Math.floor(val);
        if (type === "HP") {
          target.hp = Math.max(0, target.hp - val);
          log(
            `${target === state.player ? "Player" : "Enemy"} HP -${val}`,
            "log-danger"
          );
        } else if (type === "POS") {
          target.pos = Math.max(0, target.pos - val);
          log(
            `${target === state.player ? "Player" : "Enemy"} Pos -${val}`,
            "log-pos"
          );
          if (target.pos === 0 && !target.isStunned) {
            target.nextTurnStun = true;
            log(
              `>> ${target === state.player ? "Player" : "Enemy"} BREAK!!`,
              "log-danger"
            );
          }
        }
      }

      function endTurnProcessing() {
        if (state.player.hp <= 0 || state.enemy.hp <= 0) {
          setTimeout(() => {
            alert(state.player.hp <= 0 ? "æ•—åŒ—..." : "å‹åˆ©ï¼");
            location.reload();
          }, 500);
          return;
        }

        const updateStun = (c) => {
          if (c.nextTurnStun) {
            c.isStunned = true;
            c.nextTurnStun = false;
            c.pos = c.maxPos;
          } else {
            c.isStunned = false;
          }
        };
        updateStun(state.player);
        updateStun(state.enemy);

        if (state.player.ep >= 1) state.bonus.playerEP = 1;
        if (state.player.ep === 0) state.bonus.playerSP = 1;
        if (state.enemy.ep >= 1) state.bonus.enemyEP = 1;
        if (state.enemy.ep === 0) state.bonus.enemySP = 1;

        state.turn++;
        setTimeout(startTurn, 1000);
      }

      function updateUI() {
        const p = state.player;
        const e = state.enemy;
        const setBar = (id, c, m) =>
          (document.getElementById(id).style.width = (c / m) * 100 + "%");

        setBar("p-hp-bar", p.hp, p.maxHp);
        setBar("p-pos-bar", p.pos, p.maxPos);
        setBar("p-sp-bar", p.sp, MAX_SP);

        setBar("e-hp-bar", e.hp, e.maxHp);
        setBar("e-pos-bar", e.pos, e.maxPos);
        setBar("e-sp-bar", e.sp, MAX_SP);

        const spBarP = document.getElementById("p-sp-bar");
        if (p.sp >= MAX_SP) spBarP.classList.add("sp-max-glow");
        else spBarP.classList.remove("sp-max-glow");

        const spBarE = document.getElementById("e-sp-bar");
        if (e.sp >= MAX_SP) spBarE.classList.add("sp-max-glow");
        else spBarE.classList.remove("sp-max-glow");

        document.getElementById("p-hp-text").innerText = `${p.hp}/${p.maxHp}`;
        document.getElementById(
          "p-pos-text"
        ).innerText = `${p.pos}/${p.maxPos}`;
        document.getElementById("p-sp-text").innerText = `${p.sp}/${MAX_SP}`;
        document.getElementById("e-hp-text").innerText = `${e.hp}/${e.maxHp}`;
        document.getElementById(
          "e-pos-text"
        ).innerText = `${e.pos}/${e.maxPos}`;
        document.getElementById("e-sp-text").innerText = `${e.sp}/${MAX_SP}`;
        document.getElementById("p-ep").innerText = p.ep;

        const pcEl = document.getElementById("p-counter-status");
        if (p.counterAvailable) {
          pcEl.innerText = "å¯èƒ½ (1å›)";
          pcEl.style.color = "#3498db";
        } else {
          pcEl.innerText = "æ¶ˆè²»æ¸ˆ";
          pcEl.style.color = "#555";
        }

        document.getElementById("p-badges").innerHTML = p.isStunned
          ? '<span class="badge badge-stun">STUN</span>'
          : "";
        document.getElementById("e-badges").innerHTML = e.isStunned
          ? '<span class="badge badge-stun">STUN</span>'
          : "";

        const updateBtns = (btns) => {
          btns.forEach((btn) => {
            const subType = btn.getAttribute("data-sub-type");
            const slot = btn.getAttribute("data-slot");
            const selection = slot === "1" ? p.selection.s1 : p.selection.s2;

            if (selection && selection.subType === subType)
              btn.classList.add("selected");
            else btn.classList.remove("selected");

            let disabled = false;
            let title = "";
            if (p.cooldowns[subType] > 0) {
              disabled = true;
              title = `CD: ${p.cooldowns[subType]}`;
            }
            if (
              btn.getAttribute("data-sub-type") === "SPECIAL" &&
              p.sp < MAX_SP
            ) {
              disabled = true;
              title = "SPã‚²ãƒ¼ã‚¸ä¸è¶³";
            }
            if (
              slot === "2" &&
              p.selection.s1?.subType === "SPECIAL" &&
              subType !== "NONE"
            ) {
              disabled = true;
            }

            if (p.isStunned || state.phase !== "INPUT") disabled = true;
            btn.disabled = disabled;
            if (title) btn.title = title;
          });
        };
        updateBtns(
          document.getElementById("s1-btns").querySelectorAll("button")
        );
        updateBtns(
          document.getElementById("s2-btns").querySelectorAll("button")
        );

        const cost = (p.selection.s1?.cost || 0) + (p.selection.s2?.cost || 0);
        const ce = document.getElementById("total-cost");
        ce.innerText = cost;
        ce.style.color = cost > p.ep ? "#e74c3c" : "#eee";

        const grid = document.getElementById("e-cd-grid");
        grid.innerHTML = "";

        const costGroups = { 3: [], 2: [], 1: [] };
        e.deck.forEach((c) => {
          if (c.type === "SPECIAL") return;
          if (costGroups[c.cost]) costGroups[c.cost].push(c);
        });

        [3, 2, 1].forEach((cost) => {
          const cards = costGroups[cost];
          const total = cards.length;
          const active = cards.filter((c) => c.cd > 0).length;

          const row = document.createElement("div");
          row.className = "cd-row";
          if (active > 0) row.style.borderColor = "#666";

          const cdNote = cost === 3 ? "(2-Turn CD)" : "(1-Turn CD)";

          row.innerHTML = `
                <span>COST ${cost} ${cdNote}</span>
                <span class="${
                  active > 0 ? "cd-alert" : ""
                }">${active} / ${total} on CD</span>
            `;
          grid.appendChild(row);
        });

        const cBtn = document.getElementById("btn-counter");
        if (!p.counterAvailable) {
          cBtn.disabled = true;
          cBtn.innerText = "SP Counter (ä½¿ç”¨æ¸ˆ)";
          cBtn.classList.remove("selected");
        } else {
          cBtn.disabled = p.isStunned || state.phase !== "INPUT";
          cBtn.innerText = p.usingCounter
            ? ">> ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å¾…æ©Ÿä¸­ <<"
            : "SP Counter æ§‹ãˆ (Cost 0)";
          p.usingCounter
            ? cBtn.classList.add("selected")
            : cBtn.classList.remove("selected");
        }

        const commit = document.getElementById("commit-btn");
        if (state.phase !== "INPUT") {
          commit.disabled = true;
          commit.innerText = "è§£æ±ºå¾…æ©Ÿä¸­...";
        } else if (p.isStunned) {
          commit.disabled = false;
          commit.innerText = "ã‚¹ã‚¿ãƒ³ä¸­ (ã‚¹ã‚­ãƒƒãƒ—)";
        } else if (cost > p.ep) {
          commit.disabled = true;
          commit.innerText = "EPä¸è¶³";
        } else if (!p.selection.s1 || !p.selection.s2) {
          commit.disabled = true;
          commit.innerText = "ã‚³ãƒãƒ³ãƒ‰æœªé¸æŠ";
        } else {
          commit.disabled = false;
          commit.innerText = "ã‚¿ãƒ¼ãƒ³å®Ÿè¡Œ";
        }

        document.getElementById("turn-count").innerText = state.turn;
      }

      function log(msg, cls = "") {
        const d = document.createElement("div");
        d.className = `log-entry ${cls}`;
        d.innerText = `[T${state.turn}] ${msg}`;
        document.getElementById("log-area").prepend(d);
      }

      // --- Event Listeners ---
      document.addEventListener("DOMContentLoaded", () => {
        document
          .querySelectorAll("#s1-btns button, #s2-btns button")
          .forEach((button) => {
            button.addEventListener("click", (event) => {
              const slot = parseInt(
                event.currentTarget.getAttribute("data-slot")
              );
              const subType = event.currentTarget.getAttribute("data-sub-type");
              const cost = parseInt(
                event.currentTarget.getAttribute("data-cost")
              );
              selectCommand(slot, subType, cost);
            });
          });

        document
          .getElementById("btn-counter")
          .addEventListener("click", toggleCounter);
        document
          .getElementById("commit-btn")
          .addEventListener("click", commitTurn);

        initGame();
      });
    </script>
  </body>
</html>
