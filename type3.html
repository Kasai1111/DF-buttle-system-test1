<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>DUSTFALL Battle Ver 3.0 (Hand & Burnout)</title>
    <style>
      /* --- Âü∫Êú¨„Çπ„Çø„Ç§„É´ --- */
      body {
        font-family: "Segoe UI", "Meiryo", sans-serif;
        background: #121212;
        color: #eee;
        padding: 20px;
        line-height: 1.4;
      }
      .container {
        max-width: 1000px;
        margin: 0 auto;
      }

      /* --- „Éò„ÉÉ„ÉÄ„Éº --- */
      .header {
        text-align: center;
        margin-bottom: 20px;
        border-bottom: 2px solid #333;
        padding-bottom: 15px;
      }
      .turn-badge {
        background: #3498db;
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-weight: bold;
        font-size: 1.2em;
      }
      .phase-text {
        color: #f39c12;
        margin-left: 10px;
        font-weight: bold;
      }

      /* --- „Éê„Éà„É´„Ç®„É™„Ç¢ --- */
      .battle-area {
        display: flex;
        gap: 20px;
        justify-content: center;
        margin-bottom: 20px;
      }
      .char-box {
        flex: 1;
        background: #1e1e1e;
        border: 1px solid #444;
        border-radius: 8px;
        padding: 15px;
        position: relative;
        transition: all 0.3s;
      }
      .char-box.burnout {
        border-color: #e74c3c;
        box-shadow: 0 0 15px rgba(231, 76, 60, 0.4);
      }
      .char-box.active {
        border-color: #f1c40f;
      }

      .burnout-label {
        position: absolute;
        top: -10px;
        right: 10px;
        background: #e74c3c;
        color: white;
        font-size: 0.8em;
        padding: 2px 8px;
        border-radius: 4px;
        font-weight: bold;
        animation: pulse 1s infinite;
        display: none;
      }
      .char-box.burnout .burnout-label {
        display: block;
      }

      @keyframes pulse {
        0% {
          opacity: 0.8;
        }
        50% {
          opacity: 1;
          transform: scale(1.05);
        }
        100% {
          opacity: 0.8;
        }
      }

      /* „Éê„ÉºË°®Á§∫ */
      .bar-row {
        margin-bottom: 8px;
        font-size: 0.9em;
      }
      .bar-bg {
        background: #333;
        height: 12px;
        border-radius: 6px;
        overflow: hidden;
        margin-top: 2px;
      }
      .bar-fill {
        height: 100%;
        transition: width 0.5s;
      }
      .hp-fill {
        background: linear-gradient(90deg, #c0392b, #e74c3c);
      }
      .pos-fill {
        background: linear-gradient(90deg, #d35400, #f39c12);
      }
      .sp-fill {
        background: linear-gradient(90deg, #8e44ad, #9b59b6);
      }

      /* „Ç§„É≥„ÉÜ„É´ÔºàÊÉÖÂ†±Ôºâ */
      .intel-panel {
        background: #000;
        border: 1px dashed #555;
        padding: 10px;
        margin-top: 15px;
        font-size: 0.85em;
        color: #aaa;
        border-radius: 4px;
      }
      .hand-intel {
        display: flex;
        justify-content: space-around;
        margin-top: 5px;
        font-weight: bold;
        color: #fff;
      }
      .intel-icon {
        font-size: 1.2em;
        margin-right: 4px;
      }

      /* --- Êìç‰Ωú„Ç®„É™„Ç¢ --- */
      .control-panel {
        background: #252525;
        padding: 20px;
        border-radius: 8px;
        border-top: 4px solid #444;
      }

      .slot-container {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
        justify-content: center;
      }
      .slot-box {
        width: 200px;
        height: 60px;
        border: 2px dashed #666;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #1a1a1a;
        cursor: pointer;
        position: relative;
      }
      .slot-box.filled {
        border-style: solid;
        border-color: #3498db;
        background: #2c3e50;
        color: #fff;
        font-weight: bold;
      }
      .slot-label {
        position: absolute;
        top: -20px;
        left: 0;
        font-size: 0.8em;
        color: #888;
      }
      .slot-remove {
        position: absolute;
        top: -10px;
        right: -10px;
        background: #e74c3c;
        color: white;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        text-align: center;
        line-height: 20px;
        font-size: 0.8em;
        display: none;
      }
      .slot-box.filled .slot-remove {
        display: block;
      }

      /* ÊâãÊú≠„Ç´„Éº„Éâ */
      .hand-area {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }
      .card {
        width: 130px;
        height: 160px;
        background: #3e3e3e;
        border: 1px solid #555;
        border-radius: 8px;
        padding: 10px;
        cursor: pointer;
        transition: transform 0.2s;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        position: relative;
        user-select: none;
      }
      .card:hover:not(.disabled) {
        transform: translateY(-5px);
        background: #4a4a4a;
      }
      .card.disabled {
        opacity: 0.4;
        cursor: not-allowed;
        filter: grayscale(1);
      }
      .card.selected {
        border: 2px solid #f1c40f;
        background: #2c3e50;
      }

      .card-cost {
        position: absolute;
        top: 5px;
        right: 5px;
        background: #111;
        color: #fff;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        text-align: center;
        line-height: 24px;
        font-weight: bold;
        font-size: 0.9em;
      }
      .card-type {
        font-weight: bold;
        text-align: center;
        margin-top: 15px;
        font-size: 1.1em;
      }
      .card-sub {
        font-size: 0.8em;
        text-align: center;
        color: #aaa;
      }
      .card-desc {
        font-size: 0.75em;
        color: #ccc;
        text-align: center;
        border-top: 1px solid #555;
        padding-top: 5px;
      }

      /* „Çø„Ç§„ÉóÂà•„Ç´„É©„Éº */
      .type-atk {
        border-bottom: 4px solid #e74c3c;
      }
      .type-grd {
        border-bottom: 4px solid #3498db;
      }
      .type-brk {
        border-bottom: 4px solid #f1c40f;
      }
      .type-sp {
        border-bottom: 4px solid #9b59b6;
        background: linear-gradient(135deg, #2c1a3d, #4b2c68);
      }

      .action-btn {
        width: 100%;
        padding: 15px;
        font-size: 1.2em;
        font-weight: bold;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        background: #d35400;
        color: white;
        transition: background 0.3s;
      }
      .action-btn:disabled {
        background: #555;
        cursor: not-allowed;
      }
      .ep-warn {
        color: #e74c3c;
        font-weight: bold;
      }

      /* --- „É≠„Ç∞ --- */
      .log-area {
        background: #000;
        height: 250px;
        overflow-y: auto;
        padding: 10px;
        margin-top: 20px;
        border: 1px solid #333;
        font-family: "Consolas", monospace;
        font-size: 0.9em;
      }
      .log-entry {
        margin-bottom: 4px;
        border-bottom: 1px solid #222;
        padding-bottom: 2px;
      }
      .log-turn {
        color: #3498db;
        font-weight: bold;
        margin-top: 10px;
        border-top: 1px dashed #555;
        padding-top: 5px;
      }
      .log-dmg {
        color: #e74c3c;
      }
      .log-pos {
        color: #f39c12;
      }
      .log-armor {
        color: #f1c40f;
        font-weight: bold;
      }
      .log-burnout {
        color: #e74c3c;
        font-weight: bold;
        background: rgba(231, 76, 60, 0.1);
        padding: 2px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>DUSTFALL Ver 3.0</h1>
        <div>
          <span class="turn-badge">TURN <span id="turn-cnt">1</span></span>
          <span class="phase-text" id="phase-txt">Draw Phase</span>
        </div>
      </div>

      <div class="battle-area">
        <div class="char-box" id="p-box">
          <h3>üéÆ Player <span class="burnout-label">BURNOUT</span></h3>
          <div class="bar-row">
            <div>HP <span id="p-hp-txt">100</span></div>
            <div class="bar-bg">
              <div
                id="p-hp-bar"
                class="bar-fill hp-fill"
                style="width: 100%"
              ></div>
            </div>
          </div>
          <div class="bar-row">
            <div>Posture <span id="p-pos-txt">50</span></div>
            <div class="bar-bg">
              <div
                id="p-pos-bar"
                class="bar-fill pos-fill"
                style="width: 100%"
              ></div>
            </div>
          </div>
          <div class="bar-row">
            <div>SP <span id="p-sp-txt">0/8</span></div>
            <div class="bar-bg">
              <div
                id="p-sp-bar"
                class="bar-fill sp-fill"
                style="width: 0%"
              ></div>
            </div>
          </div>
          <div
            style="
              margin-top: 10px;
              display: flex;
              justify-content: space-between;
            "
          >
            <div>
              EP:
              <span
                id="p-ep"
                style="font-size: 1.4em; color: #3498db; font-weight: bold"
                >7</span
              >
              / 7
            </div>
            <div id="p-status-badges"></div>
          </div>
        </div>

        <div class="char-box" id="e-box">
          <h3>üëæ Enemy <span class="burnout-label">BURNOUT</span></h3>
          <div class="bar-row">
            <div>HP <span id="e-hp-txt">100</span></div>
            <div class="bar-bg">
              <div
                id="e-hp-bar"
                class="bar-fill hp-fill"
                style="width: 100%"
              ></div>
            </div>
          </div>
          <div class="bar-row">
            <div>Posture <span id="e-pos-txt">50</span></div>
            <div class="bar-bg">
              <div
                id="e-pos-bar"
                class="bar-fill pos-fill"
                style="width: 100%"
              ></div>
            </div>
          </div>
          <div class="bar-row">
            <div>SP <span id="e-sp-txt">0/8</span></div>
            <div class="bar-bg">
              <div
                id="e-sp-bar"
                class="bar-fill sp-fill"
                style="width: 0%"
              ></div>
            </div>
          </div>

          <div class="intel-panel">
            <div>üëÅÔ∏è Êïµ„ÅÆÊâãÊú≠ÊÉÖÂ†± (Hand Intel):</div>
            <div class="hand-intel" id="e-hand-intel">
              <span>‚öîÔ∏è ?</span> <span>üõ°Ô∏è ?</span> <span>üí• ?</span>
            </div>
            <div
              id="e-burnout-warn"
              style="
                color: #e74c3c;
                font-size: 0.8em;
                margin-top: 5px;
                display: none;
              "
            >
              ‚ö†Ô∏è Êïµ„ÅØ„Éê„Éº„É≥„Ç¢„Ç¶„Éà‰∏≠ (Èò≤Âæ°‰∏çÂèØ / Ë¢´„ÉÄ„É°1.5ÂÄç)
            </div>
          </div>

          <div
            id="enemy-move-hint"
            style="
              margin-top: 10px;
              border-top: 1px solid #444;
              padding-top: 5px;
              display: none;
            "
          >
            <div style="color: #f39c12; font-size: 0.9em">
              ‚ö†Ô∏è Êïµ„ÅÆÊ∂àË≤ªEP:
              <span id="e-ep-reveal" style="font-size: 1.2em; font-weight: bold"
                >?</span
              >
            </div>
            <div style="font-size: 0.8em; color: #888">
              (ÊâãÊú≠ÊÉÖÂ†±„Å®Âêà„Çè„Åõ„Å¶Êé®Ê∏¨„Åõ„Çà)
            </div>
          </div>
        </div>
      </div>

      <div class="control-panel">
        <div
          style="
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
          "
        >
          <div id="msg-area">ÊâãÊú≠„Åã„Çâ„Ç≥„Éû„É≥„Éâ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ (Max 2)</div>
          <div>
            Cost: <span id="current-cost">0</span> /
            <span id="max-cost">7</span>
          </div>
        </div>

        <div class="slot-container">
          <div class="slot-box" id="slot1" onclick="removeSlot(1)">
            <span class="slot-label">SLOT 1 (Main)</span>
            <span id="slot1-txt" style="color: #666">Empty</span>
            <div class="slot-remove">√ó</div>
          </div>
          <div class="slot-box" id="slot2" onclick="removeSlot(2)">
            <span class="slot-label">SLOT 2 (Follow)</span>
            <span id="slot2-txt" style="color: #666">Empty</span>
            <div class="slot-remove">√ó</div>
          </div>
        </div>

        <div
          id="counter-area"
          style="text-align: center; margin-bottom: 15px; display: none"
        >
          <button
            id="btn-counter"
            class="card"
            style="
              width: 100%;
              height: 40px;
              flex-direction: row;
              align-items: center;
              justify-content: center;
              background: #2c3e50;
              border-color: #e74c3c;
            "
          >
            ‚ö° SP Counter (Cost 0) - Áõ∏Êâã„ÅÆSPÊäÄ„ÇíÁÑ°ÂäπÂåñ
          </button>
        </div>

        <div class="hand-area" id="p-hand"></div>

        <button id="commit-btn" class="action-btn" onclick="commitTurn()">
          „Çø„Éº„É≥ÂÆüË°å
        </button>
      </div>

      <div class="log-area" id="log">
        <div class="log-entry">System: Ver 3.0 Loaded.</div>
        <div class="log-entry">
          System: ÊâãÊú≠„Ç∑„Çπ„ÉÜ„É† & „Éê„Éº„É≥„Ç¢„Ç¶„ÉàÂÆüË£ÖÂÆå‰∫Ü„ÄÇ
        </div>
      </div>
    </div>

    <script>
      /* --- DUSTFALL Ver 3.0 Logic --- */

      // Types & Constants
      const TYPES = {
        ATK: "ATTACK",
        GRD: "GUARD",
        BRK: "BREAK",
        SP: "SPECIAL",
        NONE: "NONE",
      };
      const MAX_EP = 7;
      const MAX_SP = 8;

      // Deck Definition (Based on Specs)
      const BASE_DECK = [
        {
          id: "a3",
          type: TYPES.ATK,
          cost: 3,
          name: "Âº∑Attack",
          desc: "Armor„ÅÇ„Çä",
        },
        {
          id: "a2a",
          type: TYPES.ATK,
          cost: 2,
          name: "ÈÄüAttack",
          desc: "Ê®ôÊ∫ñÊîªÊíÉ",
        },
        {
          id: "a2b",
          type: TYPES.ATK,
          cost: 2,
          name: "ÈÄüAttack",
          desc: "Ê®ôÊ∫ñÊîªÊíÉ",
        },
        {
          id: "g3",
          type: TYPES.GRD,
          cost: 3,
          name: "Â†ÖGuard",
          desc: "ÈâÑÂ£ÅÈò≤Âæ°",
        },
        {
          id: "g2",
          type: TYPES.GRD,
          cost: 2,
          name: "ËªΩGuard",
          desc: "Ê®ôÊ∫ñÈò≤Âæ°",
        },
        {
          id: "b3",
          type: TYPES.BRK,
          cost: 3,
          name: "Âº∑Break",
          desc: "‰ΩìÂã¢Â¥©„Åó(Â§ß)",
        },
        {
          id: "b2",
          type: TYPES.BRK,
          cost: 2,
          name: "ÈÄüBreak",
          desc: "‰ΩìÂã¢Â¥©„Åó",
        },
        {
          id: "g1",
          type: TYPES.GRD,
          cost: 1,
          name: "Â∞èGuard",
          desc: "Á∑äÊÄ•Èò≤Âæ°",
        }, // Added for low cost curve
        {
          id: "b2b",
          type: TYPES.BRK,
          cost: 2,
          name: "ÈÄüBreak",
          desc: "‰ΩìÂã¢Â¥©„Åó",
        }, // Filler
        {
          id: "a3b",
          type: TYPES.ATK,
          cost: 3,
          name: "Âº∑Attack",
          desc: "Armor„ÅÇ„Çä",
        }, // Filler
      ];

      const SP_CARD = {
        id: "sp",
        type: TYPES.SP,
        cost: 5,
        name: "SPÂøÖÊÆ∫",
        desc: "ÊúÄÂº∑„ÅÆ‰∏ÄÊíÉ",
      };

      // Game State
      let state = {
        turn: 1,
        phase: "DRAW", // DRAW, INPUT, RESOLVE
        isPlayerFirst: true,

        player: {
          hp: 100,
          maxHp: 100,
          pos: 50,
          maxPos: 50,
          ep: 7,
          sp: 2,
          hand: [],
          slots: [null, null], // Selected cards
          isBurnout: false,
          nextTurnBurnout: false,
          isStunned: false,
          counterUsed: false,
          counterActive: false,
        },

        enemy: {
          hp: 100,
          maxHp: 100,
          pos: 50,
          maxPos: 50,
          ep: 7,
          sp: 2,
          hand: [],
          slots: [null, null],
          isBurnout: false,
          nextTurnBurnout: false,
          isStunned: false,
          handIntel: { ATK: 0, GRD: 0, BRK: 0, SP: 0 },
        },
      };

      // --- Initialization ---
      function initGame() {
        log("Battle Start! ÂÖàÊîªÂæåÊîª„ÅØ„Çø„Éº„É≥ÊØé„Å´ÂÖ•„ÇåÊõø„Çè„Çä„Åæ„Åô„ÄÇ");
        startTurn();
      }

      function startTurn() {
        state.phase = "DRAW";
        state.isPlayerFirst = state.turn % 2 !== 0;

        // Resource Recovery & Status Check
        [state.player, state.enemy].forEach((char) => {
          // Recover EP (If burnout, handled later)
          char.ep = Math.min(char.ep + 3, MAX_EP);
          char.sp = Math.min(char.sp + 1, MAX_SP);
          char.pos = Math.min(char.pos + 5, char.maxPos);

          // Resolve Burnout from previous turn
          if (char.nextTurnBurnout) {
            char.isBurnout = true;
            char.nextTurnBurnout = false;
            log(
              `${
                char === state.player ? "Player" : "Enemy"
              } „ÅØ„Éê„Éº„É≥„Ç¢„Ç¶„ÉàÁä∂ÊÖãÔºÅ(Èò≤Âæ°‰∏çÂèØ/Ë¢´„ÉÄ„É°Â¢ó)`,
              "log-burnout"
            );
          } else {
            char.isBurnout = false;
          }

          // Resolve Stun
          if (char.isStunned) {
            char.isStunned = false; // Stun lasts 1 turn, simply skip action later
            // Stun recovery resets posture? Let's say yes for gameplay flow
            char.pos = char.maxPos;
          }

          // Clear slots
          char.slots = [null, null];
          char.counterActive = false;
        });

        // Draw Hands
        drawHand(state.player);
        drawHand(state.enemy);

        // Calculate Enemy Intel
        updateEnemyIntel();

        // UI Update
        renderHand();
        updateStats();

        log(
          `--- TURN ${state.turn} (${
            state.isPlayerFirst ? "ÂÖàÊîª" : "ÂæåÊîª"
          }) ---`,
          "log-turn"
        );

        if (state.isPlayerFirst) {
          document.getElementById("msg-area").innerText =
            "„ÅÇ„Å™„Åü„ÅÆÂÖàÊîª„Åß„Åô„ÄÇÊâãÊú≠„Åã„ÇâË°åÂãï„ÇíÈÅ∏Êäû„ÄÇ";
          document.getElementById("enemy-move-hint").style.display = "none";
        } else {
          // Enemy moves first logic immediately for display?
          // Actually, if Player is 2nd, Enemy moves "secretly" first.
          enemyAI();
          const eCost =
            (state.enemy.slots[0]?.cost || 0) +
            (state.enemy.slots[1]?.cost || 0);
          document.getElementById(
            "msg-area"
          ).innerText = `ÂæåÊîª„Åß„Åô„ÄÇÊïµ„ÅØ EP:${eCost} „ÇíÊ∂àË≤ª„Åó„Å¶ÂæÖÊ©ü‰∏≠„ÄÇ`;
          document.getElementById("e-ep-reveal").innerText = eCost;
          document.getElementById("enemy-move-hint").style.display = "block";

          // Counter check
          const spLikely = eCost >= 5;
          if (spLikely && !state.player.counterUsed) {
            document.getElementById("counter-area").style.display = "block";
          } else {
            document.getElementById("counter-area").style.display = "none";
          }
        }

        state.phase = "INPUT";
        updateStats();
      }

      function drawHand(char) {
        // Simple Shuffle & Draw 4
        let deck = [...BASE_DECK];
        // If SP Max, add SP Card to pool
        if (char.sp >= MAX_SP) {
          deck.push(SP_CARD);
        }

        // Shuffle
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }

        char.hand = deck.slice(0, 4);

        // Assign unique IDs to hand cards to track selection
        char.hand = char.hand.map((c, idx) => ({ ...c, uid: `h_${idx}` }));
      }

      function updateEnemyIntel() {
        const h = state.enemy.hand;
        state.enemy.handIntel = {
          ATK: h.filter((c) => c.type === TYPES.ATK).length,
          GRD: h.filter((c) => c.type === TYPES.GRD).length,
          BRK: h.filter((c) => c.type === TYPES.BRK).length,
          SP: h.filter((c) => c.type === TYPES.SP).length,
        };

        const ei = state.enemy.handIntel;
        const html = `
            <span style="color:#e74c3c">‚öîÔ∏è${ei.ATK}</span>
            <span style="color:#3498db">üõ°Ô∏è${ei.GRD}</span>
            <span style="color:#f1c40f">üí•${ei.BRK}</span>
            ${ei.SP > 0 ? '<span style="color:#9b59b6">üöÄSP!</span>' : ""}
        `;
        document.getElementById("e-hand-intel").innerHTML = html;
      }

      // --- Player Input ---
      function renderHand() {
        const container = document.getElementById("p-hand");
        container.innerHTML = "";

        state.player.hand.forEach((card) => {
          const div = document.createElement("div");
          div.className = `card type-${card.type
            .toLowerCase()
            .substring(0, 3)}`;
          if (state.player.isBurnout && card.type === TYPES.GRD) {
            div.classList.add("disabled");
            div.title = "Burnout‰∏≠„ÅØ‰ΩøÁî®‰∏çÂèØ";
          }
          if (state.player.slots.includes(card)) {
            div.classList.add("selected");
          }

          div.innerHTML = `
                <div class="card-cost">${card.cost}</div>
                <div class="card-type">${card.name}</div>
                <div class="card-sub">${card.type}</div>
                <div class="card-desc">${card.desc}</div>
            `;

          div.onclick = () => selectCard(card);
          container.appendChild(div);
        });
      }

      function selectCard(card) {
        if (state.phase !== "INPUT") return;
        if (state.player.isBurnout && card.type === TYPES.GRD) {
          log("Burnout‰∏≠„ÅØ„Ç¨„Éº„Éâ„ÇíÈÅ∏Êäû„Åß„Åç„Åæ„Åõ„ÇìÔºÅ", "log-burnout");
          return;
        }

        // Toggle logic
        const p = state.player;
        const index = p.slots.indexOf(card);

        if (index > -1) {
          // Remove
          p.slots[index] = null;
          // Shift if slot 1 removed but slot 2 exists
          if (p.slots[0] === null && p.slots[1] !== null) {
            p.slots[0] = p.slots[1];
            p.slots[1] = null;
          }
        } else {
          // Add
          if (p.slots[0] === null) p.slots[0] = card;
          else if (p.slots[1] === null) p.slots[1] = card;
          else return; // Full
        }

        updateSlotUI();
        renderHand();
      }

      function removeSlot(num) {
        if (state.phase !== "INPUT") return;
        const p = state.player;
        if (p.slots[num - 1]) {
          p.slots[num - 1] = null;
          // Shift
          if (num === 1 && p.slots[1]) {
            p.slots[0] = p.slots[1];
            p.slots[1] = null;
          }
          updateSlotUI();
          renderHand();
        }
      }

      function updateSlotUI() {
        const s1 = state.player.slots[0];
        const s2 = state.player.slots[1];

        const fill = (elId, card) => {
          const el = document.getElementById(elId);
          const txt = document.getElementById(elId + "-txt");
          if (card) {
            el.classList.add("filled");
            el.className = `slot-box filled type-${card.type
              .toLowerCase()
              .substring(0, 3)}`;
            txt.innerText = `${card.name} (Cost ${card.cost})`;
          } else {
            el.className = "slot-box";
            txt.innerText = "Empty";
          }
        };

        fill("slot1", s1);
        fill("slot2", s2);

        // Calc Cost
        const total = (s1 ? s1.cost : 0) + (s2 ? s2.cost : 0);
        const costEl = document.getElementById("current-cost");
        costEl.innerText = total;

        const btn = document.getElementById("commit-btn");
        if (total > state.player.ep) {
          costEl.style.color = "#e74c3c";
          btn.disabled = true;
          btn.innerText = "EP‰∏çË∂≥";
        } else {
          costEl.style.color = "#fff";
          btn.disabled = false;
          btn.innerText = "„Çø„Éº„É≥ÂÆüË°å";
        }
      }

      // SP Counter Toggle
      document.getElementById("btn-counter").onclick = function () {
        state.player.counterActive = !state.player.counterActive;
        this.classList.toggle("selected");
      };

      function commitTurn() {
        // AI Decision (if Player was first)
        if (state.isPlayerFirst) {
          enemyAI();
        }

        state.phase = "RESOLVE";
        resolveBattle();
      }

      // --- AI Logic (Ver 3.0) ---
      function enemyAI() {
        const e = state.enemy;
        const pHand = state.player.hand;

        // Analyze Player Weakness
        const pGuardCount = pHand.filter((c) => c.type === TYPES.GRD).length;
        const pIsBurnout = state.player.isBurnout;

        // AI Personality: "Opportunist"
        // If Player has no guards or is burnout, prioritize ATTACK
        let desireType = null;
        if (pGuardCount === 0 || pIsBurnout) desireType = TYPES.ATK;

        // Filter playable cards (Check Burnout restriction)
        let playable = e.hand.filter(
          (c) => !(e.isBurnout && c.type === TYPES.GRD)
        );

        // Sort by priority
        // 1. SP (if available)
        // 2. Desired Type (if any)
        // 3. High Cost (Armor)
        playable.sort((a, b) => {
          if (a.type === TYPES.SP) return -1;
          if (b.type === TYPES.SP) return 1;
          if (desireType) {
            if (a.type === desireType && b.type !== desireType) return -1;
            if (b.type === desireType && a.type !== desireType) return 1;
          }
          return b.cost - a.cost; // Higher cost first
        });

        // Select Cards fitting EP
        e.slots = [null, null];
        let currentEP = e.ep;

        if (playable.length > 0 && playable[0].cost <= currentEP) {
          e.slots[0] = playable[0];
          currentEP -= playable[0].cost;

          // Try Slot 2
          const remaining = playable.filter(
            (c) => c !== e.slots[0] && c.cost <= currentEP
          );
          if (remaining.length > 0) {
            e.slots[1] = remaining[0];
          }
        }
      }

      // --- Resolution Logic ---
      function resolveBattle() {
        const p = state.player;
        const e = state.enemy;

        // Use Wait for empty slots
        const ensureCmd = (cmd) =>
          cmd || { type: TYPES.NONE, cost: 0, name: "Wait" };

        const pS1 = ensureCmd(p.slots[0]);
        const pS2 = ensureCmd(p.slots[1]);
        const eS1 = ensureCmd(e.slots[0]);
        const eS2 = ensureCmd(e.slots[1]);

        log("=== Ëß£Ê±∫„Éï„Çß„Éº„Ç∫ ===");
        log(`Player: [${pS1.name}] -> [${pS2.name}]`);
        log(`Enemy : [${eS1.name}] -> [${eS2.name}]`);

        // 1. Counter Check
        if (p.counterActive) {
          p.counterUsed = true;
          if (eS1.type === TYPES.SP || eS2.type === TYPES.SP) {
            log("‚ö° SP Counter ÊàêÂäüÔºÅ Êïµ„ÅÆSPÊäÄ„ÇíÁÑ°ÂäπÂåñÔºÜ„Çπ„Çø„É≥ÔºÅ", "log-armor");
            e.isStunned = true;
            eS1.type = TYPES.NONE; // Cancel
            eS2.type = TYPES.NONE;
            e.sp = 0;
          } else {
            log("SP Counter Â§±Êïó... (Ê®©Âà©Ê∂àÂ§±)", "log-dmg");
          }
        }

        // Stun Check (Skip turn if stunned)
        // (Simplified: Stunned char does nothing)
        const pAct = p.isStunned ? { type: TYPES.NONE, cost: 0 } : pS1;
        const eAct = e.isStunned ? { type: TYPES.NONE, cost: 0 } : eS1;

        // Slot 1
        let pMod = 1.0,
          eMod = 1.0;

        if (!p.isStunned && !e.isStunned) {
          const res1 = resolveClash(pS1, eS1, 1.0, 1.0);
          if (res1.winner === "PLAYER") {
            log(`>> Slot 1: Player Win! (${res1.reason})`, "log-armor");
            pMod = 1.5;
            eMod = 0.5;
          } else if (res1.winner === "ENEMY") {
            log(`>> Slot 1: Enemy Win! (${res1.reason})`, "log-dmg");
            pMod = 0.5;
            eMod = 1.5;
          } else {
            log(`>> Slot 1: Draw/None.`);
          }
        }

        // Slot 2
        if (!p.isStunned && !e.isStunned) {
          resolveClash(pS2, eS2, pMod, eMod);
        }

        // EP Consumption & Burnout Check
        p.ep = Math.max(0, p.ep - (pS1.cost + pS2.cost));
        e.ep = Math.max(0, e.ep - (eS1.cost + eS2.cost));

        if (p.ep === 0) p.nextTurnBurnout = true;
        if (e.ep === 0) e.nextTurnBurnout = true;

        updateStats();

        // End Check
        if (p.hp <= 0 || e.hp <= 0) {
          setTimeout(() => alert(p.hp <= 0 ? "You Died..." : "You Win!"), 100);
        } else {
          state.turn++;
          setTimeout(startTurn, 2500);
        }
      }

      function resolveClash(pCmd, eCmd, pMod, eMod) {
        // --- Priority Logic ---
        // 1. Same Type? -> Armor Check (Cost)
        if (pCmd.type !== TYPES.NONE && pCmd.type === eCmd.type) {
          if (pCmd.cost > eCmd.cost) {
            applyAction(state.player, state.enemy, pCmd, pMod, true);
            return {
              winner: "PLAYER",
              reason: `Armor Crush! Cost ${pCmd.cost} > ${eCmd.cost}`,
            };
          } else if (eCmd.cost > pCmd.cost) {
            applyAction(state.enemy, state.player, eCmd, eMod, true);
            return {
              winner: "ENEMY",
              reason: `Armor Crush! Cost ${eCmd.cost} > ${pCmd.cost}`,
            };
          } else {
            // Clash (Small dmg both)
            applyDamage(state.player, 5, "POS");
            applyDamage(state.enemy, 5, "POS");
            return { winner: "DRAW", reason: "Clash" };
          }
        }

        // 2. Triangle Check
        const tri = getTriangle(pCmd.type, eCmd.type);
        if (tri === 1) {
          // Player Win
          applyAction(state.player, state.enemy, pCmd, pMod, true);
          applyAction(state.enemy, state.player, eCmd, eMod, false); // Loser hits weak or miss
          return { winner: "PLAYER", reason: "Type Adv" };
        } else if (tri === -1) {
          // Enemy Win
          applyAction(state.enemy, state.player, eCmd, eMod, true);
          applyAction(state.player, state.enemy, pCmd, pMod, false);
          return { winner: "ENEMY", reason: "Type Adv" };
        } else {
          // Both hit (e.g. Wait vs Attack, or None vs None)
          if (pCmd.type !== TYPES.NONE)
            applyAction(state.player, state.enemy, pCmd, pMod, true);
          if (eCmd.type !== TYPES.NONE)
            applyAction(state.enemy, state.player, eCmd, eMod, true);
          return { winner: "DRAW", reason: "Neutral" };
        }
      }

      function getTriangle(t1, t2) {
        if (t1 === TYPES.NONE || t2 === TYPES.NONE) return 0;
        if (t1 === TYPES.ATK && t2 === TYPES.BRK) return 1;
        if (t1 === TYPES.BRK && t2 === TYPES.GRD) return 1;
        if (t1 === TYPES.GRD && t2 === TYPES.ATK) return 1;
        if (t1 === t2) return 0; // Handled by armor
        return -1;
      }

      function applyAction(actor, target, cmd, mod, isWin) {
        if (!isWin && (cmd.type === TYPES.ATK || cmd.type === TYPES.BRK))
          return; // Lost exchanges deal 0? Or Chip? Let's say 0 for strictness

        let val = 0;
        let type = "HP";

        if (cmd.type === TYPES.ATK) {
          val = (cmd.cost >= 3 ? 20 : 10) * mod;
          // Burnout bonus
          if (target.isBurnout) val *= 1.5;
        } else if (cmd.type === TYPES.BRK) {
          val = 20 * mod;
          type = "POS";
        } else if (cmd.type === TYPES.SP) {
          val = 50;
          // Reset SP
          actor.sp = 0;
        }

        if (val > 0) applyDamage(target, val, type);
      }

      function applyDamage(target, val, type) {
        val = Math.floor(val);
        if (target.isStunned) val *= 2; // Stun Dmg

        if (type === "HP") {
          target.hp = Math.max(0, target.hp - val);
          log(
            `${target === state.player ? "Player" : "Enemy"} HP -${val}`,
            "log-dmg"
          );
        } else {
          target.pos = Math.max(0, target.pos - val);
          log(
            `${target === state.player ? "Player" : "Enemy"} Pos -${val}`,
            "log-pos"
          );
          if (target.pos === 0) {
            log(">>> BREAK (STUN) <<<", "log-armor");
            target.isStunned = true; // Immediate effect or next turn? Spec says next turn action lost.
          }
        }
      }

      function updateStats() {
        const set = (id, cur, max) =>
          (document.getElementById(id).style.width = (cur / max) * 100 + "%");
        const p = state.player,
          e = state.enemy;

        set("p-hp-bar", p.hp, p.maxHp);
        set("p-pos-bar", p.pos, p.maxPos);
        set("p-sp-bar", p.sp, MAX_SP);
        document.getElementById("p-hp-txt").innerText = p.hp;
        document.getElementById("p-pos-txt").innerText = p.pos;
        document.getElementById("p-sp-txt").innerText = p.sp;
        document.getElementById("p-ep").innerText = p.ep;

        set("e-hp-bar", e.hp, e.maxHp);
        set("e-pos-bar", e.pos, e.maxPos);
        set("e-sp-bar", e.sp, MAX_SP);
        document.getElementById("e-hp-txt").innerText = e.hp;
        document.getElementById("e-pos-txt").innerText = e.pos;
        document.getElementById("e-sp-txt").innerText = e.sp;

        // Burnout styling
        const toggleBurn = (boxId, isBurn) => {
          const b = document.getElementById(boxId);
          if (isBurn) b.classList.add("burnout");
          else b.classList.remove("burnout");
        };
        toggleBurn("p-box", p.isBurnout);
        toggleBurn("e-box", e.isBurnout);

        document.getElementById("e-burnout-warn").style.display = e.isBurnout
          ? "block"
          : "none";
      }

      function log(msg, cls = "") {
        const l = document.getElementById("log");
        const d = document.createElement("div");
        d.className = `log-entry ${cls}`;
        d.innerText = msg;
        l.prepend(d);
      }

      window.onload = initGame;
    </script>
  </body>
</html>
